import { createRequire as __createRequire } from 'node:module';
import { fileURLToPath as __fileURLToPath } from 'node:url';
import { dirname as __dirname_ } from 'node:path';
const require = __createRequire(import.meta.url);
const __filename = __fileURLToPath(import.meta.url);
const __dirname = __dirname_(__filename);
import {
  emitFlagsDatafiles
} from "./chunks/chunk-AWCPEMR2.js";
import {
  indent_default
} from "./chunks/chunk-A3NYPUKZ.js";
import {
  box,
  did_you_mean_default,
  executeUpgrade
} from "./chunks/chunk-AVBVDIVA.js";
import {
  getUpdateCommand,
  isGlobal
} from "./chunks/chunk-7E44U65V.js";
import {
  Now,
  collectContactInformation,
  createCertForCns,
  displayBuildLogs,
  displayRuntimeLogs,
  extractDomain,
  getDomain,
  getDomainByName,
  getDomainPrice,
  getDomainStatus,
  isDeploying,
  isWildcardAlias,
  pollForOrder,
  printDeploymentStatus,
  purchaseDomain,
  require_cjs,
  require_date_fns,
  require_format,
  require_jsonlines,
  setupDomain
} from "./chunks/chunk-PQABRSPJ.js";
import {
  login,
  processRevocationResponse,
  require_open,
  revocationRequest,
  sleep,
  ua_default,
  writeToAuthConfigFile,
  writeToConfigFile
} from "./chunks/chunk-74F7S6QJ.js";
import "./chunks/chunk-LTWXVGGJ.js";
import {
  getCustomEnvironments,
  getInvalidSubcommand,
  pickCustomEnvironment,
  readStandardInput,
  require_dist as require_dist3
} from "./chunks/chunk-LCYROVUM.js";
import {
  formatTable
} from "./chunks/chunk-CNJPNT3A.js";
import "./chunks/chunk-2TX2KBK2.js";
import {
  getCommandFlags,
  isValidName
} from "./chunks/chunk-I63FYLJU.js";
import {
  getDeployment,
  mapCertError,
  toHost
} from "./chunks/chunk-75TPDDWM.js";
import {
  getScope
} from "./chunks/chunk-SRPVI3PV.js";
import {
  formatEnvironment,
  validateLsArgs
} from "./chunks/chunk-3U5VDZM5.js";
import {
  validateJsonOutput
} from "./chunks/chunk-XPKWKPWA.js";
import {
  getSubcommand as getSubcommand3
} from "./chunks/chunk-YPQSDAEW.js";
import {
  abortSubcommand,
  addStoreSubcommand,
  addSubcommand,
  addSubcommand2,
  addSubcommand3,
  addSubcommand4,
  addSubcommand5,
  addSubcommand7 as addSubcommand6,
  addSubcommand8 as addSubcommand7,
  addSubcommand9 as addSubcommand8,
  aliasCommand,
  apiCommand,
  approveSubcommand,
  archiveSubcommand,
  balanceSubcommand,
  bisectCommand,
  blobCommand,
  buySubcommand,
  cacheCommand,
  certsCommand,
  completeSubcommand,
  configureSubcommand,
  connectSubcommand,
  contractCommand,
  copySubcommand,
  createStoreSubcommand,
  createSubcommand,
  createThresholdSubcommand,
  curlCommand,
  dangerouslyDeleteSubcommand,
  delSubcommand,
  deleteStoreSubcommand,
  disableSubcommand,
  disableSubcommand2,
  disableSubcommand3,
  disconnectSubcommand,
  disconnectSubcommand2,
  discoverSubcommand,
  dnsCommand,
  domainsCommand,
  enableSubcommand,
  enableSubcommand2,
  enableSubcommand3,
  fetchSubcommand,
  flagsCommand,
  flushSubcommand,
  getCommandAliases,
  getStoreInfoSubcommand,
  getStoreSubcommand,
  getSubcommand,
  getSubcommand2,
  gitCommand,
  guidanceCommand,
  guideSubcommand,
  httpstatCommand,
  importSubcommand,
  initCommand,
  inspectCommand,
  inspectSubcommand,
  inspectSubcommand2,
  inspectSubcommand3,
  installCommand,
  integrationCommand,
  integrationResourceCommand,
  invalidateSubcommand,
  inviteSubcommand,
  issueSubcommand,
  listSubcommand,
  listSubcommand10,
  listSubcommand11,
  listSubcommand12,
  listSubcommand13,
  listSubcommand2,
  listSubcommand3,
  listSubcommand4,
  listSubcommand5,
  listSubcommand6,
  listSubcommand7,
  listSubcommand8,
  listSubcommand9,
  listVersionsSubcommand,
  logoutCommand,
  logsCommand,
  mcpCommand,
  microfrontendsCommand,
  moveSubcommand,
  openCommand,
  openSubcommand,
  prepareSubcommand,
  projectCommand,
  promoteCommand,
  promoteSubcommand,
  pullSubcommand,
  purgeSubcommand,
  putSubcommand,
  redeployCommand,
  redirectsCommand,
  removeCommand,
  removeStoreSubcommand,
  removeSubcommand,
  removeSubcommand10,
  removeSubcommand2,
  removeSubcommand3,
  removeSubcommand4,
  removeSubcommand5,
  removeSubcommand6,
  removeSubcommand7,
  removeSubcommand8,
  removeSubcommand9,
  restoreSubcommand,
  rollbackCommand,
  rollingReleaseCommand,
  sdkKeysAddSubcommand,
  sdkKeysListSubcommand,
  sdkKeysRemoveSubcommand,
  sdkKeysSubcommand,
  setSubcommand,
  startSubcommand,
  statusSubcommand,
  statusSubcommand2,
  statusSubcommand3,
  statusSubcommand4,
  storeSubcommand,
  switchSubcommand,
  targetCommand,
  teamsCommand,
  telemetryCommand,
  transferInSubcommand,
  upgradeCommand,
  uploadSubcommand,
  usageCommand,
  webhooksCommand,
  whoamiCommand
} from "./chunks/chunk-LFXZ5E5S.js";
import "./chunks/chunk-M3N5RQLZ.js";
import {
  metricsCommand,
  schemaSubcommand
} from "./chunks/chunk-NJKAUXT4.js";
import "./chunks/chunk-DYV4NBAT.js";
import {
  main
} from "./chunks/chunk-D4QJ2SOI.js";
import "./chunks/chunk-GT5YMUDW.js";
import {
  require_dist as require_dist2,
  require_tar_fs
} from "./chunks/chunk-BFAZVUS3.js";
import {
  require_lib as require_lib3
} from "./chunks/chunk-LLPVFNNI.js";
import {
  require_execa
} from "./chunks/chunk-UPNWDVQF.js";
import "./chunks/chunk-H5G734TV.js";
import {
  ensureLink
} from "./chunks/chunk-V4BYOHHC.js";
import "./chunks/chunk-VNW7226M.js";
import "./chunks/chunk-ISCLKSE2.js";
import "./chunks/chunk-ZGVB6SQH.js";
import "./chunks/chunk-DI7L4B4K.js";
import {
  help
} from "./chunks/chunk-6LTRH3B2.js";
import {
  table
} from "./chunks/chunk-5QN5JFM3.js";
import {
  TelemetryClient,
  checkExistsAndConnect,
  createEnvObject,
  createGitMeta,
  createProject,
  disconnectGitProvider,
  elapsed,
  formatProject,
  getLinkedProject,
  getProjectByNameOrId,
  getTeamById,
  getTeams,
  getUser,
  global_path_default,
  humanizePath,
  list,
  param,
  parseGitConfig,
  parseRepoUrl,
  pluckRemoteUrls,
  printRemoteUrls,
  pull,
  require_frameworks,
  require_lib,
  require_ms,
  selectAndParseRemoteUrl,
  stamp_default
} from "./chunks/chunk-BNSR2EP5.js";
import {
  APIError,
  AliasInUse,
  CertConfigurationError,
  CertError,
  CertMissing,
  CertNotFound,
  CertOrderNotFound,
  CertsPermissionDenied,
  DNSConflictingRecord,
  DNSInvalidPort,
  DNSInvalidType,
  DNSPermissionDenied,
  DeploymentFailedAliasImpossible,
  DeploymentNotFound,
  DeploymentNotReady,
  DeploymentPermissionDenied,
  DomainAlreadyExists,
  DomainExternal,
  DomainMoveConflict,
  DomainNotAvailable,
  DomainNotFound,
  DomainNotVerified,
  DomainPaymentError,
  DomainPermissionDenied,
  DomainPurchasePending,
  DomainRemovalConflict,
  InvalidAlias,
  InvalidAliasInConfig,
  InvalidDeploymentId,
  InvalidDomain,
  InvalidMoveDestination,
  NoAliasInConfig,
  NowError,
  ProjectNotFound,
  SourceNotFound,
  TLDNotSupportedViaCLI,
  TooManyRequests,
  UnexpectedDomainPurchaseError,
  UnexpectedDomainTransferError,
  UnsupportedTLD,
  UserAborted,
  cmd,
  code,
  getCommandName,
  getFlagsSpecification,
  isAPIError,
  packageName,
  parseArguments,
  printError,
  require_bytes,
  require_lib as require_lib2,
  require_pluralize
} from "./chunks/chunk-3J2XL77M.js";
import {
  emoji,
  eraseLines,
  init_pkg,
  link_default,
  output_manager_default,
  pkg_default,
  prependEmoji,
  require_dist
} from "./chunks/chunk-7K6FEHYP.js";
import {
  __require,
  __toESM,
  require_source
} from "./chunks/chunk-A2M6YJ6J.js";

// src/commands/alias/ls.ts
var import_chalk = __toESM(require_source(), 1);
var import_ms = __toESM(require_ms(), 1);

// src/util/alias/get-aliases.ts
async function getAliases(client, deploymentId, next, limit = 20) {
  let aliasUrl = `/v3/now/aliases?limit=${limit}`;
  if (next) {
    aliasUrl += `&until=${next}`;
  }
  const to = deploymentId ? `/now/deployments/${deploymentId}/aliases` : aliasUrl;
  try {
    const payload = await client.fetch(to);
    return payload;
  } catch (err) {
    if (isAPIError(err)) {
      const contextName = await getScope(client).then(
        (scope) => scope.contextName
      );
      if (err.status === 404) {
        throw new DeploymentNotFound({
          id: deploymentId,
          context: contextName
        });
      }
      if (err.status === 403 && deploymentId) {
        throw new DeploymentPermissionDenied(deploymentId, contextName);
      }
      if (err.status === 400 && err.message.includes("`id`") && deploymentId) {
        throw new InvalidDeploymentId(deploymentId);
      }
    }
    throw err;
  }
}

// src/util/get-pagination-opts.ts
function getPaginationOpts(opts) {
  const { "--next": nextTimestamp, "--limit": limit } = opts;
  if (typeof nextTimestamp !== void 0 && Number.isNaN(nextTimestamp)) {
    throw new Error("Please provide a number for option --next");
  }
  if (typeof limit === "number" && (!Number.isInteger(limit) || limit > 100 || limit < 1)) {
    throw new Error(
      "Please provide an integer from 1 to 100 for option --limit"
    );
  }
  return [nextTimestamp, limit];
}

// src/util/telemetry/commands/alias/list.ts
var AliasListTelemetryClient = class extends TelemetryClient {
  trackCliOptionLimit(limit) {
    if (limit) {
      this.trackCliOption({
        option: "limit",
        value: String(limit)
      });
    }
  }
  trackCliOptionNext(next) {
    if (next) {
      this.trackCliOption({
        option: "next",
        value: this.redactedValue
      });
    }
  }
};

// src/commands/alias/ls.ts
async function ls(client, argv) {
  let parsedArguments;
  const flagsSpecification = getFlagsSpecification(listSubcommand.options);
  try {
    parsedArguments = parseArguments(argv, flagsSpecification);
  } catch (err) {
    printError(err);
    return 1;
  }
  const { args, flags: opts } = parsedArguments;
  const validationResult = validateLsArgs({
    commandName: "alias ls",
    args
  });
  if (validationResult !== 0) {
    return validationResult;
  }
  const { contextName } = await getScope(client);
  const telemetryClient = new AliasListTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  let paginationOptions;
  const formatResult = validateJsonOutput(opts);
  if (!formatResult.valid) {
    output_manager_default.error(formatResult.error);
    return 1;
  }
  const asJson = formatResult.jsonOutput;
  try {
    paginationOptions = getPaginationOpts(opts);
    const [next, limit] = paginationOptions;
    telemetryClient.trackCliOptionNext(next);
    telemetryClient.trackCliOptionLimit(limit);
    telemetryClient.trackCliOptionFormat(opts["--format"]);
  } catch (err) {
    output_manager_default.prettyError(err);
    return 1;
  }
  const lsStamp = stamp_default();
  output_manager_default.spinner(`Fetching aliases under ${import_chalk.default.bold(contextName)}`);
  const { aliases, pagination } = await getAliases(
    client,
    void 0,
    ...paginationOptions
  );
  if (asJson) {
    output_manager_default.stopSpinner();
    const jsonOutput = {
      aliases: aliases.map((a) => ({
        alias: a.alias,
        deploymentId: a.deploymentId,
        url: a.deployment?.url ?? null,
        createdAt: a.createdAt
      })),
      pagination
    };
    client.stdout.write(`${JSON.stringify(jsonOutput, null, 2)}
`);
  } else {
    output_manager_default.log(`aliases found under ${import_chalk.default.bold(contextName)} ${lsStamp()}`);
    client.stdout.write(printAliasTable(aliases));
    if (pagination.count === 20) {
      const flags = getCommandFlags(opts, ["_", "--next", "--format"]);
      output_manager_default.log(
        `To display the next page run ${getCommandName(
          `alias ls${flags} --next ${pagination.next}`
        )}`
      );
    }
  }
  return 0;
}
function printAliasTable(aliases) {
  return `${table(
    [
      ["source", "url", "age"].map((header) => import_chalk.default.gray(header)),
      ...aliases.map((a) => [
        // for legacy reasons, we might have situations
        // where the deployment was deleted and the alias
        // not collected appropriately, and we need to handle it
        a.deployment?.url ? a.deployment.url : import_chalk.default.gray("\u2013"),
        a.alias,
        (0, import_ms.default)(Date.now() - a.createdAt)
      ])
    ],
    { align: ["l", "l", "r"], hsep: 4 }
  ).replace(/^/gm, "  ")}

`;
}

// src/commands/alias/rm.ts
var import_chalk2 = __toESM(require_source(), 1);
var import_ms2 = __toESM(require_ms(), 1);

// src/util/alias/remove-alias-by-id.ts
async function removeAliasById(client, id) {
  return client.fetch(`/now/aliases/${id}`, {
    method: "DELETE"
  });
}

// src/util/alias/find-alias-by-alias-or-id.ts
async function findAliasByAliasOrId(client, aliasOrId) {
  return client.fetch(
    `/now/aliases/${encodeURIComponent(getSafeAlias(aliasOrId))}`
  );
}
function getSafeAlias(alias2) {
  return alias2.replace(/^https:\/\//i, "").replace(/^\.+/, "").replace(/\.+$/, "").toLowerCase();
}

// src/util/telemetry/commands/alias/remove.ts
var AliasRemoveTelemetryClient = class extends TelemetryClient {
  trackCliArgumentAlias(alias2) {
    if (alias2) {
      this.trackCliArgument({
        arg: "alias",
        value: this.redactedValue
      });
    }
  }
  trackCliFlagYes(yes) {
    if (yes) {
      this.trackCliFlag("yes");
    }
  }
};

// src/commands/alias/rm.ts
async function rm(client, argv) {
  let parsedArguments;
  const flagsSpecification = getFlagsSpecification(removeSubcommand.options);
  try {
    parsedArguments = parseArguments(argv, flagsSpecification);
  } catch (err) {
    printError(err);
    return 1;
  }
  const { args, flags: opts } = parsedArguments;
  const { contextName } = await getScope(client);
  const telemetryClient = new AliasRemoveTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  telemetryClient.trackCliFlagYes(opts["--yes"]);
  const [aliasOrId] = args;
  telemetryClient.trackCliArgumentAlias(aliasOrId);
  if (args.length !== 1) {
    output_manager_default.error(
      `Invalid number of arguments. Usage: ${import_chalk2.default.cyan(
        `${getCommandName("alias rm <alias>")}`
      )}`
    );
    return 1;
  }
  if (!aliasOrId) {
    output_manager_default.error(`${getCommandName("alias rm <alias>")} expects one argument`);
    return 1;
  }
  if (!isValidName(aliasOrId)) {
    output_manager_default.error(`The provided argument "${aliasOrId}" is not a valid alias`);
    return 1;
  }
  const alias2 = await findAliasByAliasOrId(client, aliasOrId);
  if (!alias2) {
    output_manager_default.error(
      `Alias not found by "${aliasOrId}" under ${import_chalk2.default.bold(contextName)}`
    );
    output_manager_default.log(`Run ${getCommandName("alias ls")} to see your aliases.`);
    return 1;
  }
  const removeStamp = stamp_default();
  if (!opts["--yes"] && !await confirmAliasRemove(client, alias2)) {
    output_manager_default.log("Canceled");
    return 0;
  }
  await removeAliasById(client, alias2.uid);
  output_manager_default.success(`Alias ${import_chalk2.default.bold(alias2.alias)} removed ${removeStamp()}`);
  return 0;
}
async function confirmAliasRemove(client, alias2) {
  const srcUrl = alias2.deployment ? import_chalk2.default.underline(alias2.deployment.url) : null;
  const tbl = table(
    [
      [
        ...srcUrl ? [srcUrl] : [],
        import_chalk2.default.underline(alias2.alias),
        import_chalk2.default.gray(`${(0, import_ms2.default)(Date.now() - alias2.createdAt)} ago`)
      ]
    ],
    { hsep: 4 }
  );
  output_manager_default.log("The following alias will be removed permanently");
  output_manager_default.print(`  ${tbl}
`);
  return client.input.confirm(import_chalk2.default.red("Are you sure?"), false);
}

// src/commands/alias/set.ts
var import_chalk6 = __toESM(require_source(), 1);

// src/util/certs/get-wildcard-cns-for-alias.ts
var import_tldts = __toESM(require_cjs(), 1);
function getWildcardCNSForAlias(alias2) {
  if (isWildcardAlias(alias2)) {
    return [extractDomain(alias2), alias2];
  }
  const parsedDomain = (0, import_tldts.parse)(alias2);
  const { domain, subdomain } = parsedDomain;
  if (!domain) {
    throw new InvalidDomain(alias2);
  }
  const secondLevel = subdomain && subdomain.includes(".") ? subdomain.split(".").slice(1).join(".") : null;
  const root = secondLevel ? `${secondLevel}.${domain}` : domain;
  return [root, `*.${root}`];
}

// src/util/output/join-words.ts
function joinWords(words = []) {
  if (words.length === 0) {
    return "";
  }
  if (words.length === 1) {
    return words[0];
  }
  const last = words[words.length - 1];
  const rest = words.slice(0, words.length - 1);
  return `${rest.join(", ")} and ${last}`;
}

// src/util/certs/create-cert-for-alias.ts
async function createCertificateForAlias(client, context, alias2, shouldBeWildcard) {
  output_manager_default.spinner(`Generating a certificate\u2026`);
  const cns = shouldBeWildcard ? getWildcardCNSForAlias(alias2) : [alias2];
  const certStamp = stamp_default();
  const cert = await createCertForCns(client, cns, context);
  if (cert instanceof NowError) {
    output_manager_default.stopSpinner();
    return cert;
  }
  output_manager_default.log(
    `Certificate for ${joinWords(cert.cns)} (${cert.uid}) created ${certStamp()}`
  );
  return cert;
}

// src/util/alias/create-alias.ts
async function createAlias(client, contextName, deployment, alias2, externalDomain) {
  output_manager_default.spinner(`Creating alias`);
  const result = await performCreateAlias(
    client,
    contextName,
    deployment,
    alias2
  );
  output_manager_default.stopSpinner();
  if (result instanceof CertMissing) {
    const cert = await createCertificateForAlias(
      client,
      contextName,
      alias2,
      !externalDomain
    );
    if (cert instanceof Error) {
      return cert;
    }
    output_manager_default.spinner(`Creating alias`);
    const secondTry = await performCreateAlias(
      client,
      contextName,
      deployment,
      alias2
    );
    output_manager_default.stopSpinner();
    return secondTry;
  }
  return result;
}
async function performCreateAlias(client, contextName, deployment, alias2) {
  try {
    return await client.fetch(
      `/now/deployments/${deployment.id}/aliases`,
      {
        method: "POST",
        body: { alias: alias2 }
      }
    );
  } catch (err) {
    if (isAPIError(err)) {
      if (err.code === "cert_missing" || err.code === "cert_expired") {
        return new CertMissing(alias2);
      }
      if (err.status === 409) {
        return { uid: err.uid, alias: err.alias };
      }
      if (err.code === "deployment_not_found" || err.code === "not_found") {
        return new DeploymentNotFound({
          context: contextName,
          id: deployment.id
        });
      }
      if (err.code === "gone") {
        return new DeploymentFailedAliasImpossible();
      }
      if (err.code === "invalid_alias") {
        return new InvalidAlias(alias2);
      }
      if (err.code === "deployment_not_ready") {
        return new DeploymentNotReady({ url: deployment.url });
      }
      if (err.status === 403) {
        if (err.code === "alias_in_use") {
          return new AliasInUse(alias2);
        }
        if (err.code === "forbidden") {
          return new DomainPermissionDenied(alias2, contextName);
        }
      }
    }
    throw err;
  }
}

// src/util/domains/is-domain-external.ts
function isDomainExternal(domain) {
  return domain.serviceType !== "zeit.world";
}

// src/util/alias/assign-alias.ts
async function assignAlias(client, deployment, alias2, contextName) {
  let externalDomain = false;
  if (alias2.indexOf(".") !== -1 && !alias2.endsWith(".now.sh") && !alias2.endsWith(".vercel.app")) {
    const result = await setupDomain(client, alias2, contextName);
    if (result instanceof Error) {
      return result;
    }
    externalDomain = isDomainExternal(result);
  }
  const record = await createAlias(
    client,
    contextName,
    deployment,
    alias2,
    externalDomain
  );
  return record;
}

// src/util/alias/get-deployment-by-alias.ts
var import_chalk3 = __toESM(require_source(), 1);
import path from "path";

// src/util/deploy/get-deployments-by-appname.ts
async function fetchDeploymentsByAppName(client, appName) {
  const { deployments } = await client.fetch(
    `/v3/now/deployments?app=${encodeURIComponent(appName)}`
  );
  return deployments;
}

// src/util/alias/get-deployment-by-alias.ts
async function getAppLastDeployment(client, appName, user, contextName) {
  output_manager_default.debug(`Looking for deployments matching app ${appName}`);
  const deployments = await fetchDeploymentsByAppName(client, appName);
  const deploymentItem = deployments.sort((a, b) => b.created - a.created).filter((dep) => dep.state === "READY" && dep.creator.uid === user.id)[0];
  if (deploymentItem) {
    return await getDeployment(client, contextName, deploymentItem.uid);
  }
  return null;
}
async function getDeploymentForAlias(client, args, localConfigPath, user, contextName, localConfig) {
  output_manager_default.spinner(`Fetching deployment to alias in ${import_chalk3.default.bold(contextName)}`);
  if (args.length === 2) {
    const [deploymentId] = args;
    try {
      return await getDeployment(client, contextName, deploymentId);
    } finally {
      output_manager_default.stopSpinner();
    }
  }
  const appName = localConfig?.name || path.basename(path.resolve(process.cwd(), localConfigPath || ""));
  if (!appName) {
    return null;
  }
  try {
    return await getAppLastDeployment(client, appName, user, contextName);
  } finally {
    output_manager_default.stopSpinner();
  }
}

// src/util/certs/handle-cert-error.ts
var import_ms3 = __toESM(require_ms(), 1);
var import_tldts2 = __toESM(require_cjs(), 1);
var import_chalk5 = __toESM(require_source(), 1);

// src/util/format-dns-table.ts
var import_chalk4 = __toESM(require_source(), 1);
var HEADER = ["name", "type", "value"].map((v) => (0, import_chalk4.gray)(v));
function formatDNSTable(rows) {
  return table([HEADER, ...rows], { hsep: 8 });
}

// src/util/certs/handle-cert-error.ts
function handleCertError(error) {
  if (error instanceof TooManyRequests) {
    output_manager_default.error(
      `Too many requests detected for ${error.meta.api} API. Try again in ${(0, import_ms3.default)(
        error.meta.retryAfterMs,
        {
          long: true
        }
      )}.`
    );
    return 1;
  }
  if (error instanceof CertError) {
    output_manager_default.error(error.message);
    if (error.meta.helpUrl) {
      output_manager_default.print(`  Read more: ${error.meta.helpUrl}
`);
    }
    return 1;
  }
  if (error instanceof DomainNotFound) {
    output_manager_default.error(error.message);
    return 1;
  }
  if (error instanceof CertConfigurationError) {
    const { external, cns } = error.meta;
    output_manager_default.error(
      `We couldn't verify the propagation of the DNS settings for ${error.meta.cns.map((cn) => import_chalk5.default.underline(cn)).join(", ")}`
    );
    if (external) {
      output_manager_default.print(
        `  The propagation may take a few minutes, but please verify your settings:

`
      );
      output_manager_default.print(
        `${formatDNSTable(
          cns.map((cn) => {
            const parsed = (0, import_tldts2.parse)(cn);
            return parsed.subdomain ? [parsed.subdomain, "ALIAS", "alias.vercel.com"] : ["", "ALIAS", "alias.vercel.com"];
          })
        )}

`
      );
      output_manager_default.log(
        `Alternatively, you can issue a certificate solving DNS challenges manually after running:`
      );
      output_manager_default.print(
        `  ${getCommandName(`certs issue --challenge-only <cns>`)}
`
      );
      output_manager_default.print(
        "  Read more: https://err.sh/vercel/dns-configuration-error\n"
      );
    } else {
      output_manager_default.print(
        `  We configured them for you, but the propagation may take a few minutes. Please try again later.
`
      );
      output_manager_default.print(
        "  Read more: https://err.sh/vercel/dns-configuration-error\n\n"
      );
    }
    return 1;
  }
  return error;
}

// src/util/telemetry/commands/alias/set.ts
var AliasSetTelemetryClient = class extends TelemetryClient {
  trackCliFlagDebug(flag) {
    if (flag) {
      this.trackCliFlag("debug");
    }
  }
  trackCliOptionLocalConfig(localConfig) {
    if (localConfig) {
      this.trackCliOption({
        option: "local-config",
        value: this.redactedValue
      });
    }
  }
  trackCliArgumentDeployment(deploymentUrl) {
    if (deploymentUrl) {
      this.trackCliArgument({
        arg: "deployment-url",
        value: this.redactedValue
      });
    }
  }
  trackCliArgumentAlias(customDomain) {
    if (customDomain) {
      this.trackCliArgument({
        arg: "custom-domain",
        value: this.redactedValue
      });
    }
  }
};

// src/commands/alias/set.ts
async function set(client, argv) {
  let parsedArguments;
  const flagsSpecification = getFlagsSpecification(listSubcommand.options);
  try {
    parsedArguments = parseArguments(argv, flagsSpecification);
  } catch (err) {
    printError(err);
    return 1;
  }
  const { args, flags: opts } = parsedArguments;
  const setStamp = stamp_default();
  const { localConfig } = client;
  const telemetryClient = new AliasSetTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  telemetryClient.trackCliFlagDebug(opts["--debug"]);
  telemetryClient.trackCliOptionLocalConfig(opts["--local-config"]);
  const { contextName, user } = await getScope(client);
  if (args.length > 2) {
    output_manager_default.error(
      `${getCommandName(
        "alias <deployment> <target>"
      )} accepts at most two arguments`
    );
    return 1;
  }
  if (args.length >= 1 && !isValidName(args[0])) {
    output_manager_default.error(
      `The provided argument "${args[0]}" is not a valid deployment`
    );
    return 1;
  }
  if (args.length >= 2 && !isValidName(args[1])) {
    output_manager_default.error(`The provided argument "${args[1]}" is not a valid domain`);
    return 1;
  }
  if (args.length === 0) {
    output_manager_default.error(
      `To ship to production, optionally configure your domains (${link_default(
        "https://vercel.link/domain-configuration"
      )}) and run ${getCommandName("--prod")}.`
    );
    return 1;
  }
  if (args.length === 1) {
    const [aliasTarget2] = args;
    telemetryClient.trackCliArgumentAlias(aliasTarget2);
    const deployment2 = handleCertError(
      await getDeploymentForAlias(
        client,
        args,
        opts["--local-config"],
        user,
        contextName,
        localConfig
      )
    );
    if (deployment2 === 1) {
      return deployment2;
    }
    if (deployment2 instanceof Error) {
      output_manager_default.error(deployment2.message);
      return 1;
    }
    if (!deployment2) {
      output_manager_default.error(
        `Couldn't find a deployment to alias. Please provide one as an argument.`
      );
      return 1;
    }
    const targets = getTargetsForAlias(args, localConfig);
    if (targets instanceof Error) {
      output_manager_default.prettyError(targets);
      return 1;
    }
    for (const target of targets) {
      output_manager_default.log(`Assigning alias ${target} to deployment ${deployment2.url}`);
      const record2 = await assignAlias(client, deployment2, target, contextName);
      const handleResult2 = handleSetupDomainError(
        handleCreateAliasError(record2)
      );
      if (handleResult2 === 1) {
        return 1;
      }
      output_manager_default.success(
        `${import_chalk6.default.bold(
          `${isWildcardAlias(target) ? "" : "https://"}${handleResult2.alias}`
        )} now points to https://${deployment2.url} ${setStamp()}`
      );
    }
    return 0;
  }
  const [deploymentIdOrHost, aliasTarget] = args;
  telemetryClient.trackCliArgumentDeployment(deploymentIdOrHost);
  telemetryClient.trackCliArgumentAlias(aliasTarget);
  const deployment = handleCertError(
    await getDeployment(client, contextName, deploymentIdOrHost)
  );
  if (deployment === 1) {
    return deployment;
  }
  if (deployment === null) {
    output_manager_default.error(
      `Couldn't find a deployment to alias. Please provide one as an argument.`
    );
    return 1;
  }
  output_manager_default.log(`Assigning alias ${aliasTarget} to deployment ${deployment.url}`);
  const isWildcard = isWildcardAlias(aliasTarget);
  const record = await assignAlias(
    client,
    deployment,
    aliasTarget,
    contextName
  );
  const handleResult = handleSetupDomainError(handleCreateAliasError(record));
  if (handleResult === 1) {
    return 1;
  }
  const prefix = isWildcard ? "" : "https://";
  output_manager_default.success(
    `${import_chalk6.default.bold(`${prefix}${handleResult.alias}`)} now points to https://${deployment.url} ${setStamp()}`
  );
  return 0;
}
function handleSetupDomainError(error) {
  if (error instanceof DomainPermissionDenied) {
    output_manager_default.error(
      `You don't have permissions over domain ${import_chalk6.default.underline(
        error.meta.domain
      )} under ${import_chalk6.default.bold(error.meta.context)}.`
    );
    return 1;
  }
  if (error instanceof UserAborted) {
    output_manager_default.error("User canceled.");
    return 1;
  }
  if (error instanceof DomainNotFound) {
    output_manager_default.error("You should buy the domain before aliasing.");
    return 1;
  }
  if (error instanceof UnsupportedTLD) {
    output_manager_default.error(
      `The TLD for domain name ${error.meta.domain} is not supported.`
    );
    return 1;
  }
  if (error instanceof InvalidDomain) {
    output_manager_default.error(
      `The domain ${error.meta.domain} used for the alias is not valid.`
    );
    return 1;
  }
  if (error instanceof DomainNotAvailable) {
    output_manager_default.error(
      `The domain ${error.meta.domain} is not available to be purchased.`
    );
    return 1;
  }
  if (error instanceof UnexpectedDomainPurchaseError) {
    output_manager_default.error("There was an unexpected error while purchasing the domain.");
    return 1;
  }
  if (error instanceof DomainAlreadyExists) {
    output_manager_default.error(
      `The domain  ${error.meta.domain} exists for a different account.`
    );
    return 1;
  }
  if (error instanceof DomainPurchasePending) {
    output_manager_default.error(
      `The domain ${error.meta.domain} is processing and will be available once the order is completed.`
    );
    output_manager_default.print(
      "  An email will be sent upon completion so you can alias to your new domain.\n"
    );
    return 1;
  }
  if (error instanceof SourceNotFound) {
    output_manager_default.error(
      `You can't purchase the domain you're aliasing to since you have no valid payment method.`
    );
    output_manager_default.print("  Please add a valid payment method and retry.\n");
    return 1;
  }
  if (error instanceof DomainPaymentError) {
    output_manager_default.error(
      `You can't purchase the domain you're aliasing to since your card was declined.`
    );
    output_manager_default.print("  Please add a valid payment method and retry.\n");
    return 1;
  }
  if (error instanceof TLDNotSupportedViaCLI) {
    output_manager_default.error(
      `The TLD for domain name ${error.meta.domain} is not supported via the CLI. Use the REST API or the dashboard to purchase.`
    );
    return 1;
  }
  return error;
}
function handleCreateAliasError(errorOrResult) {
  const error = handleCertError(errorOrResult);
  if (error === 1) {
    return error;
  }
  if (error instanceof AliasInUse) {
    output_manager_default.error(
      `The alias ${import_chalk6.default.dim(
        error.meta.alias
      )} is a deployment URL or it's in use by a different team.`
    );
    return 1;
  }
  if (error instanceof DeploymentNotFound) {
    output_manager_default.error(
      `Failed to find deployment ${import_chalk6.default.dim(error.meta.id)} under ${import_chalk6.default.bold(
        error.meta.context
      )}`
    );
    return 1;
  }
  if (error instanceof InvalidAlias) {
    output_manager_default.error(
      "Invalid alias. Please confirm that the alias you provided is a valid hostname. Note: For `vercel.app`, only sub and sub-sub domains are supported."
    );
    return 1;
  }
  if (error instanceof DeploymentPermissionDenied) {
    output_manager_default.error(
      `No permission to access deployment ${import_chalk6.default.dim(
        error.meta.id
      )} under ${import_chalk6.default.bold(error.meta.context)}`
    );
    return 1;
  }
  if (error instanceof CertMissing) {
    output_manager_default.error(
      `There is no certificate for the domain ${error.meta.domain} and it could not be created.`
    );
    output_manager_default.log(
      `Please generate a new certificate manually with ${getCommandName(
        `certs issue ${error.meta.domain}`
      )}`
    );
    return 1;
  }
  if (error instanceof InvalidDomain) {
    output_manager_default.error(
      `The domain ${error.meta.domain} used for the alias is not valid.`
    );
    return 1;
  }
  if (error instanceof DomainPermissionDenied || error instanceof DeploymentFailedAliasImpossible || error instanceof InvalidDeploymentId) {
    output_manager_default.error(error.message);
    return 1;
  }
  if (error instanceof DeploymentNotReady) {
    output_manager_default.error(error.message);
    return 1;
  }
  return error;
}
function getTargetsForAlias(args, { alias: alias2 } = {}) {
  if (args.length) {
    return [args[args.length - 1]].map((target) => target.indexOf(".") !== -1 ? toHost(target) : target).filter((x) => !!x && typeof x === "string");
  }
  if (!alias2) {
    return new NoAliasInConfig();
  }
  if (typeof alias2 !== "string" && !Array.isArray(alias2)) {
    return new InvalidAliasInConfig(alias2);
  }
  return typeof alias2 === "string" ? [alias2] : alias2;
}

// src/util/telemetry/commands/alias/index.ts
var AliasTelemetryClient = class extends TelemetryClient {
  trackCliSubcommandList(actual) {
    this.trackCliSubcommand({
      subcommand: "list",
      value: actual
    });
  }
  trackCliSubcommandSet(actual) {
    this.trackCliSubcommand({
      subcommand: "set",
      value: actual
    });
  }
  trackCliSubcommandRemove(actual) {
    this.trackCliSubcommand({
      subcommand: "rm",
      value: actual
    });
  }
};

// src/commands/alias/index.ts
var COMMAND_CONFIG = {
  ls: getCommandAliases(listSubcommand),
  rm: getCommandAliases(removeSubcommand),
  set: getCommandAliases(setSubcommand)
};
async function alias(client) {
  const telemetry2 = new AliasTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  let parsedArguments;
  const flagsSpecification = getFlagsSpecification(aliasCommand.options);
  try {
    parsedArguments = parseArguments(client.argv.slice(2), flagsSpecification, {
      permissive: true
    });
  } catch (err) {
    printError(err);
    return 1;
  }
  const { subcommand, args, subcommandOriginal } = getSubcommand3(
    parsedArguments.args.slice(1),
    COMMAND_CONFIG
  );
  const needHelp = parsedArguments.flags["--help"];
  if (!subcommand && needHelp) {
    telemetry2.trackCliFlagHelp("alias");
    output_manager_default.print(help(aliasCommand, { columns: client.stderr.columns }));
    return 2;
  }
  function printHelp(command) {
    output_manager_default.print(
      help(command, { parent: aliasCommand, columns: client.stderr.columns })
    );
  }
  switch (subcommand) {
    case "ls":
      if (needHelp) {
        telemetry2.trackCliFlagHelp("alias", subcommandOriginal);
        printHelp(listSubcommand);
        return 2;
      }
      telemetry2.trackCliSubcommandList(subcommandOriginal);
      return ls(client, args);
    case "rm":
      if (needHelp) {
        telemetry2.trackCliFlagHelp("alias", subcommandOriginal);
        printHelp(removeSubcommand);
        return 2;
      }
      telemetry2.trackCliSubcommandRemove(subcommandOriginal);
      return rm(client, args);
    case "set":
      if (needHelp) {
        telemetry2.trackCliFlagHelp("alias", subcommandOriginal);
        printHelp(setSubcommand);
        return 2;
      }
      telemetry2.trackCliSubcommandSet(subcommandOriginal);
      return set(client, args);
    default:
      if (needHelp) {
        telemetry2.trackCliFlagHelp("alias", subcommandOriginal);
        printHelp(setSubcommand);
        return 2;
      }
      telemetry2.trackCliSubcommandSet(subcommandOriginal);
      return set(client, args);
  }
}

// src/commands/api/index.ts
var import_chalk8 = __toESM(require_source(), 1);

// src/util/telemetry/commands/api/index.ts
var ApiTelemetryClient = class extends TelemetryClient {
  trackCliArgumentEndpoint(endpoint) {
    if (endpoint) {
      const normalized = this.normalizeEndpoint(endpoint);
      this.trackCliArgument({
        arg: "endpoint",
        value: normalized
      });
    }
  }
  trackCliOptionMethod(method) {
    if (method) {
      const validMethods = ["GET", "POST", "PUT", "DELETE", "PATCH", "HEAD"];
      const upperMethod = method.toUpperCase();
      const value = validMethods.includes(upperMethod) ? upperMethod : this.redactedValue;
      this.trackCliOption({
        option: "method",
        value
      });
    }
  }
  trackCliOptionField(fields) {
    if (fields && fields.length > 0) {
      this.trackCliOption({
        option: "field",
        value: this.redactedArgumentsLength(fields)
      });
    }
  }
  trackCliOptionRawField(fields) {
    if (fields && fields.length > 0) {
      this.trackCliOption({
        option: "raw-field",
        value: this.redactedArgumentsLength(fields)
      });
    }
  }
  trackCliOptionHeader(headers) {
    if (headers && headers.length > 0) {
      this.trackCliOption({
        option: "header",
        value: this.redactedArgumentsLength(headers)
      });
    }
  }
  trackCliOptionInput(input) {
    if (input) {
      const value = input === "-" ? "stdin" : "file";
      this.trackCliOption({
        option: "input",
        value
      });
    }
  }
  trackCliFlagPaginate(value) {
    if (value) {
      this.trackCliFlag("paginate");
    }
  }
  trackCliFlagInclude(value) {
    if (value) {
      this.trackCliFlag("include");
    }
  }
  trackCliFlagSilent(value) {
    if (value) {
      this.trackCliFlag("silent");
    }
  }
  trackCliFlagVerbose(value) {
    if (value) {
      this.trackCliFlag("verbose");
    }
  }
  trackCliFlagRaw(value) {
    if (value) {
      this.trackCliFlag("raw");
    }
  }
  trackCliFlagRefresh(value) {
    if (value) {
      this.trackCliFlag("refresh");
    }
  }
  trackCliOptionGenerate(format4) {
    if (format4) {
      const validFormats = ["curl"];
      const value = validFormats.includes(format4) ? format4 : this.redactedValue;
      this.trackCliOption({
        option: "generate",
        value
      });
    }
  }
  trackCliFlagDangerouslySkipPermissions(value) {
    if (value) {
      this.trackCliFlag("dangerously-skip-permissions");
    }
  }
  trackCliSubcommandList() {
    this.trackCliSubcommand({ subcommand: "list", value: "list" });
  }
  trackCliOptionFormat(format4) {
    if (format4) {
      const validFormats = ["table", "json"];
      const value = validFormats.includes(format4) ? format4 : this.redactedValue;
      this.trackCliOption({
        option: "format",
        value
      });
    }
  }
  /**
   * Normalize endpoint by replacing IDs with placeholders for privacy
   */
  normalizeEndpoint(endpoint) {
    return endpoint.replace(/\/dpl_[a-zA-Z0-9]+/g, "/:deploymentId").replace(/\/prj_[a-zA-Z0-9]+/g, "/:projectId").replace(/\/team_[a-zA-Z0-9]+/g, "/:teamId").replace(/\/[a-f0-9]{24}/g, "/:id").replace(/\/[a-f0-9-]{36}/g, "/:uuid");
  }
};

// src/commands/api/request-builder.ts
import { readFile } from "fs/promises";
import { resolve } from "path";
async function buildRequest(endpoint, flags) {
  const headers = {};
  let body;
  const customHeaders = flags["--header"] || [];
  for (const header of customHeaders) {
    const colonIndex = header.indexOf(":");
    if (colonIndex > 0) {
      const key = header.substring(0, colonIndex).trim();
      const value = header.substring(colonIndex + 1).trim();
      headers[key] = value;
    }
  }
  const fields = flags["--field"] || [];
  const rawFields = flags["--raw-field"] || [];
  if (fields.length > 0 || rawFields.length > 0) {
    body = {};
    for (const field of fields) {
      const { key, value } = await parseField(field, true);
      body[key] = value;
    }
    for (const field of rawFields) {
      const { key, value } = await parseField(field, false);
      body[key] = value;
    }
  }
  if (flags["--input"]) {
    const inputPath = flags["--input"];
    if (inputPath === "-") {
      body = await readStdin();
    } else {
      body = await readFile(resolve(inputPath), "utf-8");
    }
    if (typeof body === "string") {
      try {
        body = JSON.parse(body);
      } catch {
      }
    }
  }
  let method = flags["--method"]?.toUpperCase() || "GET";
  if (!flags["--method"] && body) {
    method = "POST";
  }
  return {
    url: endpoint,
    method,
    headers,
    body
  };
}
async function parseField(field, typed) {
  const eqIndex = field.indexOf("=");
  if (eqIndex === -1) {
    throw new Error(`Invalid field format: ${field}. Expected key=value`);
  }
  const key = field.substring(0, eqIndex);
  let value = field.substring(eqIndex + 1);
  if (typed && typeof value === "string") {
    if (value.startsWith("@")) {
      const filePath = value.substring(1);
      if (filePath === "-") {
        value = await readStdin();
      } else {
        value = await readFile(resolve(filePath), "utf-8");
      }
      if (typeof value === "string") {
        try {
          value = JSON.parse(value);
        } catch {
        }
      }
    } else if (value === "true") {
      value = true;
    } else if (value === "false") {
      value = false;
    } else if (value === "null") {
      value = null;
    } else if (/^-?\d+$/.test(value)) {
      value = parseInt(value, 10);
    } else if (/^-?\d*\.\d+$/.test(value)) {
      value = parseFloat(value);
    } else if (value.startsWith("[") || value.startsWith("{")) {
      try {
        value = JSON.parse(value);
      } catch {
      }
    }
  }
  return { key, value };
}
async function readStdin() {
  const chunks = [];
  for await (const chunk of process.stdin) {
    chunks.push(chunk);
  }
  return Buffer.concat(chunks).toString("utf-8");
}
function formatOutput(data, options) {
  if (options.raw) {
    if (typeof data === "string") {
      return data;
    }
    return JSON.stringify(data);
  }
  return JSON.stringify(data, null, 2);
}
function generateCurlCommand(config, baseUrl) {
  const parts = ["curl"];
  if (config.method !== "GET") {
    parts.push(`-X ${config.method}`);
  }
  parts.push(`-H 'Authorization: Bearer <TOKEN>'`);
  for (const [key, value] of Object.entries(config.headers)) {
    parts.push(`-H '${key}: ${escapeShellArg(value)}'`);
  }
  if (config.body) {
    const bodyStr = typeof config.body === "string" ? config.body : JSON.stringify(config.body);
    parts.push(`-H 'Content-Type: application/json'`);
    parts.push(`-d '${escapeShellArg(bodyStr)}'`);
  }
  const fullUrl = `${baseUrl}${config.url}`;
  parts.push(`'${fullUrl}'`);
  return parts.join(" \\\n  ");
}
function escapeShellArg(str) {
  return str.replace(/'/g, "'\\''");
}

// src/util/openapi/openapi-cache.ts
import { join } from "path";
import { readFile as readFile2, writeFile, mkdir } from "fs/promises";

// src/util/openapi/constants.ts
var OPENAPI_URL = "https://openapi.vercel.sh/";
var CACHE_FILE = "openapi-spec.json";
var CACHE_TTL_MS = 24 * 60 * 60 * 1e3;
var FETCH_TIMEOUT_MS = 10 * 1e3;

// src/util/openapi/openapi-cache.ts
var OpenApiCache = class {
  constructor() {
    this.spec = null;
    this.cachePath = join(global_path_default(), CACHE_FILE);
  }
  /**
   * Check if the spec has been loaded
   */
  get isLoaded() {
    return this.spec !== null;
  }
  /**
   * Load the OpenAPI spec, using cache if available and fresh.
   * Returns true if successful, false otherwise.
   */
  async load(forceRefresh = false) {
    if (!forceRefresh) {
      const cached = await this.readCache();
      if (cached && !this.isExpired(cached.fetchedAt)) {
        output_manager_default.debug("Using cached OpenAPI spec");
        this.spec = cached.spec;
        return true;
      }
    }
    try {
      output_manager_default.debug("Fetching OpenAPI spec from " + OPENAPI_URL);
      this.spec = await this.fetchSpec();
      await this.saveCache(this.spec);
      return true;
    } catch (err) {
      output_manager_default.debug(`Failed to fetch OpenAPI spec: ${err}`);
      const stale = await this.readCache();
      if (stale) {
        output_manager_default.debug("Using stale cached OpenAPI spec");
        this.spec = stale.spec;
        return true;
      }
      return false;
    }
  }
  /**
   * Load the OpenAPI spec with spinner UI.
   * Returns true if successful, false otherwise.
   */
  async loadWithSpinner(forceRefresh = false) {
    output_manager_default.spinner(
      forceRefresh ? "Refreshing API endpoints..." : "Loading API endpoints..."
    );
    const success = await this.load(forceRefresh);
    output_manager_default.stopSpinner();
    return success;
  }
  /**
   * Get all available endpoints from the loaded spec, sorted by path then method.
   * Throws if spec hasn't been loaded yet.
   */
  getEndpoints() {
    this.ensureLoaded();
    const endpoints = this.extractEndpoints();
    return this.sortEndpoints(endpoints);
  }
  /**
   * Extract body fields from a requestBody schema.
   * Throws if spec hasn't been loaded yet.
   */
  getBodyFields(endpoint) {
    this.ensureLoaded();
    if (!endpoint.requestBody?.content)
      return [];
    const jsonContent = endpoint.requestBody.content["application/json"];
    if (!jsonContent?.schema)
      return [];
    const schema = this.resolveSchemaRef(jsonContent.schema);
    if (!schema?.properties)
      return [];
    const requiredFields = new Set(schema.required || []);
    const fields = [];
    for (const [name, propSchema] of Object.entries(schema.properties)) {
      const resolvedProp = this.resolveSchemaRef(propSchema);
      let enumValues = resolvedProp?.enum || propSchema.enum;
      if (!enumValues && (resolvedProp?.type === "array" || propSchema.type === "array")) {
        const items = resolvedProp?.items || propSchema.items;
        if (items) {
          const resolvedItems = this.resolveSchemaRef(items);
          enumValues = resolvedItems?.enum || items.enum;
        }
      }
      fields.push({
        name,
        required: requiredFields.has(name),
        description: resolvedProp?.description || propSchema.description,
        type: resolvedProp?.type || propSchema.type,
        enumValues
      });
    }
    fields.sort((a, b) => {
      if (a.required !== b.required) {
        return a.required ? -1 : 1;
      }
      return a.name.localeCompare(b.name);
    });
    return fields;
  }
  // ─────────────────────────────────────────────────────────────────────────────
  // Private methods
  // ─────────────────────────────────────────────────────────────────────────────
  /**
   * Ensure the spec is loaded before accessing it
   */
  ensureLoaded() {
    if (!this.spec) {
      throw new Error(
        "OpenAPI spec not loaded. Call load() or loadWithSpinner() first."
      );
    }
  }
  /**
   * Read cached spec from disk
   */
  async readCache() {
    try {
      const content = await readFile2(this.cachePath, "utf-8");
      return JSON.parse(content);
    } catch {
      return null;
    }
  }
  /**
   * Save spec to disk cache
   */
  async saveCache(spec) {
    const cached = {
      fetchedAt: Date.now(),
      spec
    };
    const dir = join(this.cachePath, "..");
    await mkdir(dir, { recursive: true });
    await writeFile(this.cachePath, JSON.stringify(cached));
    output_manager_default.debug("Saved OpenAPI spec to cache");
  }
  /**
   * Fetch OpenAPI spec from remote with timeout
   */
  async fetchSpec() {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), FETCH_TIMEOUT_MS);
    try {
      const response = await fetch(OPENAPI_URL, { signal: controller.signal });
      if (!response.ok) {
        throw new Error(`Failed to fetch OpenAPI spec: ${response.status}`);
      }
      return await response.json();
    } finally {
      clearTimeout(timeoutId);
    }
  }
  /**
   * Check if cached spec is expired
   */
  isExpired(fetchedAt) {
    return Date.now() - fetchedAt > CACHE_TTL_MS;
  }
  /**
   * Sort endpoints by path, then by method
   */
  sortEndpoints(endpoints) {
    return endpoints.sort((a, b) => {
      const pathCompare = a.path.localeCompare(b.path);
      if (pathCompare !== 0)
        return pathCompare;
      return a.method.localeCompare(b.method);
    });
  }
  /**
   * Extract all available endpoints from the spec
   */
  extractEndpoints() {
    const endpoints = [];
    for (const [path3, pathItem] of Object.entries(this.spec.paths)) {
      const methods = ["get", "post", "put", "patch", "delete"];
      for (const method of methods) {
        const operation = pathItem[method];
        if (operation) {
          const pathParams = pathItem.parameters || [];
          const opParams = operation.parameters || [];
          const allParams = [...pathParams, ...opParams];
          endpoints.push({
            path: path3,
            method: method.toUpperCase(),
            summary: operation.summary || pathItem.summary || "",
            description: operation.description || pathItem.description || "",
            operationId: operation.operationId || "",
            tags: operation.tags || [],
            parameters: allParams,
            requestBody: operation.requestBody
          });
        }
      }
    }
    return endpoints;
  }
  /**
   * Resolve a $ref to its actual schema
   */
  resolveSchemaRef(schema) {
    if (!schema)
      return void 0;
    if (schema.$ref) {
      const match = schema.$ref.match(/^#\/components\/schemas\/(.+)$/);
      if (match && this.spec.components?.schemas) {
        const resolved = this.spec.components.schemas[match[1]];
        return this.resolveSchemaRef(resolved);
      }
      return void 0;
    }
    if (schema.allOf && schema.allOf.length > 0) {
      const merged = { type: "object", properties: {}, required: [] };
      for (const subSchema of schema.allOf) {
        const resolved = this.resolveSchemaRef(subSchema);
        if (resolved) {
          if (resolved.properties) {
            merged.properties = {
              ...merged.properties,
              ...resolved.properties
            };
          }
          if (resolved.required) {
            merged.required = [
              ...merged.required || [],
              ...resolved.required
            ];
          }
        }
      }
      return merged;
    }
    return schema;
  }
};

// src/commands/api/constants.ts
var API_BASE_URL = "https://api.vercel.com";

// src/commands/api/format-utils.ts
var import_chalk7 = __toESM(require_source(), 1);
function colorizeMethod(method) {
  switch (method) {
    case "GET":
      return import_chalk7.default.cyan(method);
    case "POST":
      return import_chalk7.default.green(method);
    case "PUT":
      return import_chalk7.default.yellow(method);
    case "PATCH":
      return import_chalk7.default.blue(method);
    case "DELETE":
      return import_chalk7.default.red(method);
    default:
      return method;
  }
}
function colorizeMethodPadded(method, width = 7) {
  const colored = colorizeMethod(method);
  const padding2 = " ".repeat(Math.max(0, width - method.length));
  return colored + padding2;
}
function formatPathParam(paramName) {
  return import_chalk7.default.cyan(`{${paramName}}`);
}
function formatTypeHint(type) {
  return import_chalk7.default.dim(`[${type}]`);
}
function formatDescription(description) {
  if (!description)
    return "";
  return import_chalk7.default.gray(` (${description})`);
}

// src/commands/api/index.ts
async function api(client) {
  const telemetryClient = new ApiTelemetryClient({
    opts: { store: client.telemetryEventStore }
  });
  let parsedArgs;
  const flagsSpec = getFlagsSpecification(apiCommand.options);
  try {
    parsedArgs = parseArguments(client.argv.slice(2), flagsSpec, {
      permissive: true
    });
  } catch (err) {
    printError(err);
    return 1;
  }
  const { args, flags } = parsedArgs;
  const needHelp = flags["--help"];
  const firstArg = args[1];
  if (firstArg === "ls" || firstArg === "list") {
    const lsFlagsSpec = getFlagsSpecification(listSubcommand2.options);
    let lsParsedArgs;
    try {
      lsParsedArgs = parseArguments(client.argv.slice(2), lsFlagsSpec);
    } catch (err) {
      printError(err);
      return 1;
    }
    const lsFlags = lsParsedArgs.flags;
    if (lsFlags["--help"]) {
      telemetryClient.trackCliFlagHelp("api", firstArg);
      output_manager_default.print(
        help(listSubcommand2, {
          parent: apiCommand,
          columns: client.stderr.columns
        })
      );
      return 2;
    }
    telemetryClient.trackCliSubcommandList();
    if (lsFlags["--refresh"])
      telemetryClient.trackCliFlagRefresh(true);
    if (lsFlags["--format"])
      telemetryClient.trackCliOptionFormat(lsFlags["--format"]);
    return listEndpoints(
      client,
      lsFlags["--refresh"] ?? false,
      lsFlags["--format"] ?? "table"
    );
  }
  if (needHelp) {
    telemetryClient.trackCliFlagHelp("api");
    output_manager_default.print(help(apiCommand, { columns: client.stderr.columns }));
    return 2;
  }
  if (flags["--dangerously-skip-permissions"]) {
    client.dangerouslySkipPermissions = true;
  }
  let endpoint = firstArg;
  let selectedMethod;
  let selectedBodyFields = [];
  if (!endpoint) {
    if (client.stdin.isTTY) {
      const selected = await promptEndpointSelection(
        client,
        flags["--refresh"] ?? false
      );
      if (!selected) {
        return 1;
      }
      endpoint = selected.finalUrl;
      selectedMethod = selected.method;
      selectedBodyFields = selected.bodyFields;
    } else {
      output_manager_default.error("Endpoint is required. Usage: vercel api <endpoint>");
      return 1;
    }
  }
  if (!endpoint.startsWith("/")) {
    output_manager_default.error("Endpoint must start with /");
    return 1;
  }
  try {
    const resolvedUrl = new URL(endpoint, API_BASE_URL);
    if (resolvedUrl.origin !== API_BASE_URL) {
      output_manager_default.error(
        "Invalid endpoint: must be a Vercel API path, not an external URL"
      );
      return 1;
    }
  } catch {
    output_manager_default.error("Invalid endpoint URL format");
    return 1;
  }
  telemetryClient.trackCliArgumentEndpoint(endpoint);
  telemetryClient.trackCliOptionMethod(flags["--method"]);
  telemetryClient.trackCliOptionHeader(flags["--header"]);
  telemetryClient.trackCliOptionInput(flags["--input"]);
  if (flags["--paginate"])
    telemetryClient.trackCliFlagPaginate(true);
  if (flags["--include"])
    telemetryClient.trackCliFlagInclude(true);
  if (flags["--silent"])
    telemetryClient.trackCliFlagSilent(true);
  if (flags["--verbose"])
    telemetryClient.trackCliFlagVerbose(true);
  if (flags["--raw"])
    telemetryClient.trackCliFlagRaw(true);
  if (flags["--refresh"])
    telemetryClient.trackCliFlagRefresh(true);
  if (flags["--generate"])
    telemetryClient.trackCliOptionGenerate(flags["--generate"]);
  if (flags["--dangerously-skip-permissions"])
    telemetryClient.trackCliFlagDangerouslySkipPermissions(true);
  const finalFlags = { ...flags };
  if (selectedMethod && !flags["--method"]) {
    finalFlags["--method"] = selectedMethod;
  }
  if (selectedBodyFields.length > 0) {
    const existingFields = finalFlags["--field"] || [];
    finalFlags["--field"] = [...existingFields, ...selectedBodyFields];
  }
  if (flags["--generate"] === "curl") {
    try {
      const requestConfig = await buildRequest(endpoint, finalFlags);
      const curlCmd = generateCurlCommand(
        requestConfig,
        "https://api.vercel.com"
      );
      output_manager_default.log("");
      output_manager_default.log("Replace <TOKEN> with your auth token:");
      output_manager_default.log("");
      client.stdout.write(curlCmd + "\n");
      return 0;
    } catch (err) {
      printError(err);
      return 1;
    }
  }
  return executeApiRequest(client, endpoint, finalFlags);
}
async function executeApiRequest(client, endpoint, flags) {
  let requestConfig;
  try {
    requestConfig = await buildRequest(endpoint, flags);
  } catch (err) {
    printError(err);
    return 1;
  }
  if (flags["--verbose"]) {
    output_manager_default.debug(`Request: ${requestConfig.method} ${requestConfig.url}`);
    if (Object.keys(requestConfig.headers).length > 0) {
      output_manager_default.debug(`Headers: ${JSON.stringify(requestConfig.headers)}`);
    }
    if (requestConfig.body) {
      output_manager_default.debug(
        `Body: ${typeof requestConfig.body === "string" ? requestConfig.body : JSON.stringify(requestConfig.body)}`
      );
    }
  }
  if (flags["--paginate"]) {
    return executePaginatedRequest(client, requestConfig, flags);
  }
  return executeSingleRequest(client, requestConfig, flags);
}
async function executeSingleRequest(client, config, flags) {
  try {
    const confirmed = await client.confirmMutatingOperation(
      config.url,
      config.method
    );
    if (!confirmed) {
      return 1;
    }
    const response = await client.fetch(config.url, {
      method: config.method,
      body: config.body,
      headers: config.headers,
      json: false
      // Get raw response
    });
    return handleResponse(client, response, flags);
  } catch (err) {
    output_manager_default.prettyError(err);
    return 1;
  }
}
async function executePaginatedRequest(client, config, flags) {
  const results = [];
  try {
    const confirmed = await client.confirmMutatingOperation(
      config.url,
      config.method
    );
    if (!confirmed) {
      return 1;
    }
    for await (const page of client.fetchPaginated(
      config.url,
      {
        method: config.method,
        body: config.body,
        headers: config.headers
      }
    )) {
      const data = extractPaginatedData(page);
      results.push(...data);
    }
    return outputResults(client, results, flags);
  } catch (err) {
    output_manager_default.prettyError(err);
    return 1;
  }
}
function extractPaginatedData(page) {
  for (const [key, value] of Object.entries(page)) {
    if (key !== "pagination" && Array.isArray(value)) {
      return value;
    }
  }
  const { pagination, ...rest } = page;
  return [rest];
}
async function handleResponse(client, response, flags) {
  if (flags["--include"]) {
    outputHeaders(client, response);
  }
  if (flags["--silent"]) {
    return response.ok ? 0 : 1;
  }
  const contentType = response.headers.get("content-type") || "";
  if (contentType.includes("application/json")) {
    const json = await response.json();
    if (flags["--verbose"]) {
      output_manager_default.debug(
        `Response status: ${response.status} ${response.statusText}`
      );
    }
    return outputResults(client, json, flags);
  }
  const text = await response.text();
  client.stdout.write(text);
  return response.ok ? 0 : 1;
}
function outputHeaders(client, response) {
  client.stdout.write(`HTTP ${response.status} ${response.statusText}
`);
  response.headers.forEach((value, key) => {
    client.stdout.write(`${key}: ${value}
`);
  });
  client.stdout.write("\n");
}
function outputResults(client, data, flags) {
  const formatted = formatOutput(data, {
    raw: flags["--raw"]
  });
  client.stdout.write(formatted + "\n");
  return 0;
}
async function promptEndpointSelection(client, forceRefresh) {
  try {
    const openApi = new OpenApiCache();
    const success = await openApi.loadWithSpinner(forceRefresh);
    if (!success) {
      output_manager_default.error("Could not load API specification for endpoint selection");
      return null;
    }
    const endpoints = openApi.getEndpoints();
    const selectedEndpoint = await promptForEndpoint(client, endpoints);
    const bodyFieldsSpec = openApi.getBodyFields(selectedEndpoint);
    const { finalUrl, bodyFields } = await promptForParameters(
      client,
      selectedEndpoint.path,
      selectedEndpoint.parameters,
      bodyFieldsSpec
    );
    return {
      path: selectedEndpoint.path,
      method: selectedEndpoint.method,
      finalUrl,
      bodyFields
    };
  } catch (err) {
    output_manager_default.stopSpinner();
    output_manager_default.debug(`Endpoint selection failed: ${err}`);
    return null;
  }
}
async function promptForEndpoint(client, endpoints) {
  const allChoices = endpoints.map((ep) => ({
    name: `${colorizeMethodPadded(ep.method)} ${ep.path}`,
    value: ep,
    // Show full description if available, otherwise show summary
    description: ep.description || ep.summary || void 0,
    // Include summary in searchable metadata
    summary: ep.summary,
    tags: ep.tags
  }));
  const total = allChoices.length;
  return client.input.search({
    message: `Search for an API endpoint (${total} available):`,
    source: async (term) => {
      if (!term) {
        return allChoices;
      }
      const lowerTerm = term.toLowerCase();
      return allChoices.filter((choice) => {
        const searchableText = [
          choice.name,
          choice.summary || "",
          choice.description || "",
          ...choice.tags || []
        ].join(" ").toLowerCase();
        return searchableText.includes(lowerTerm);
      });
    }
  });
}
async function listEndpoints(client, forceRefresh, format4) {
  const openApi = new OpenApiCache();
  const success = await openApi.loadWithSpinner(forceRefresh);
  if (!success) {
    output_manager_default.error("Could not load API specification");
    return 1;
  }
  const endpoints = openApi.getEndpoints();
  if (format4 === "json") {
    return outputEndpointsAsJson(client, endpoints);
  }
  return outputEndpointsAsTable(endpoints);
}
function outputEndpointsAsJson(client, endpoints) {
  const jsonOutput = endpoints.map((ep) => ({
    method: ep.method,
    path: ep.path,
    summary: ep.summary || null,
    description: ep.description || null,
    operationId: ep.operationId || null,
    tags: ep.tags
  }));
  client.stdout.write(JSON.stringify(jsonOutput, null, 2) + "\n");
  return 0;
}
function groupEndpointsByPath(endpoints) {
  const grouped = /* @__PURE__ */ new Map();
  for (const ep of endpoints) {
    const existing = grouped.get(ep.path) || [];
    existing.push({ method: ep.method, summary: ep.summary });
    grouped.set(ep.path, existing);
  }
  const methodOrder = ["GET", "POST", "PUT", "PATCH", "DELETE"];
  for (const [path3, methods] of grouped) {
    methods.sort(
      (a, b) => methodOrder.indexOf(a.method) - methodOrder.indexOf(b.method)
    );
    grouped.set(path3, methods);
  }
  return grouped;
}
function outputEndpointsAsTable(endpoints) {
  const grouped = groupEndpointsByPath(endpoints);
  const methodWidth = 7;
  output_manager_default.log("");
  for (const [path3, methods] of grouped) {
    output_manager_default.log(import_chalk8.default.bold(path3));
    for (const { method, summary } of methods) {
      const coloredMethod = colorizeMethod(method);
      const paddedMethod = method.padEnd(methodWidth);
      const methodDisplay = coloredMethod + paddedMethod.slice(method.length);
      output_manager_default.log(`  ${methodDisplay}  ${import_chalk8.default.gray(summary || "")}`);
    }
    output_manager_default.log("");
  }
  output_manager_default.log(
    `${import_chalk8.default.bold(grouped.size.toString())} routes, ${import_chalk8.default.bold(endpoints.length.toString())} endpoints`
  );
  return 0;
}
function createRequiredValidator(fieldName) {
  return (input) => {
    if (!input.trim()) {
      return `${fieldName} is required`;
    }
    return true;
  };
}
function buildQueryString(params) {
  return Object.entries(params).map(([k, v]) => `${encodeURIComponent(k)}=${encodeURIComponent(v)}`).join("&");
}
async function promptForParameters(client, path3, parameters, bodyFieldsSpec) {
  const globalParams = /* @__PURE__ */ new Set(["teamId", "slug"]);
  const pathParams = parameters.filter((p) => p.in === "path");
  const requiredQueryParams = parameters.filter(
    (p) => p.in === "query" && p.required && !globalParams.has(p.name)
  );
  const optionalQueryParams = parameters.filter(
    (p) => p.in === "query" && !p.required && !globalParams.has(p.name)
  );
  const requiredBodyFields = bodyFieldsSpec.filter((f) => f.required);
  const optionalBodyFields = bodyFieldsSpec.filter((f) => !f.required);
  let finalPath = path3;
  for (const param2 of pathParams) {
    const value = await client.input.text({
      message: `Enter value for ${formatPathParam(param2.name)}${formatDescription(param2.description)}:`,
      validate: createRequiredValidator(param2.name)
    });
    finalPath = finalPath.replace(`{${param2.name}}`, encodeURIComponent(value));
  }
  const queryValues = {};
  for (const param2 of requiredQueryParams) {
    queryValues[param2.name] = await client.input.text({
      message: `Enter value for ${import_chalk8.default.cyan(param2.name)}${formatDescription(param2.description)}:`,
      validate: createRequiredValidator(param2.name)
    });
  }
  if (optionalQueryParams.length > 0) {
    const selectedOptionalParams = await client.input.checkbox({
      message: "Select optional query parameters to include:",
      pageSize: 20,
      choices: optionalQueryParams.map((p) => ({
        name: `${import_chalk8.default.cyan(p.name)}${formatDescription(p.description)}`,
        value: p.name
      }))
    });
    for (const paramName of selectedOptionalParams) {
      const param2 = optionalQueryParams.find((p) => p.name === paramName);
      queryValues[param2.name] = await client.input.text({
        message: `Enter value for ${import_chalk8.default.cyan(param2.name)}${formatDescription(param2.description)}:`,
        validate: createRequiredValidator(param2.name)
      });
    }
  }
  const bodyFieldValues = [];
  for (const field of requiredBodyFields) {
    const value = await promptForBodyField(client, field, true);
    bodyFieldValues.push(`${field.name}=${value}`);
  }
  if (optionalBodyFields.length > 0) {
    const selectedOptionalFields = await client.input.checkbox({
      message: "Select optional body fields to include:",
      pageSize: 20,
      choices: optionalBodyFields.map((f) => ({
        name: `${import_chalk8.default.cyan(f.name)}${f.type ? ` ${formatTypeHint(f.type)}` : ""}${formatDescription(f.description)}`,
        value: f.name
      }))
    });
    for (const fieldName of selectedOptionalFields) {
      const field = optionalBodyFields.find((f) => f.name === fieldName);
      const value = await promptForBodyField(client, field, true);
      bodyFieldValues.push(`${field.name}=${value}`);
    }
  }
  const queryString = buildQueryString(queryValues);
  if (queryString) {
    finalPath += `?${queryString}`;
  }
  return { finalUrl: finalPath, bodyFields: bodyFieldValues };
}
async function promptForBodyField(client, field, required) {
  const description = formatDescription(field.description);
  const optionalHint = required ? "" : import_chalk8.default.dim(" (optional)");
  if (field.type === "array" && field.enumValues && field.enumValues.length > 0) {
    const choices = field.enumValues.map((v) => ({
      name: String(v),
      value: String(v)
    }));
    const selected = await client.input.checkbox({
      message: `Select values for ${import_chalk8.default.cyan(field.name)}${optionalHint}${description}:`,
      choices,
      required
    });
    return JSON.stringify(selected);
  }
  if (field.enumValues && field.enumValues.length > 0) {
    const choices = field.enumValues.map((v) => ({
      name: String(v),
      value: String(v)
    }));
    if (!required) {
      choices.unshift({ name: import_chalk8.default.dim("(skip)"), value: "" });
    }
    return client.input.select({
      message: `Select value for ${import_chalk8.default.cyan(field.name)}${optionalHint}${description}:`,
      choices
    });
  }
  const typeHint = field.type ? ` ${formatTypeHint(field.type)}` : "";
  return client.input.text({
    message: `Enter value for ${import_chalk8.default.cyan(field.name)}${optionalHint}${typeHint}${description}:`,
    validate: required ? createRequiredValidator(field.name) : void 0
  });
}

// src/commands/bisect/index.ts
var import_open = __toESM(require_open(), 1);
var import_execa = __toESM(require_execa(), 1);
var import_pluralize = __toESM(require_pluralize(), 1);
var import_chalk10 = __toESM(require_source(), 1);
import { resolve as resolve2 } from "path";
import { URLSearchParams as URLSearchParams2, parse as parse3 } from "url";

// src/util/format-date.ts
var import_ms4 = __toESM(require_ms(), 1);
var import_chalk9 = __toESM(require_source(), 1);
var import_format = __toESM(require_format(), 1);
function formatDate(dateStrOrNumber) {
  if (!dateStrOrNumber) {
    return import_chalk9.default.gray("-");
  }
  const date = new Date(dateStrOrNumber);
  const diff = date.getTime() - Date.now();
  return diff < 0 ? `${(0, import_format.default)(date, "DD MMMM YYYY HH:mm:ss")} ${import_chalk9.default.gray(
    `[${(0, import_ms4.default)(-diff)} ago]`
  )}` : `${(0, import_format.default)(date, "DD MMMM YYYY HH:mm:ss")} ${import_chalk9.default.gray(
    `[in ${(0, import_ms4.default)(diff)}]`
  )}`;
}
function formatDateWithoutTime(dateStrOrNumber) {
  if (!dateStrOrNumber) {
    return import_chalk9.default.gray("-");
  }
  const date = new Date(dateStrOrNumber);
  const diff = date.getTime() - Date.now();
  return diff < 0 ? `${(0, import_format.default)(date, "MMM DD YYYY")} ${import_chalk9.default.gray(`[${(0, import_ms4.default)(-diff)} ago]`)}` : `${(0, import_format.default)(date, "MMM DD YYYY")} ${import_chalk9.default.gray(`[in ${(0, import_ms4.default)(diff)}]`)}`;
}

// src/util/bisect/normalize-url.ts
function hasScheme(url) {
  return url.startsWith("http://") || url.startsWith("https://");
}
function normalizeURL(url) {
  return hasScheme(url) ? url : `https://${url}`;
}

// src/util/telemetry/commands/bisect/index.ts
var BisectTelemetryClient = class extends TelemetryClient {
  trackCliOptionGood(good) {
    if (good) {
      this.trackCliOption({
        option: "good",
        value: this.redactedValue
      });
    }
  }
  trackCliOptionBad(bad) {
    if (bad) {
      this.trackCliOption({
        option: "bad",
        value: this.redactedValue
      });
    }
  }
  trackCliOptionPath(path3) {
    if (path3) {
      this.trackCliOption({
        option: "path",
        value: this.redactedValue
      });
    }
  }
  trackCliOptionRun(run) {
    if (run) {
      this.trackCliOption({
        option: "run",
        value: this.redactedValue
      });
    }
  }
  trackCliFlagOpen(open7) {
    if (open7) {
      this.trackCliFlag("open");
    }
  }
};

// src/commands/bisect/index.ts
async function bisect(client) {
  let parsedArgs = null;
  const flagsSpecification = getFlagsSpecification(bisectCommand.options);
  try {
    parsedArgs = parseArguments(client.argv.slice(2), flagsSpecification);
  } catch (error) {
    printError(error);
    return 1;
  }
  const telemetry2 = new BisectTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  if (parsedArgs.flags["--help"]) {
    telemetry2.trackCliFlagHelp("bisect");
    output_manager_default.print(help(bisectCommand, { columns: client.stderr.columns }));
    return 2;
  }
  telemetry2.trackCliOptionGood(parsedArgs.flags["--good"]);
  telemetry2.trackCliOptionBad(parsedArgs.flags["--bad"]);
  telemetry2.trackCliOptionPath(parsedArgs.flags["--path"]);
  telemetry2.trackCliOptionRun(parsedArgs.flags["--run"]);
  telemetry2.trackCliFlagOpen(parsedArgs.flags["--open"]);
  const scope = await getScope(client);
  const { contextName } = scope;
  let bad = parsedArgs.flags["--bad"] || await client.input.text({
    message: `Specify a URL where the bug occurs:`,
    validate: (val) => val ? true : "A URL must be provided"
  });
  let good = parsedArgs.flags["--good"] || await client.input.text({
    message: `Specify a URL where the bug does not occur:`,
    validate: (val) => val ? true : "A URL must be provided"
  });
  let subpath = parsedArgs.flags["--path"] || "";
  let run = parsedArgs.flags["--run"] || "";
  const openEnabled = parsedArgs.flags["--open"] || false;
  if (run) {
    run = resolve2(run);
  }
  bad = normalizeURL(bad);
  let parsed = parse3(bad);
  if (!parsed.hostname) {
    output_manager_default.error("Invalid input: no hostname provided");
    return 1;
  }
  bad = parsed.hostname;
  if (typeof parsed.path === "string" && parsed.path !== "/") {
    if (subpath && subpath !== parsed.path) {
      output_manager_default.note(
        `Ignoring subpath ${import_chalk10.default.bold(
          parsed.path
        )} in favor of \`--path\` argument ${import_chalk10.default.bold(subpath)}`
      );
    } else {
      subpath = parsed.path;
    }
  }
  good = normalizeURL(good);
  parsed = parse3(good);
  if (!parsed.hostname) {
    output_manager_default.error("Invalid input: no hostname provided");
    return 1;
  }
  good = parsed.hostname;
  if (typeof parsed.path === "string" && parsed.path !== "/" && subpath && subpath !== parsed.path) {
    output_manager_default.note(
      `Ignoring subpath ${import_chalk10.default.bold(
        parsed.path
      )} which does not match ${import_chalk10.default.bold(subpath)}`
    );
  }
  if (!subpath) {
    subpath = await client.input.text({
      message: `Specify the URL subpath where the bug occurs:`,
      validate: (val) => val ? true : "A subpath must be provided"
    });
  }
  output_manager_default.spinner("Retrieving deployments\u2026");
  const badDeployment = await getDeployment(client, contextName, bad).catch(
    (err) => err
  );
  if (badDeployment) {
    if (badDeployment instanceof Error) {
      badDeployment.message += ` when requesting bad deployment "${normalizeURL(
        bad
      )}"`;
      output_manager_default.prettyError(badDeployment);
      return 1;
    }
    bad = badDeployment.url;
  } else {
    output_manager_default.error(`Failed to retrieve ${import_chalk10.default.bold("bad")} Deployment: ${bad}`);
    return 1;
  }
  const goodDeployment = await getDeployment(client, contextName, good).catch(
    (err) => err
  );
  if (goodDeployment) {
    if (goodDeployment instanceof Error) {
      goodDeployment.message += ` when requesting good deployment "${normalizeURL(
        good
      )}"`;
      output_manager_default.prettyError(goodDeployment);
      return 1;
    }
    good = goodDeployment.url;
  } else {
    output_manager_default.error(
      `Failed to retrieve ${import_chalk10.default.bold("good")} Deployment: ${good}`
    );
    return 1;
  }
  const { projectId } = badDeployment;
  if (projectId !== goodDeployment.projectId) {
    output_manager_default.error(`Good and Bad deployments must be from the same Project`);
    return 1;
  }
  if (badDeployment.url === goodDeployment.url) {
    output_manager_default.error(`Good and Bad deployments must be different`);
    return 1;
  }
  if (badDeployment.createdAt < goodDeployment.createdAt) {
    output_manager_default.error(`Good deployment must be older than the Bad deployment`);
    return 1;
  }
  if (badDeployment.target !== goodDeployment.target) {
    output_manager_default.error(
      `Bad deployment target "${badDeployment.target || "preview"}" does not match good deployment target "${goodDeployment.target || "preview"}"`
    );
    return 1;
  }
  let deployments = [];
  const query = new URLSearchParams2();
  query.set("projectId", projectId);
  if (badDeployment.target) {
    query.set("target", badDeployment.target);
  }
  query.set("state", "READY");
  query.set("until", String(badDeployment.createdAt + 1));
  for await (const chunk of client.fetchPaginated(
    `/v6/deployments?${query}`,
    {
      accountId: badDeployment.ownerId
    }
  )) {
    let newDeployments = chunk.deployments;
    let hasGood = false;
    for (let i = 0; i < newDeployments.length; i++) {
      if (newDeployments[i].url === good) {
        newDeployments = newDeployments.slice(0, i);
        hasGood = true;
        break;
      }
    }
    deployments = deployments.concat(newDeployments);
    if (hasGood)
      break;
  }
  if (!deployments.length) {
    output_manager_default.error(
      "Cannot bisect because this project does not have any deployments"
    );
    return 1;
  }
  let lastBad = deployments.shift();
  while (deployments.length > 0) {
    output_manager_default.print("\n");
    const middleIndex = Math.floor(deployments.length / 2);
    const deployment = deployments[middleIndex];
    const rem = (0, import_pluralize.default)("deployment", deployments.length, true);
    const steps = Math.floor(Math.log2(deployments.length));
    const pSteps = (0, import_pluralize.default)("step", steps, true);
    output_manager_default.log(
      import_chalk10.default.magenta(
        `${import_chalk10.default.bold(
          "Bisecting:"
        )} ${rem} left to test after this (roughly ${pSteps})`
      ),
      import_chalk10.default.magenta
    );
    const testUrl = `https://${deployment.url}${subpath}`;
    output_manager_default.log(`${import_chalk10.default.bold("Deployment URL:")} ${link_default(testUrl)}`);
    output_manager_default.log(`${import_chalk10.default.bold("Date:")} ${formatDate(deployment.createdAt)}`);
    const commit2 = getCommit(deployment);
    if (commit2) {
      const shortSha = commit2.sha.substring(0, 7);
      const firstLine = commit2.message?.split("\n")[0];
      output_manager_default.log(`${import_chalk10.default.bold("Commit:")} [${shortSha}] ${firstLine}`);
    }
    let action;
    if (run) {
      const proc = await (0, import_execa.default)(run, [testUrl], {
        stdio: "inherit",
        reject: false,
        env: {
          ...process.env,
          HOST: deployment.url,
          URL: testUrl
        }
      });
      if (proc instanceof Error && typeof proc.exitCode !== "number") {
        output_manager_default.prettyError(proc);
        return 1;
      }
      const { exitCode: exitCode2 } = proc;
      let color;
      if (exitCode2 === 0) {
        color = import_chalk10.default.green;
        action = "good";
      } else if (exitCode2 === 125) {
        action = "skip";
        color = import_chalk10.default.grey;
      } else {
        action = "bad";
        color = import_chalk10.default.red;
      }
      output_manager_default.log(
        `Run script returned exit code ${import_chalk10.default.bold(String(exitCode2))}: ${color(
          action
        )}`
      );
    } else {
      if (openEnabled) {
        await (0, import_open.default)(testUrl);
      }
      action = await client.input.expand({
        message: "Select an action:",
        choices: [
          { key: "g", name: "Good", value: "good" },
          { key: "b", name: "Bad", value: "bad" },
          { key: "s", name: "Skip", value: "skip" }
        ]
      });
    }
    if (action === "good") {
      deployments = deployments.slice(0, middleIndex);
    } else if (action === "bad") {
      lastBad = deployment;
      deployments = deployments.slice(middleIndex + 1);
    } else if (action === "skip") {
      deployments.splice(middleIndex, 1);
    }
  }
  output_manager_default.print("\n");
  const result = [
    import_chalk10.default.bold(
      `The first bad deployment is: ${link_default(`https://${lastBad.url}`)}`
    ),
    "",
    `   ${import_chalk10.default.bold("Date:")} ${formatDate(lastBad.createdAt)}`
  ];
  const commit = getCommit(lastBad);
  if (commit) {
    const shortSha = commit.sha.substring(0, 7);
    const firstLine = commit.message?.split("\n")[0];
    result.push(` ${import_chalk10.default.bold("Commit:")} [${shortSha}] ${firstLine}`);
  }
  result.push(`${import_chalk10.default.bold("Inspect:")} ${link_default(lastBad.inspectorUrl)}`);
  output_manager_default.print(box(result.join("\n")));
  output_manager_default.print("\n");
  return 0;
}
function getCommit(deployment) {
  const sha = deployment.meta?.githubCommitSha || deployment.meta?.gitlabCommitSha || deployment.meta?.bitbucketCommitSha;
  if (!sha)
    return null;
  const message = deployment.meta?.githubCommitMessage || deployment.meta?.gitlabCommitMessage || deployment.meta?.bitbucketCommitMessage;
  return { sha, message };
}

// src/commands/blob/list.ts
import * as blob from "@vercel/blob";
var import_chalk11 = __toESM(require_source(), 1);
var import_ms5 = __toESM(require_ms(), 1);

// src/util/telemetry/commands/blob/list.ts
var BlobListTelemetryClient = class extends TelemetryClient {
  trackCliOptionLimit(limit) {
    if (limit) {
      this.trackCliOption({
        option: "limit",
        value: String(limit)
      });
    }
  }
  trackCliOptionCursor(cursor) {
    if (cursor) {
      this.trackCliOption({
        option: "cursor",
        value: cursor
      });
    }
  }
  trackCliOptionPrefix(prefix) {
    if (prefix) {
      this.trackCliOption({
        option: "prefix",
        value: this.redactedValue
      });
    }
  }
  trackCliOptionMode(mode) {
    if (mode) {
      this.trackCliOption({
        option: "mode",
        value: mode
      });
    }
  }
};

// src/commands/blob/list.ts
function isMode(mode) {
  return mode === "folded" || mode === "expanded";
}
async function list3(client, argv, rwToken) {
  const telemetryClient = new BlobListTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  const flagsSpecification = getFlagsSpecification(listSubcommand12.options);
  let parsedArgs;
  try {
    parsedArgs = parseArguments(argv, flagsSpecification);
  } catch (err) {
    printError(err);
    return 1;
  }
  const { args, flags } = parsedArgs;
  const validationResult = validateLsArgs({
    commandName: "blob list",
    args
  });
  if (validationResult !== 0) {
    return validationResult;
  }
  const {
    "--limit": limit,
    "--cursor": cursor,
    "--prefix": prefix,
    "--mode": modeFlag
  } = flags;
  telemetryClient.trackCliOptionLimit(limit);
  telemetryClient.trackCliOptionCursor(cursor);
  telemetryClient.trackCliOptionPrefix(prefix);
  telemetryClient.trackCliOptionMode(modeFlag);
  const mode = modeFlag ?? "expanded";
  if (!isMode(mode)) {
    output_manager_default.error(
      `Invalid mode: ${mode} has to be either 'folded' or 'expanded'`
    );
    return 1;
  }
  let list9;
  try {
    output_manager_default.debug("Fetching blobs");
    output_manager_default.spinner("Fetching blobs");
    list9 = await blob.list({
      token: rwToken,
      limit: limit ?? 10,
      cursor,
      mode,
      prefix
    });
  } catch (err) {
    printError(err);
    return 1;
  }
  output_manager_default.stopSpinner();
  const headers = ["Uploaded At", "Size", "Pathname", "URL"];
  const urls = [];
  const tablePrint = table(
    [
      headers.map((header) => import_chalk11.default.dim(header)),
      ...list9.blobs.map((blob6) => {
        urls.push(blob6.url);
        const uploadedAt = (0, import_ms5.default)(Date.now() - new Date(blob6.uploadedAt).getTime());
        return [uploadedAt, String(blob6.size), blob6.pathname, blob6.url];
      })
    ],
    { hsep: 5 }
  ).replace(/^/gm, "  ");
  if (list9.blobs.length > 0) {
    output_manager_default.print(`
${tablePrint}

`);
  } else {
    output_manager_default.log("No blobs in this store");
  }
  if (list9.cursor) {
    const nextFlags = getCommandFlags(flags, ["_", "--cursor"]);
    output_manager_default.log(
      `To display the next page run ${getCommandName(
        `blob list${nextFlags} --cursor ${list9.cursor}`
      )}`
    );
  }
  return 0;
}

// src/util/telemetry/commands/blob/index.ts
var BlobTelemetryClient = class extends TelemetryClient {
  trackCliSubcommandList(actual) {
    this.trackCliSubcommand({
      subcommand: "list",
      value: actual
    });
  }
  trackCliSubcommandPut(actual) {
    this.trackCliSubcommand({
      subcommand: "put",
      value: actual
    });
  }
  trackCliSubcommandGet(actual) {
    this.trackCliSubcommand({
      subcommand: "get",
      value: actual
    });
  }
  trackCliSubcommandDel(actual) {
    this.trackCliSubcommand({
      subcommand: "del",
      value: actual
    });
  }
  trackCliSubcommandCopy(actual) {
    this.trackCliSubcommand({
      subcommand: "copy",
      value: actual
    });
  }
  trackCliSubcommandCreateStore(actual) {
    this.trackCliSubcommand({
      subcommand: "create-store",
      value: actual
    });
  }
  trackCliSubcommandDeleteStore(actual) {
    this.trackCliSubcommand({
      subcommand: "delete-store",
      value: actual
    });
  }
  trackCliSubcommandGetStore(actual) {
    this.trackCliSubcommand({
      subcommand: "get-store",
      value: actual
    });
  }
  trackCliSubcommandStore(actual) {
    this.trackCliSubcommand({
      subcommand: "store",
      value: actual
    });
  }
  trackCliOptionRwToken() {
    this.trackCliOption({
      option: "--rw-token",
      value: this.redactedValue
    });
  }
};

// src/commands/blob/put.ts
import * as blob2 from "@vercel/blob";
var import_error_utils = __toESM(require_dist(), 1);
import { statSync } from "fs";
import { open as open2 } from "fs/promises";
import { basename } from "path";
var import_chalk12 = __toESM(require_source(), 1);

// src/util/telemetry/commands/blob/put.ts
var BlobPutTelemetryClient = class extends TelemetryClient {
  trackCliOptionAccess(value) {
    if (value) {
      this.trackCliOption({
        option: "access",
        value
      });
    }
  }
  trackCliArgumentPathToFile(pathToFile) {
    if (pathToFile) {
      this.trackCliArgument({
        arg: "pathToFile",
        value: this.redactedValue
      });
    }
  }
  trackCliInputSourceStdin() {
    this.trackCliArgument({
      arg: "pathToFile",
      value: "__vercel_stdin__"
    });
  }
  trackCliFlagAddRandomSuffix(addRandomSuffix) {
    if (addRandomSuffix) {
      this.trackCliFlag("add-random-suffix");
    }
  }
  trackCliOptionPathname(pathname) {
    if (pathname) {
      this.trackCliOption({
        option: "pathname",
        value: this.redactedValue
      });
    }
  }
  trackCliFlagMultipart(multipart) {
    if (multipart) {
      this.trackCliFlag("multipart");
    }
  }
  trackCliOptionContentType(contentType) {
    if (contentType) {
      this.trackCliOption({
        option: "content-type",
        value: contentType
      });
    }
  }
  trackCliOptionCacheControlMaxAge(cacheControlMaxAge) {
    if (cacheControlMaxAge) {
      this.trackCliOption({
        option: "cache-control-max-age",
        value: String(cacheControlMaxAge)
      });
    }
  }
  trackCliFlagAllowOverwrite(allowOverwrite) {
    if (allowOverwrite) {
      this.trackCliFlag("allow-overwrite");
    }
  }
  trackCliFlagForce(force) {
    if (force) {
      this.trackCliFlag("force");
    }
  }
  trackCliOptionIfMatch(ifMatch) {
    if (ifMatch) {
      this.trackCliOption({
        option: "if-match",
        value: this.redactedValue
      });
    }
  }
};

// src/util/blob/access.ts
var VALID_ACCESS_VALUES = ["public", "private"];
function isAccess(value) {
  return VALID_ACCESS_VALUES.includes(value);
}
function parseAccessFlag(accessFlag) {
  const access = accessFlag ?? "public";
  if (!isAccess(access)) {
    output_manager_default.error(
      `Invalid access value: '${access}'. Must be 'public' or 'private'.`
    );
    return null;
  }
  return access;
}

// src/commands/blob/put.ts
async function put2(client, argv, rwToken) {
  const telemetryClient = new BlobPutTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  const flagsSpecification = getFlagsSpecification(putSubcommand.options);
  let parsedArgs;
  try {
    parsedArgs = parseArguments(argv, flagsSpecification);
  } catch (err) {
    printError(err);
    return 1;
  }
  const {
    flags,
    args: [filePath]
  } = parsedArgs;
  const {
    "--access": accessFlag,
    "--add-random-suffix": addRandomSuffix,
    "--pathname": pathnameFlag,
    "--multipart": multipart,
    "--content-type": contentType,
    "--cache-control-max-age": cacheControlMaxAge,
    "--allow-overwrite": allowOverwrite,
    "--force": force,
    "--if-match": ifMatch
  } = flags;
  if (force) {
    output_manager_default.warn("--force is deprecated, use --allow-overwrite instead");
  }
  const access = parseAccessFlag(accessFlag);
  if (!access)
    return 1;
  if (filePath) {
    telemetryClient.trackCliArgumentPathToFile(filePath);
  }
  telemetryClient.trackCliOptionAccess(accessFlag);
  telemetryClient.trackCliFlagAddRandomSuffix(addRandomSuffix);
  telemetryClient.trackCliOptionPathname(pathnameFlag);
  telemetryClient.trackCliFlagMultipart(multipart);
  telemetryClient.trackCliOptionContentType(contentType);
  telemetryClient.trackCliOptionCacheControlMaxAge(cacheControlMaxAge);
  telemetryClient.trackCliFlagAllowOverwrite(allowOverwrite);
  telemetryClient.trackCliFlagForce(force);
  telemetryClient.trackCliOptionIfMatch(ifMatch);
  let putBody;
  let pathname;
  if (!filePath) {
    if (client.stdin.isTTY) {
      output_manager_default.error(
        `Missing input. Usage: ${import_chalk12.default.cyan(
          `${getCommandName("blob put <file>")}`
        )} or pipe data: ${import_chalk12.default.cyan("cat file.txt | vercel blob put --pathname <pathname>")}`
      );
      return 1;
    }
    if (!pathnameFlag) {
      output_manager_default.error(
        `Missing pathname. When reading from stdin, you must specify --pathname. Usage: ${import_chalk12.default.cyan(
          "cat file.txt | vercel blob put --pathname <pathname>"
        )}`
      );
      return 1;
    }
    putBody = process.stdin;
    pathname = pathnameFlag;
    telemetryClient.trackCliInputSourceStdin();
  } else {
    try {
      const stats = statSync(filePath);
      const isFile = stats.isFile();
      if (isFile) {
        const file = await open2(filePath, "r");
        putBody = file.createReadStream();
        pathname = pathnameFlag ?? basename(filePath);
      } else {
        output_manager_default.error("Path to upload is not a file");
        return 1;
      }
    } catch (err) {
      output_manager_default.debug(`Error reading file: ${err}`);
      if ((0, import_error_utils.isErrnoException)(err)) {
        output_manager_default.error(`File doesn't exist at '${filePath}'`);
        return 1;
      }
      output_manager_default.error("Error while reading file");
      return 1;
    }
  }
  if (!pathname || !putBody) {
    output_manager_default.error(
      `Missing pathname or input. Usage: ${import_chalk12.default.cyan(
        `${getCommandName("blob put <file>")}`
      )} or ${import_chalk12.default.cyan(
        `cat file.txt | ${getCommandName("blob put --pathname <pathname>")}`
      )}`
    );
    return 1;
  }
  let result;
  try {
    output_manager_default.debug("Uploading blob");
    output_manager_default.spinner("Uploading blob");
    result = await blob2.put(pathname, putBody, {
      token: rwToken,
      access,
      addRandomSuffix: addRandomSuffix ?? false,
      multipart: multipart ?? true,
      contentType,
      cacheControlMaxAge,
      allowOverwrite: allowOverwrite ?? force ?? false,
      ifMatch
    });
  } catch (err) {
    printError(err);
    return 1;
  }
  output_manager_default.stopSpinner();
  output_manager_default.success(result.url);
  return 0;
}

// src/commands/blob/get.ts
import * as blob3 from "@vercel/blob";

// src/util/telemetry/commands/blob/get.ts
var BlobGetTelemetryClient = class extends TelemetryClient {
  trackCliArgumentUrlOrPathname(value) {
    if (value) {
      this.trackCliArgument({
        arg: "urlOrPathname",
        value: this.redactedValue
      });
    }
  }
  trackCliOptionAccess(value) {
    if (value) {
      this.trackCliOption({
        option: "access",
        value
      });
    }
  }
  trackCliOptionOutput(value) {
    if (value) {
      this.trackCliOption({
        option: "output",
        value: this.redactedValue
      });
    }
  }
  trackCliOptionIfNoneMatch(ifNoneMatch) {
    if (ifNoneMatch) {
      this.trackCliOption({
        option: "if-none-match",
        value: this.redactedValue
      });
    }
  }
};

// src/commands/blob/get.ts
var import_bytes = __toESM(require_bytes(), 1);
import { createWriteStream } from "fs";
import { Readable } from "stream";
import { pipeline } from "stream/promises";
async function get2(client, argv, rwToken) {
  const telemetryClient = new BlobGetTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  const flagsSpecification = getFlagsSpecification(getSubcommand.options);
  let parsedArgs;
  try {
    parsedArgs = parseArguments(argv, flagsSpecification);
  } catch (err) {
    printError(err);
    return 1;
  }
  const {
    flags,
    args: [urlOrPathname]
  } = parsedArgs;
  const {
    "--access": accessFlag,
    "--output": outputPath,
    "--if-none-match": ifNoneMatch
  } = flags;
  if (!urlOrPathname) {
    output_manager_default.error(
      `Missing required argument. Usage: ${getCommandName("blob get <urlOrPathname>")}`
    );
    return 1;
  }
  const access = parseAccessFlag(accessFlag);
  if (!access)
    return 1;
  telemetryClient.trackCliArgumentUrlOrPathname(urlOrPathname);
  telemetryClient.trackCliOptionAccess(accessFlag);
  telemetryClient.trackCliOptionOutput(outputPath);
  telemetryClient.trackCliOptionIfNoneMatch(ifNoneMatch);
  try {
    output_manager_default.debug("Downloading blob");
    if (outputPath) {
      output_manager_default.spinner("Downloading blob");
    }
    const result = await blob3.get(urlOrPathname, {
      token: rwToken,
      access,
      ifNoneMatch
    });
    if (result && result.statusCode === 304) {
      output_manager_default.log("Not modified (304)");
      return 0;
    }
    if (!result || !result.stream) {
      output_manager_default.error(`Blob not found: ${urlOrPathname}`);
      return 1;
    }
    const nodeStream = Readable.fromWeb(result.stream);
    if (outputPath) {
      const writeStream = createWriteStream(outputPath);
      await pipeline(nodeStream, writeStream);
      output_manager_default.stopSpinner();
      const sizeInfo = result.blob.size ? ` (${(0, import_bytes.default)(result.blob.size)})` : "";
      const typeInfo = result.blob.contentType ? `, ${result.blob.contentType}` : "";
      output_manager_default.success(`Saved to ${outputPath}${sizeInfo}${typeInfo}`);
    } else {
      await pipeline(nodeStream, client.stdout, { end: false });
    }
  } catch (err) {
    output_manager_default.stopSpinner();
    printError(err);
    return 1;
  }
  return 0;
}

// src/commands/blob/del.ts
import * as blob4 from "@vercel/blob";

// src/util/telemetry/commands/blob/del.ts
var BlobDelTelemetryClient = class extends TelemetryClient {
  trackCliArgumentUrlsOrPathnames(urlsOrPathnames) {
    if (urlsOrPathnames) {
      this.trackCliArgument({
        arg: "urlsOrPathnames",
        value: this.redactedValue
      });
    }
  }
  trackCliOptionIfMatch(ifMatch) {
    if (ifMatch) {
      this.trackCliOption({
        option: "if-match",
        value: this.redactedValue
      });
    }
  }
};

// src/commands/blob/del.ts
async function del2(client, argv, rwToken) {
  const telemetryClient = new BlobDelTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  const flagsSpecification = getFlagsSpecification(delSubcommand.options);
  let parsedArgs;
  try {
    parsedArgs = parseArguments(argv, flagsSpecification);
  } catch (err) {
    printError(err);
    return 1;
  }
  if (!parsedArgs.args.length) {
    printError(
      `Missing required arguments: ${getCommandName("blob del urlOrPathname")}`
    );
    return 1;
  }
  const { args } = parsedArgs;
  const { "--if-match": ifMatch } = parsedArgs.flags;
  telemetryClient.trackCliArgumentUrlsOrPathnames(args[0]);
  telemetryClient.trackCliOptionIfMatch(ifMatch);
  try {
    output_manager_default.debug("Deleting blob");
    output_manager_default.spinner("Deleting blob");
    await blob4.del(args, { token: rwToken, ifMatch });
  } catch (err) {
    output_manager_default.error(`Error deleting blob: ${err}`);
    return 1;
  }
  output_manager_default.stopSpinner();
  output_manager_default.success("Blob deleted");
  return 0;
}

// src/commands/blob/copy.ts
import * as blob5 from "@vercel/blob";

// src/util/telemetry/commands/blob/copy.ts
var BlobCopyTelemetryClient = class extends TelemetryClient {
  trackCliOptionAccess(value) {
    if (value) {
      this.trackCliOption({
        option: "access",
        value
      });
    }
  }
  trackCliArgumentFromUrlOrPathname(value) {
    if (value) {
      this.trackCliArgument({
        arg: "fromUrlOrPathname",
        value: this.redactedValue
      });
    }
  }
  trackCliArgumentToPathname(value) {
    if (value) {
      this.trackCliArgument({
        arg: "toPathname",
        value: this.redactedValue
      });
    }
  }
  trackCliFlagAddRandomSuffix(value) {
    if (value) {
      this.trackCliFlag("add-random-suffix");
    }
  }
  trackCliOptionContentType(value) {
    if (value) {
      this.trackCliOption({
        option: "content-type",
        value
      });
    }
  }
  trackCliOptionCacheControlMaxAge(value) {
    if (value) {
      this.trackCliOption({
        option: "cache-control-max-age",
        value: String(value)
      });
    }
  }
  trackCliOptionIfMatch(ifMatch) {
    if (ifMatch) {
      this.trackCliOption({
        option: "if-match",
        value: this.redactedValue
      });
    }
  }
};

// src/commands/blob/copy.ts
async function copy2(client, argv, rwToken) {
  const telemetryClient = new BlobCopyTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  const flagsSpecification = getFlagsSpecification(copySubcommand.options);
  let parsedArgs;
  try {
    parsedArgs = parseArguments(argv, flagsSpecification);
  } catch (err) {
    printError(err);
    return 1;
  }
  if (!parsedArgs.args || parsedArgs.args.length < 2) {
    printError(
      `Missing required arguments: ${getCommandName(
        "blob copy fromUrlOrPathname toPathname"
      )}`
    );
    return 1;
  }
  const {
    args: [fromUrl, toPathname],
    flags: {
      "--access": accessFlag,
      "--add-random-suffix": addRandomSuffix,
      "--content-type": contentType,
      "--cache-control-max-age": cacheControlMaxAge,
      "--if-match": ifMatch
    }
  } = parsedArgs;
  const access = parseAccessFlag(accessFlag);
  if (!access)
    return 1;
  telemetryClient.trackCliArgumentFromUrlOrPathname(fromUrl);
  telemetryClient.trackCliArgumentToPathname(toPathname);
  telemetryClient.trackCliOptionAccess(accessFlag);
  telemetryClient.trackCliFlagAddRandomSuffix(addRandomSuffix);
  telemetryClient.trackCliOptionContentType(contentType);
  telemetryClient.trackCliOptionCacheControlMaxAge(cacheControlMaxAge);
  telemetryClient.trackCliOptionIfMatch(ifMatch);
  let result;
  try {
    output_manager_default.debug("Copying blob");
    output_manager_default.spinner("Copying blob");
    result = await blob5.copy(fromUrl, toPathname, {
      token: rwToken,
      access,
      addRandomSuffix: addRandomSuffix ?? false,
      contentType,
      cacheControlMaxAge,
      ifMatch
    });
  } catch (err) {
    printError(err);
    return 1;
  }
  output_manager_default.stopSpinner();
  output_manager_default.success(result.url);
  return 0;
}

// src/util/integration-resource/connect-resource-to-project.ts
async function connectResourceToProject(client, projectId, storeId, environments, accountId) {
  return client.fetch(`/v1/storage/stores/${storeId}/connections`, {
    json: true,
    method: "POST",
    body: {
      envVarEnvironments: environments,
      projectId,
      type: "integration"
    },
    accountId
  });
}

// src/commands/blob/store-add.ts
var import_chalk13 = __toESM(require_source(), 1);

// src/util/telemetry/commands/blob/store-add.ts
var BlobAddStoreTelemetryClient = class extends TelemetryClient {
  trackCliOptionAccess(value) {
    if (value) {
      this.trackCliOption({
        option: "access",
        value
      });
    }
  }
  trackCliArgumentName(value) {
    if (value) {
      this.trackCliArgument({
        arg: "name",
        value: this.redactedValue
      });
    }
  }
  trackCliOptionRegion(value) {
    if (value) {
      this.trackCliOption({
        option: "region",
        value: this.redactedValue
      });
    }
  }
};

// src/commands/blob/store-add.ts
async function addStore(client, argv) {
  const telemetryClient = new BlobAddStoreTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  const flagsSpecification = getFlagsSpecification(addStoreSubcommand.options);
  let parsedArgs;
  try {
    parsedArgs = parseArguments(argv, flagsSpecification);
  } catch (err) {
    printError(err);
    return 1;
  }
  const {
    args: [nameArg],
    flags
  } = parsedArgs;
  const accessFlag = flags["--access"];
  const access = parseAccessFlag(accessFlag);
  if (!access)
    return 1;
  const region = flags["--region"] || "iad1";
  let name = nameArg;
  if (!name) {
    name = await client.input.text({
      message: "Enter a name for your blob store",
      validate: (value) => {
        if (value.length < 5) {
          return "Name must be at least 5 characters long";
        }
        return true;
      }
    });
  }
  telemetryClient.trackCliArgumentName(name);
  telemetryClient.trackCliOptionAccess(accessFlag);
  telemetryClient.trackCliOptionRegion(flags["--region"]);
  const link = await getLinkedProject(client);
  let storeId;
  let storeRegion;
  try {
    output_manager_default.debug("Creating new blob store");
    output_manager_default.spinner("Creating new blob store");
    const requestBody = {
      name,
      region,
      access
    };
    const res = await client.fetch(
      "/v1/storage/stores/blob",
      {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(requestBody),
        accountId: link.status === "linked" ? link.org.id : void 0
      }
    );
    storeId = res.store.id;
    storeRegion = res.store.region;
  } catch (err) {
    printError(err);
    return 1;
  }
  output_manager_default.stopSpinner();
  const regionInfo = storeRegion ? ` in ${storeRegion}` : "";
  output_manager_default.success(`Blob store created: ${name} (${storeId})${regionInfo}`);
  if (link.status === "linked") {
    const res = await client.input.confirm(
      `Would you like to link this blob store to ${link.project.name}?`,
      true
    );
    if (res) {
      const environments = await client.input.checkbox({
        message: "Select environments",
        choices: [
          { name: "Production", value: "production", checked: true },
          { name: "Preview", value: "preview", checked: true },
          { name: "Development", value: "development", checked: true }
        ]
      });
      output_manager_default.spinner(
        `Connecting ${import_chalk13.default.bold(name)} to ${import_chalk13.default.bold(link.project.name)}...`
      );
      await connectResourceToProject(
        client,
        link.project.id,
        storeId,
        environments,
        link.org.id
      );
      output_manager_default.success(
        `Blob store ${import_chalk13.default.bold(name)} linked to ${import_chalk13.default.bold(
          link.project.name
        )}. Make sure to pull the new environment variables using ${getCommandName("env pull")}`
      );
    }
  }
  return 0;
}

// src/commands/blob/store-remove.ts
async function removeStore(client, argv, rwToken) {
  const flagsSpecification = getFlagsSpecification(
    removeStoreSubcommand.options
  );
  let parsedArgs;
  try {
    parsedArgs = parseArguments(argv, flagsSpecification);
  } catch (err) {
    printError(err);
    return 1;
  }
  let {
    args: [storeId]
  } = parsedArgs;
  if (!storeId && rwToken.success) {
    const [, , , id] = rwToken.token.split("_");
    storeId = `store_${id}`;
  }
  if (!storeId) {
    storeId = await client.input.text({
      message: "Enter the ID of the blob store you want to remove",
      validate: (value) => {
        if (value.length !== 22) {
          return "ID must be 22 characters long";
        }
        return true;
      }
    });
  }
  try {
    const link = await getLinkedProject(client);
    const store2 = await client.fetch(
      `/v1/storage/stores/${storeId}`,
      {
        method: "GET",
        accountId: link.status === "linked" ? link.org.id : void 0
      }
    );
    const res = await client.input.confirm(
      `Are you sure you want to remove ${store2.store.name} (${store2.store.id})? This action cannot be undone.`,
      false
    );
    if (!res) {
      output_manager_default.success("Blob store not removed");
      return 0;
    }
    output_manager_default.debug("Deleting blob store");
    output_manager_default.spinner("Deleting blob store");
    await client.fetch(
      `/v1/storage/stores/blob/${storeId}`,
      {
        method: "DELETE",
        accountId: link.status === "linked" ? link.org.id : void 0
      }
    );
  } catch (err) {
    printError(err);
    return 1;
  }
  output_manager_default.stopSpinner();
  output_manager_default.success("Blob store deleted");
  return 0;
}

// src/util/telemetry/commands/blob/store.ts
var BlobStoreTelemetryClient = class extends TelemetryClient {
  trackCliSubcommandAdd(actual) {
    this.trackCliSubcommand({
      subcommand: "add",
      value: actual
    });
  }
  trackCliSubcommandRemove(actual) {
    this.trackCliSubcommand({
      subcommand: "remove",
      value: actual
    });
  }
  trackCliSubcommandGet(actual) {
    this.trackCliSubcommand({
      subcommand: "get",
      value: actual
    });
  }
};

// src/commands/blob/store-get.ts
var import_bytes2 = __toESM(require_bytes(), 1);
var import_date_fns = __toESM(require_date_fns(), 1);
var import_chalk14 = __toESM(require_source(), 1);

// src/util/telemetry/commands/blob/store-get.ts
var BlobGetStoreTelemetryClient = class extends TelemetryClient {
  trackCliArgumentStoreId(value) {
    if (value) {
      this.trackCliArgument({
        arg: "storeId",
        value
      });
    }
  }
};

// src/commands/blob/store-get.ts
async function getStore(client, argv, rwToken) {
  const telemetryClient = new BlobGetStoreTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  const flagsSpecification = getFlagsSpecification(getStoreSubcommand.options);
  let parsedArgs;
  try {
    parsedArgs = parseArguments(argv, flagsSpecification);
  } catch (err) {
    printError(err);
    return 1;
  }
  const {
    args: [storeIdArg]
  } = parsedArgs;
  let storeId = storeIdArg;
  if (!storeId && rwToken.success) {
    const [, , , id] = rwToken.token.split("_");
    storeId = `store_${id}`;
  }
  if (!storeId) {
    storeId = await client.input.text({
      message: "Enter the ID of the blob store you want to remove",
      validate: (value) => {
        if (value.length !== 22) {
          return "ID must be 22 characters long";
        }
        return true;
      }
    });
  }
  telemetryClient.trackCliArgumentStoreId(storeId);
  try {
    const link = await getLinkedProject(client);
    output_manager_default.debug("Getting blob store");
    output_manager_default.spinner("Getting blob store");
    const store2 = await client.fetch(`/v1/storage/stores/${storeId}`, {
      method: "GET",
      accountId: link.status === "linked" ? link.org.id : void 0
    });
    const dateTimeFormat = "MM/DD/YYYY HH:mm:ss.SS";
    const regionInfo = store2.store.region ? `
Region: ${store2.store.region}` : "";
    const accessInfo = `
Access: ${store2.store.access === "private" ? "Private" : "Public"}`;
    output_manager_default.print(
      `Blob Store: ${import_chalk14.default.bold(store2.store.name)} (${import_chalk14.default.dim(store2.store.id)})
Billing State: ${store2.store.billingState === "active" ? import_chalk14.default.green("Active") : import_chalk14.default.red("Inactive")}
Size: ${(0, import_bytes2.default)(store2.store.size)}${regionInfo}${accessInfo}
Created At: ${(0, import_date_fns.format)(new Date(store2.store.createdAt), dateTimeFormat)}
Updated At: ${(0, import_date_fns.format)(new Date(store2.store.updatedAt), dateTimeFormat)}
`
    );
  } catch (err) {
    printError(err);
    return 1;
  }
  output_manager_default.stopSpinner();
  return 0;
}

// src/commands/blob/store.ts
var COMMAND_CONFIG2 = {
  add: getCommandAliases(addStoreSubcommand),
  remove: getCommandAliases(removeStoreSubcommand),
  get: getCommandAliases(getStoreSubcommand)
};
async function store(client, rwToken) {
  const telemetry2 = new BlobStoreTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  const flagsSpecification = getFlagsSpecification(storeSubcommand.options);
  let parsedArgs;
  try {
    parsedArgs = parseArguments(client.argv.slice(2), flagsSpecification, {
      permissive: true
    });
  } catch (err) {
    printError(err);
    return 1;
  }
  const subArgs = parsedArgs.args.slice(2);
  const { subcommand, args, subcommandOriginal } = getSubcommand3(
    subArgs,
    COMMAND_CONFIG2
  );
  const needHelp = parsedArgs.flags["--help"];
  if (!subcommand && needHelp) {
    telemetry2.trackCliFlagHelp("blob store", subcommand);
    output_manager_default.print(help(storeSubcommand, { columns: client.stderr.columns }));
    return 2;
  }
  function printHelp(command) {
    output_manager_default.print(
      help(command, { parent: storeSubcommand, columns: client.stderr.columns })
    );
  }
  switch (subcommand) {
    case "add":
      if (needHelp) {
        telemetry2.trackCliFlagHelp("blob store", subcommandOriginal);
        printHelp(addStoreSubcommand);
        return 2;
      }
      telemetry2.trackCliSubcommandAdd(subcommandOriginal);
      return addStore(client, args);
    case "remove":
      if (needHelp) {
        telemetry2.trackCliFlagHelp("blob store", subcommandOriginal);
        printHelp(removeStoreSubcommand);
        return 2;
      }
      telemetry2.trackCliSubcommandRemove(subcommandOriginal);
      return removeStore(client, args, rwToken);
    case "get":
      if (needHelp) {
        telemetry2.trackCliFlagHelp("blob store", subcommandOriginal);
        printHelp(getStoreSubcommand);
        return 2;
      }
      telemetry2.trackCliSubcommandGet(subcommandOriginal);
      return getStore(client, args, rwToken);
    default:
      output_manager_default.error(getInvalidSubcommand(COMMAND_CONFIG2));
      output_manager_default.print(help(storeSubcommand, { columns: client.stderr.columns }));
      return 2;
  }
}

// src/util/blob/token.ts
import { resolve as resolve3 } from "path";

// src/util/output/list-item.ts
var import_chalk15 = __toESM(require_source(), 1);
var listItem = (msg, n) => {
  if (!n) {
    n = "-";
  }
  if (Number(n)) {
    n += ".";
  }
  return `${(0, import_chalk15.default)(n.toString())} ${msg}`;
};
var list_item_default = listItem;

// src/util/blob/token.ts
var ErrorMessage = `No Vercel Blob token found. To fix this issue, choose one of the following options:
${list_item_default(`Pass the token directly as an option: ${getCommandName("blob list --rw-token BLOB_READ_WRITE_TOKEN")}`, 1)}
${list_item_default(`Set the Token as an environment variable: ${cmd(`BLOB_READ_WRITE_TOKEN=BLOB_READ_WRITE_TOKEN ${packageName} blob list`)}`, 2)}
${list_item_default("Link your current folder to a Vercel Project that has a Vercel Blob store connected", 3)}`;
async function getBlobRWToken(client, argv) {
  const flagsSpecification = getFlagsSpecification(blobCommand.options);
  try {
    const parsedArgs = parseArguments(argv, flagsSpecification);
    const {
      flags: { "--rw-token": rwToken }
    } = parsedArgs;
    if (rwToken) {
      return { token: rwToken, success: true };
    }
  } catch (err) {
  }
  if (process.env.BLOB_READ_WRITE_TOKEN) {
    return { token: process.env.BLOB_READ_WRITE_TOKEN, success: true };
  }
  const filename = ".env.local";
  const fullPath = resolve3(client.cwd, filename);
  try {
    const env = await createEnvObject(fullPath);
    if (env?.BLOB_READ_WRITE_TOKEN) {
      return { token: env.BLOB_READ_WRITE_TOKEN, success: true };
    }
  } catch (error) {
  }
  return {
    error: ErrorMessage,
    success: false
  };
}

// src/commands/blob/index.ts
var COMMAND_CONFIG3 = {
  list: getCommandAliases(listSubcommand12),
  put: getCommandAliases(putSubcommand),
  get: getCommandAliases(getSubcommand),
  del: getCommandAliases(delSubcommand),
  copy: getCommandAliases(copySubcommand),
  "create-store": getCommandAliases(createStoreSubcommand),
  "delete-store": getCommandAliases(deleteStoreSubcommand),
  "get-store": getCommandAliases(getStoreInfoSubcommand),
  store: getCommandAliases(storeSubcommand)
};
async function main2(client) {
  const telemetry2 = new BlobTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  const flagsSpecification = getFlagsSpecification(blobCommand.options);
  let parsedArgs;
  try {
    parsedArgs = parseArguments(client.argv.slice(2), flagsSpecification, {
      permissive: true
    });
  } catch (err) {
    printError(err);
    return 1;
  }
  const subArgs = parsedArgs.args.slice(1);
  const { subcommand, args, subcommandOriginal } = getSubcommand3(
    subArgs,
    COMMAND_CONFIG3
  );
  const needHelp = parsedArgs.flags["--help"];
  if (!subcommand && needHelp) {
    telemetry2.trackCliFlagHelp("blob", subcommand);
    output_manager_default.print(help(blobCommand, { columns: client.stderr.columns }));
    return 2;
  }
  function printHelp(command) {
    output_manager_default.print(
      help(command, { parent: blobCommand, columns: client.stderr.columns })
    );
  }
  const token = await getBlobRWToken(client, client.argv);
  telemetry2.trackCliOptionRwToken();
  switch (subcommand) {
    case "list":
      if (needHelp) {
        telemetry2.trackCliFlagHelp("blob", subcommandOriginal);
        printHelp(listSubcommand12);
        return 2;
      }
      telemetry2.trackCliSubcommandList(subcommandOriginal);
      if (!token.success) {
        printError(token.error);
        return 1;
      }
      return list3(client, args, token.token);
    case "put":
      if (needHelp) {
        telemetry2.trackCliFlagHelp("blob", subcommandOriginal);
        printHelp(putSubcommand);
        return 2;
      }
      telemetry2.trackCliSubcommandPut(subcommandOriginal);
      if (!token.success) {
        printError(token.error);
        return 1;
      }
      return put2(client, args, token.token);
    case "get":
      if (needHelp) {
        telemetry2.trackCliFlagHelp("blob", subcommandOriginal);
        printHelp(getSubcommand);
        return 2;
      }
      telemetry2.trackCliSubcommandGet(subcommandOriginal);
      if (!token.success) {
        printError(token.error);
        return 1;
      }
      return get2(client, args, token.token);
    case "del":
      if (needHelp) {
        telemetry2.trackCliFlagHelp("blob", subcommandOriginal);
        printHelp(delSubcommand);
        return 2;
      }
      telemetry2.trackCliSubcommandDel(subcommandOriginal);
      if (!token.success) {
        printError(token.error);
        return 1;
      }
      return del2(client, args, token.token);
    case "copy":
      if (needHelp) {
        telemetry2.trackCliFlagHelp("blob", subcommandOriginal);
        printHelp(copySubcommand);
        return 2;
      }
      telemetry2.trackCliSubcommandCopy(subcommandOriginal);
      if (!token.success) {
        printError(token.error);
        return 1;
      }
      return copy2(client, args, token.token);
    case "create-store":
      if (needHelp) {
        telemetry2.trackCliFlagHelp("blob", subcommandOriginal);
        printHelp(createStoreSubcommand);
        return 2;
      }
      telemetry2.trackCliSubcommandCreateStore(subcommandOriginal);
      return addStore(client, args);
    case "delete-store":
      if (needHelp) {
        telemetry2.trackCliFlagHelp("blob", subcommandOriginal);
        printHelp(deleteStoreSubcommand);
        return 2;
      }
      telemetry2.trackCliSubcommandDeleteStore(subcommandOriginal);
      if (!token.success) {
        printError(token.error);
        return 1;
      }
      return removeStore(client, args, token);
    case "get-store":
      if (needHelp) {
        telemetry2.trackCliFlagHelp("blob", subcommandOriginal);
        printHelp(getStoreInfoSubcommand);
        return 2;
      }
      telemetry2.trackCliSubcommandGetStore(subcommandOriginal);
      if (!token.success) {
        printError(token.error);
        return 1;
      }
      return getStore(client, args, token);
    case "store":
      output_manager_default.warn(
        "`vercel blob store` is deprecated. Use `vercel blob create-store`, `vercel blob delete-store`, or `vercel blob get-store` instead."
      );
      telemetry2.trackCliSubcommandStore(subcommandOriginal);
      return store(client, token);
    default:
      output_manager_default.error(getInvalidSubcommand(COMMAND_CONFIG3));
      output_manager_default.print(help(blobCommand, { columns: client.stderr.columns }));
      return 2;
  }
}

// src/util/telemetry/commands/cache/purge.ts
var CachePurgeTelemetryClient = class extends TelemetryClient {
  trackCliFlagYes(yes) {
    if (yes) {
      this.trackCliFlag("yes");
    }
  }
  trackCliOptionType(type) {
    if (type) {
      this.trackCliOption({
        option: "type",
        value: type
      });
    }
  }
};

// src/commands/cache/purge.ts
async function purge(client, argv) {
  const telemetry2 = new CachePurgeTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(purgeSubcommand.options);
  try {
    parsedArgs = parseArguments(argv, flagsSpecification);
  } catch (err) {
    printError(err);
    return 1;
  }
  const link = await getLinkedProject(client);
  if (link.status === "not_linked") {
    output_manager_default.error(
      "No project linked. Run `vercel link` to link a project to this directory."
    );
    return 1;
  }
  if (link.status === "error") {
    return link.exitCode;
  }
  const { project, org } = link;
  client.config.currentTeam = org.type === "team" ? org.id : void 0;
  const yes = Boolean(parsedArgs.flags["--yes"]);
  telemetry2.trackCliFlagYes(yes);
  const type = parsedArgs.flags["--type"] || "all";
  telemetry2.trackCliOptionType(parsedArgs.flags["--type"]);
  const cacheTypeMap = {
    cdn: "the CDN cache",
    data: "the Data cache",
    all: "the CDN cache and Data cache"
  };
  const validTypes = Object.keys(cacheTypeMap);
  if (!validTypes.includes(type)) {
    output_manager_default.error(
      `Invalid cache type "${type}". Valid types are: ${validTypes.join(", ")}`
    );
    return 1;
  }
  const typeDesciption = cacheTypeMap[type];
  const msg = `You are about to purge ${typeDesciption} for project ${project.name}`;
  const query = new URLSearchParams({ projectIdOrName: project.id }).toString();
  if (!yes) {
    if (!process.stdin.isTTY) {
      output_manager_default.print(
        `${msg}. To continue, run ${getCommandName("cache purge --yes")}.`
      );
      return 1;
    }
    const confirmed = await client.input.confirm(`${msg}. Continue?`, true);
    if (!confirmed) {
      output_manager_default.print(`Canceled.
`);
      return 0;
    }
  }
  const requests = [];
  if (type === "cdn" || type === "all") {
    requests.push(
      client.fetch(`/v1/edge-cache/purge-all?${query}`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        }
      })
    );
  }
  if (type === "data" || type === "all") {
    requests.push(
      client.fetch(`/v1/data-cache/purge-all?${query}`, {
        method: "DELETE",
        headers: {
          "Content-Type": "application/json"
        }
      })
    );
  }
  await Promise.all(requests);
  output_manager_default.print(
    prependEmoji(`Successfully purged ${typeDesciption}`, emoji("success")) + `
`
  );
  return 0;
}

// src/util/telemetry/commands/cache/invalidate.ts
var CacheInvalidateTelemetryClient = class extends TelemetryClient {
  trackCliFlagYes(yes) {
    if (yes) {
      this.trackCliFlag("yes");
    }
  }
  trackCliOptionTag(tag) {
    if (tag) {
      this.trackCliOption({
        option: "tag",
        value: tag
      });
    }
  }
  trackCliOptionSrcimg(srcimg) {
    if (srcimg) {
      this.trackCliOption({
        option: "srcimg",
        value: srcimg
      });
    }
  }
};

// src/commands/cache/invalidate.ts
var import_pluralize2 = __toESM(require_pluralize(), 1);
async function invalidate(client, argv) {
  const telemetry2 = new CacheInvalidateTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(
    invalidateSubcommand.options
  );
  try {
    parsedArgs = parseArguments(argv, flagsSpecification);
  } catch (err) {
    printError(err);
    return 1;
  }
  const link = await getLinkedProject(client);
  if (link.status === "not_linked") {
    output_manager_default.error(
      "No project linked. Run `vercel link` to link a project to this directory."
    );
    return 1;
  }
  if (link.status === "error") {
    return link.exitCode;
  }
  const { project, org } = link;
  client.config.currentTeam = org.type === "team" ? org.id : void 0;
  const yes = Boolean(parsedArgs.flags["--yes"]);
  const tag = parsedArgs.flags["--tag"];
  const srcimg = parsedArgs.flags["--srcimg"];
  telemetry2.trackCliFlagYes(yes);
  telemetry2.trackCliOptionTag(tag);
  telemetry2.trackCliOptionSrcimg(srcimg);
  if (tag && srcimg) {
    output_manager_default.error(`Cannot use both --tag and --srcimg options`);
    return 1;
  }
  let itemName = "";
  let itemValue = "";
  let flag = "";
  let postUrl = "";
  let postBody = {};
  if (tag) {
    itemName = (0, import_pluralize2.default)("tag", tag.split(",").length, false);
    itemValue = tag;
    flag = "--tag";
    postUrl = "/v1/edge-cache/invalidate-by-tags";
    postBody = { tags: tag };
  } else if (srcimg) {
    itemName = "source image";
    itemValue = srcimg;
    flag = "--srcimg";
    postUrl = "/v1/edge-cache/invalidate-by-src-images";
    postBody = { srcImages: [srcimg] };
  } else {
    output_manager_default.error(`The --tag or --srcimg option is required`);
    return 1;
  }
  const msg = `You are about to invalidate all cached content associated with ${itemName} ${itemValue} for project ${project.name}`;
  if (!yes) {
    if (!process.stdin.isTTY) {
      output_manager_default.print(
        `${msg}. To continue, run ${getCommandName(`cache invalidate ${flag} ${itemValue} --yes`)}.`
      );
      return 1;
    }
    const confirmed = await client.input.confirm(`${msg}. Continue?`, true);
    if (!confirmed) {
      output_manager_default.print(`Canceled.
`);
      return 0;
    }
  }
  await client.fetch(`${postUrl}?projectIdOrName=${project.id}`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(postBody)
  });
  output_manager_default.print(
    prependEmoji(
      `Successfully invalidated all cached content associated with ${itemName} ${itemValue}`,
      emoji("success")
    ) + `
`
  );
  return 0;
}

// src/util/telemetry/commands/cache/dangerously-delete.ts
var CacheDangerouslyDeleteTelemetryClient = class extends TelemetryClient {
  trackCliFlagYes(yes) {
    if (yes) {
      this.trackCliFlag("yes");
    }
  }
  trackCliOptionTag(tag) {
    if (tag) {
      this.trackCliOption({
        option: "tag",
        value: tag
      });
    }
  }
  trackCliOptionSrcimg(srcimg) {
    if (srcimg) {
      this.trackCliOption({
        option: "srcimg",
        value: srcimg
      });
    }
  }
  trackCliOptionRevalidationDeadlineSeconds(seconds) {
    if (seconds) {
      this.trackCliOption({
        option: "revalidation-deadline-seconds",
        value: seconds?.toString()
      });
    }
  }
};

// src/commands/cache/dangerously-delete.ts
var import_pluralize3 = __toESM(require_pluralize(), 1);
async function dangerouslyDelete(client, argv) {
  const telemetry2 = new CacheDangerouslyDeleteTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(
    dangerouslyDeleteSubcommand.options
  );
  try {
    parsedArgs = parseArguments(argv, flagsSpecification);
  } catch (err) {
    printError(err);
    return 1;
  }
  const link = await getLinkedProject(client);
  if (link.status === "not_linked") {
    output_manager_default.error(
      "No project linked. Run `vercel link` to link a project to this directory."
    );
    return 1;
  }
  if (link.status === "error") {
    return link.exitCode;
  }
  const { project, org } = link;
  client.config.currentTeam = org.type === "team" ? org.id : void 0;
  const yes = Boolean(parsedArgs.flags["--yes"]);
  const tag = parsedArgs.flags["--tag"];
  const srcimg = parsedArgs.flags["--srcimg"];
  const revalidate = parsedArgs.flags["--revalidation-deadline-seconds"];
  telemetry2.trackCliFlagYes(yes);
  telemetry2.trackCliOptionTag(tag);
  telemetry2.trackCliOptionSrcimg(srcimg);
  telemetry2.trackCliOptionRevalidationDeadlineSeconds(revalidate);
  if (tag && srcimg) {
    output_manager_default.error(`Cannot use both --tag and --srcimg options`);
    return 1;
  }
  let itemName = "";
  let itemValue = "";
  let flag = "";
  let postUrl = "";
  let postBody = {};
  if (tag) {
    itemName = (0, import_pluralize3.default)("tag", tag.split(",").length, false);
    itemValue = tag;
    flag = "--tag";
    postUrl = "/v1/edge-cache/dangerously-delete-by-tags";
    postBody = { tags: tag, revalidationDeadlineSeconds: revalidate };
  } else if (srcimg) {
    itemName = "source image";
    itemValue = srcimg;
    flag = "--srcimg";
    postUrl = "/v1/edge-cache/dangerously-delete-by-src-images";
    postBody = { srcImages: [srcimg], revalidationDeadlineSeconds: revalidate };
  } else {
    output_manager_default.error(`The --tag or --srcimg option is required`);
    return 1;
  }
  const msg = `You are about to dangerously delete all cached content associated with ${itemName} ${itemValue} for project ${project.name}`;
  if (!yes) {
    if (!process.stdin.isTTY) {
      const optional = typeof revalidate !== "undefined" ? ` --revalidation-deadline-seconds ${revalidate}` : "";
      output_manager_default.print(
        `${msg}. To continue, run ${getCommandName(`cache dangerously-delete ${flag} ${itemValue}${optional} --yes`)}.`
      );
      return 1;
    }
    const confirmed = await client.input.confirm(`${msg}. Continue?`, true);
    if (!confirmed) {
      output_manager_default.print(`Canceled.
`);
      return 0;
    }
  }
  await client.fetch(`${postUrl}?projectIdOrName=${project.id}`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(postBody)
  });
  output_manager_default.print(
    prependEmoji(
      `Successfully deleted all cached content associated with ${itemName} ${itemValue}`,
      emoji("success")
    ) + `
`
  );
  return 0;
}

// src/util/telemetry/commands/cache/index.ts
var CacheTelemetryClient = class extends TelemetryClient {
  trackCliSubcommandPurge(actual) {
    this.trackCliSubcommand({
      subcommand: "purge",
      value: actual
    });
  }
  trackCliSubcommandInvalidate(actual) {
    this.trackCliSubcommand({
      subcommand: "invalidate",
      value: actual
    });
  }
  trackCliSubcommandDangerouslyDelete(actual) {
    this.trackCliSubcommand({
      subcommand: "dangerously-delete",
      value: actual
    });
  }
};

// src/commands/cache/index.ts
var COMMAND_CONFIG4 = {
  purge: getCommandAliases(purgeSubcommand),
  invalidate: getCommandAliases(invalidateSubcommand),
  "dangerously-delete": getCommandAliases(dangerouslyDeleteSubcommand)
};
async function main3(client) {
  const telemetry2 = new CacheTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(cacheCommand.options);
  try {
    parsedArgs = parseArguments(client.argv.slice(2), flagsSpecification, {
      permissive: true
    });
  } catch (err) {
    printError(err);
    return 1;
  }
  const subArgs = parsedArgs.args.slice(1);
  const { subcommand, args, subcommandOriginal } = getSubcommand3(
    subArgs,
    COMMAND_CONFIG4
  );
  const needHelp = parsedArgs.flags["--help"];
  if (!subcommand && needHelp) {
    telemetry2.trackCliFlagHelp(cacheCommand.name);
    output_manager_default.print(help(cacheCommand, { columns: client.stderr.columns }));
    return 0;
  }
  function printHelp(command) {
    telemetry2.trackCliFlagHelp(command.name, subcommandOriginal);
    output_manager_default.print(
      help(command, { parent: cacheCommand, columns: client.stderr.columns })
    );
  }
  switch (subcommand) {
    case "purge":
      if (needHelp) {
        printHelp(purgeSubcommand);
        return 2;
      }
      telemetry2.trackCliSubcommandPurge(subcommandOriginal);
      return purge(client, args);
    case "invalidate":
      if (needHelp) {
        printHelp(invalidateSubcommand);
        return 2;
      }
      telemetry2.trackCliSubcommandInvalidate(subcommandOriginal);
      return invalidate(client, args);
    case "dangerously-delete":
      if (needHelp) {
        printHelp(dangerouslyDeleteSubcommand);
        return 2;
      }
      telemetry2.trackCliSubcommandDangerouslyDelete(subcommandOriginal);
      return dangerouslyDelete(client, args);
    default:
      output_manager_default.error(getInvalidSubcommand(COMMAND_CONFIG4));
      output_manager_default.print(help(cacheCommand, { columns: client.stderr.columns }));
      return 2;
  }
}

// src/commands/contract/index.ts
var import_chalk16 = __toESM(require_source(), 1);

// src/util/telemetry/commands/contract/index.ts
var ContractTelemetryClient = class extends TelemetryClient {
  trackCliFlagJson(json) {
    if (json) {
      this.trackCliFlag("json");
    }
  }
};

// src/commands/contract/index.ts
var import_error_utils2 = __toESM(require_dist(), 1);

// src/util/billing/format.ts
function formatCurrency(amount) {
  return `$${amount.toFixed(4)}`;
}
function formatQuantity(quantity, unit) {
  if (unit === "USD") {
    return `$${quantity.toFixed(4)}`;
  }
  return quantity.toFixed(4);
}
function extractDatePortion(isoString) {
  return isoString.slice(0, 10);
}

// src/commands/contract/index.ts
async function contract(client) {
  const { print, log, error, spinner } = output_manager_default;
  const flagsSpecification = getFlagsSpecification(contractCommand.options);
  let parsedArgs;
  try {
    parsedArgs = parseArguments(client.argv.slice(2), flagsSpecification);
  } catch (err) {
    printError(err);
    return 1;
  }
  const telemetry2 = new ContractTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  if (parsedArgs.flags["--help"]) {
    telemetry2.trackCliFlagHelp("contract");
    print(help(contractCommand, { columns: client.stderr.columns }));
    return 0;
  }
  const formatResult = validateJsonOutput(parsedArgs.flags);
  if (!formatResult.valid) {
    error(formatResult.error);
    return 1;
  }
  const asJson = formatResult.jsonOutput;
  telemetry2.trackCliOptionFormat(parsedArgs.flags["--format"]);
  let contextName;
  let teamId;
  try {
    const scope = await getScope(client);
    contextName = scope.contextName;
    teamId = scope.team?.id;
  } catch (err) {
    if ((0, import_error_utils2.isErrnoException)(err) && (err.code === "NOT_AUTHORIZED" || err.code === "TEAM_DELETED")) {
      error(err.message);
      return 1;
    }
    throw err;
  }
  const start = Date.now();
  if (!asJson) {
    spinner(`Fetching contract commitments for ${import_chalk16.default.bold(contextName)}`);
  }
  const query = new URLSearchParams();
  if (teamId) {
    query.set("teamId", teamId);
  }
  try {
    const response = await client.fetch(
      `/v1/billing/contract-commitments?${query}`,
      {
        json: false,
        useCurrentTeam: false
      }
    );
    if (!response.ok) {
      const errorText = await response.text();
      error(
        `Failed to fetch contract commitments: ${response.status} ${errorText}`
      );
      return 1;
    }
    const text = await response.text();
    const data = text ? JSON.parse(text) : null;
    const commitments = Array.isArray(data) ? data : [];
    if (asJson) {
      const jsonOutput = {
        context: contextName,
        commitments: commitments.map((c) => ({
          contractId: c.ContractId,
          contractPeriodStart: c.ContractPeriodStart,
          contractPeriodEnd: c.ContractPeriodEnd,
          commitmentId: c.ContractCommitmentId,
          commitmentType: c.ContractCommitmentType,
          commitmentCategory: c.ContractCommitmentCategory,
          commitmentPeriodStart: c.ContractCommitmentPeriodStart,
          commitmentPeriodEnd: c.ContractCommitmentPeriodEnd,
          commitmentCost: c.ContractCommitmentCost,
          commitmentQuantity: c.ContractCommitmentQuantity,
          commitmentUnit: c.ContractCommitmentUnit,
          billingCurrency: c.BillingCurrency,
          description: c.ContractCommitmentDescription
        })),
        totalCommitments: commitments.length
      };
      client.stdout.write(`${JSON.stringify(jsonOutput, null, 2)}
`);
      return 0;
    }
    log(
      `Contract commitments for ${import_chalk16.default.bold(contextName)} ${elapsed(Date.now() - start)}`
    );
    log("");
    if (commitments.length === 0) {
      log("No contract commitments found.");
      return 0;
    }
    const contractGroups = /* @__PURE__ */ new Map();
    for (const commitment of commitments) {
      const existing = contractGroups.get(commitment.ContractId) || [];
      existing.push(commitment);
      contractGroups.set(commitment.ContractId, existing);
    }
    for (const [contractId, contractCommitments] of contractGroups) {
      const firstCommitment = contractCommitments[0];
      log(import_chalk16.default.bold(`Contract: ${contractId}`));
      log(
        `${import_chalk16.default.gray("Period:")} ${extractDatePortion(firstCommitment.ContractPeriodStart)} to ${extractDatePortion(firstCommitment.ContractPeriodEnd)}`
      );
      log("");
      const headers = [
        "Type",
        "Category",
        "Period",
        "Commitment",
        "Description"
      ];
      const rows = contractCommitments.map((c) => {
        const periodStr = `${extractDatePortion(c.ContractCommitmentPeriodStart)} - ${extractDatePortion(c.ContractCommitmentPeriodEnd)}`;
        let commitmentValue;
        if (c.ContractCommitmentCategory === "Spend" && c.ContractCommitmentCost !== void 0) {
          commitmentValue = formatCurrency(c.ContractCommitmentCost);
        } else if (c.ContractCommitmentCategory === "Usage" && c.ContractCommitmentQuantity !== void 0) {
          commitmentValue = formatQuantity(
            c.ContractCommitmentQuantity,
            c.ContractCommitmentUnit
          );
        } else {
          commitmentValue = "-";
        }
        return [
          c.ContractCommitmentType,
          c.ContractCommitmentCategory,
          periodStr,
          commitmentValue,
          c.ContractCommitmentDescription || "-"
        ];
      });
      const tablePrint = table(
        [headers.map((h) => import_chalk16.default.bold(import_chalk16.default.cyan(h))), ...rows],
        { hsep: 3, align: ["l", "l", "l", "r", "l"] }
      ).replace(/^/gm, "  ");
      print(`${tablePrint}

`);
    }
    log(`${import_chalk16.default.gray("Total commitments:")} ${commitments.length}`);
    return 0;
  } catch (err) {
    output_manager_default.prettyError(err);
    return 1;
  }
}

// src/commands/certs/add.ts
var import_chalk17 = __toESM(require_source(), 1);

// src/util/certs/create-cert-from-file.ts
var import_error_utils3 = __toESM(require_dist(), 1);
import { readFileSync } from "fs";
import { resolve as resolve4 } from "path";
async function createCertFromFile(client, keyPath, certPath, caPath) {
  output_manager_default.spinner("Adding your custom certificate");
  try {
    const cert = readFileSync(resolve4(certPath), "utf8");
    const key = readFileSync(resolve4(keyPath), "utf8");
    const ca = readFileSync(resolve4(caPath), "utf8");
    const certificate = await client.fetch("/v3/certs", {
      method: "PUT",
      body: {
        ca,
        cert,
        key
      }
    });
    return certificate;
  } catch (err) {
    if ((0, import_error_utils3.isErrnoException)(err) && err.code === "ENOENT") {
      return new Error(`The specified file "${err.path}" doesn't exist.`);
    }
    if (isAPIError(err) && err.status < 500) {
      return err;
    }
    throw err;
  }
}

// src/util/telemetry/commands/certs/add.ts
var CertsAddTelemetryClient = class extends TelemetryClient {
  trackCliFlagOverwrite(v) {
    if (v) {
      this.trackCliFlag("overwrite");
    }
  }
  trackCliOptionCrt(v) {
    if (v) {
      this.trackCliOption({
        option: "crt",
        value: this.redactedValue
      });
    }
  }
  trackCliOptionKey(v) {
    if (v) {
      this.trackCliOption({
        option: "key",
        value: this.redactedValue
      });
    }
  }
  trackCliOptionCa(v) {
    if (v) {
      this.trackCliOption({
        option: "ca",
        value: this.redactedValue
      });
    }
  }
};

// src/commands/certs/add.ts
async function add(client, argv) {
  const { telemetryEventStore } = client;
  const addStamp = stamp_default();
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(addSubcommand.options);
  try {
    parsedArgs = parseArguments(argv, flagsSpecification);
  } catch (err) {
    printError(err);
    return 1;
  }
  const { args, flags: opts } = parsedArgs;
  let cert;
  const {
    "--overwrite": overwrite,
    "--crt": crtPath,
    "--key": keyPath,
    "--ca": caPath
  } = opts;
  const telemetry2 = new CertsAddTelemetryClient({
    opts: {
      store: telemetryEventStore
    }
  });
  telemetry2.trackCliFlagOverwrite(overwrite);
  telemetry2.trackCliOptionCrt(crtPath);
  telemetry2.trackCliOptionKey(keyPath);
  telemetry2.trackCliOptionCa(caPath);
  if (overwrite) {
    output_manager_default.error("Overwrite option is deprecated");
    return 1;
  }
  if (crtPath || keyPath || caPath) {
    if (args.length !== 0 || !crtPath || !keyPath || !caPath) {
      output_manager_default.error(
        `Invalid number of arguments to create a custom certificate entry. Usage:`
      );
      output_manager_default.print(
        `  ${import_chalk17.default.cyan(
          `${getCommandName(
            "certs add --crt <domain.crt> --key <domain.key> --ca <ca.crt>"
          )}`
        )}
`
      );
      return 1;
    }
    cert = await createCertFromFile(client, keyPath, crtPath, caPath);
  } else {
    output_manager_default.warn(
      `${import_chalk17.default.cyan(
        getCommandName("certs add")
      )} will be soon deprecated. Please use ${import_chalk17.default.cyan(
        getCommandName("certs issue <cn> <cns>")
      )} instead`
    );
    if (args.length < 1) {
      output_manager_default.error(
        `Invalid number of arguments to create a custom certificate entry. Usage:`
      );
      output_manager_default.print(
        `  ${import_chalk17.default.cyan(getCommandName("certs add <cn>[, <cn>]"))}
`
      );
      return 1;
    }
    const cns = args.reduce(
      (res, item) => res.concat(item.split(",")),
      []
    );
    output_manager_default.spinner(
      `Generating a certificate for ${import_chalk17.default.bold(cns.join(", "))}`
    );
    const { contextName } = await getScope(client);
    cert = await createCertForCns(client, cns, contextName);
    output_manager_default.stopSpinner();
  }
  if (cert instanceof Error) {
    output_manager_default.error(cert.message);
    return 1;
  } else {
    output_manager_default.success(
      `Certificate entry for ${import_chalk17.default.bold(
        cert.cns.join(", ")
      )} created ${addStamp()}`
    );
  }
  return 0;
}
var add_default = add;

// src/commands/certs/issue.ts
var import_chalk20 = __toESM(require_source(), 1);
var import_tldts3 = __toESM(require_cjs(), 1);

// src/util/certs/finish-cert-order.ts
var import_chalk18 = __toESM(require_source(), 1);
async function startCertOrder(client, cns, context) {
  output_manager_default.spinner(`Issuing a certificate for ${import_chalk18.default.bold(cns.join(", "))}`);
  try {
    const cert = await client.fetch("/v3/certs", {
      method: "PATCH",
      body: {
        op: "finalizeOrder",
        domains: cns
      }
    });
    return cert;
  } catch (err) {
    if (isAPIError(err)) {
      if (err.code === "cert_order_not_found") {
        return new CertOrderNotFound(cns);
      }
      const mappedError = mapCertError(err, cns);
      if (mappedError) {
        return mappedError;
      }
    }
    throw err;
  }
}

// src/util/certs/get-cns-from-args.ts
function getCnsFromArgs(args) {
  return args.reduce((res, item) => [...res, ...item.split(",")], []).filter((i) => i);
}

// src/util/certs/start-cert-order.ts
var import_chalk19 = __toESM(require_source(), 1);
async function startCertOrder2(client, cns, contextName) {
  output_manager_default.spinner(
    `Starting certificate issuance for ${import_chalk19.default.bold(
      cns.join(", ")
    )} under ${import_chalk19.default.bold(contextName)}`
  );
  const order = await client.fetch("/v3/certs", {
    method: "PATCH",
    body: {
      op: "startOrder",
      domains: cns
    }
  });
  return order;
}

// src/util/telemetry/commands/certs/issue.ts
var CertsIssueTelemetryClient = class extends CertsAddTelemetryClient {
  trackCliArgumentCn(value) {
    if (value) {
      this.trackCliArgument({
        arg: "cn",
        value: this.redactedValue
      });
    }
  }
  trackCliFlagChallengeOnly(v) {
    if (v) {
      this.trackCliFlag("challenge-only");
    }
  }
};

// src/commands/certs/issue.ts
async function issue(client, argv) {
  let cert;
  const { telemetryEventStore } = client;
  const addStamp = stamp_default();
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(issueSubcommand.options);
  try {
    parsedArgs = parseArguments(argv, flagsSpecification);
  } catch (err) {
    printError(err);
    return 1;
  }
  const { args, flags: opts } = parsedArgs;
  const {
    "--challenge-only": challengeOnly,
    "--overwrite": overwrite,
    "--crt": crtPath,
    "--key": keyPath,
    "--ca": caPath
  } = opts;
  const telemetry2 = new CertsIssueTelemetryClient({
    opts: {
      store: telemetryEventStore
    }
  });
  telemetry2.trackCliFlagChallengeOnly(challengeOnly);
  telemetry2.trackCliFlagOverwrite(overwrite);
  telemetry2.trackCliOptionCrt(crtPath);
  telemetry2.trackCliOptionKey(keyPath);
  telemetry2.trackCliOptionCa(caPath);
  if (overwrite) {
    output_manager_default.error("Overwrite option is deprecated");
    return 1;
  }
  if (crtPath || keyPath || caPath) {
    if (args.length !== 0 || !crtPath || !keyPath || !caPath) {
      output_manager_default.error(
        `Invalid number of arguments to create a custom certificate entry. Usage:`
      );
      output_manager_default.print(
        `  ${import_chalk20.default.cyan(
          getCommandName(
            "certs issue --crt <domain.crt> --key <domain.key> --ca <ca.crt>"
          )
        )}
`
      );
      return 1;
    }
    cert = await createCertFromFile(client, keyPath, crtPath, caPath);
    if (cert instanceof Error) {
      output_manager_default.error(cert.message);
      return 1;
    }
    output_manager_default.success(
      `Certificate entry for ${import_chalk20.default.bold(
        cert.cns.join(", ")
      )} created ${addStamp()}`
    );
    return 0;
  }
  if (args.length < 1) {
    output_manager_default.error(
      `Invalid number of arguments to create a custom certificate entry. Usage:`
    );
    output_manager_default.print(
      `  ${import_chalk20.default.cyan(getCommandName("certs issue <cn>[, <cn>]"))}
`
    );
    return 1;
  }
  telemetry2.trackCliArgumentCn(args[0]);
  const cns = getCnsFromArgs(args);
  const { contextName } = await getScope(client);
  if (challengeOnly) {
    return runStartOrder(client, cns, contextName, addStamp);
  }
  cert = await startCertOrder(client, cns, contextName);
  if (cert instanceof CertOrderNotFound) {
    cert = await createCertForCns(client, cns, contextName);
  }
  if (cert instanceof CertError) {
    if (cert.meta.code === "wildcard_not_allowed") {
      return runStartOrder(client, cns, contextName, addStamp, {
        fallingBack: true
      });
    }
  }
  const handledResult = handleCertError(cert);
  if (handledResult === 1) {
    return handledResult;
  }
  if (handledResult instanceof DomainPermissionDenied) {
    output_manager_default.error(
      `You do not have permissions over domain ${import_chalk20.default.underline(
        handledResult.meta.domain
      )} under ${import_chalk20.default.bold(handledResult.meta.context)}.`
    );
    return 1;
  }
  output_manager_default.success(
    `Certificate entry for ${import_chalk20.default.bold(
      handledResult.cns.join(", ")
    )} created ${addStamp()}`
  );
  return 0;
}
async function runStartOrder(client, cns, contextName, stamp, { fallingBack = false } = {}) {
  const { challengesToResolve } = await startCertOrder2(
    client,
    cns,
    contextName
  );
  const pendingChallenges = challengesToResolve.filter(
    (challenge) => challenge.status === "pending"
  );
  if (fallingBack) {
    output_manager_default.warn(
      `To generate a wildcard certificate for domain for an external domain you must solve challenges manually.`
    );
  }
  if (pendingChallenges.length === 0) {
    output_manager_default.log(
      `A certificate issuance for ${import_chalk20.default.bold(
        cns.join(", ")
      )} has been started ${stamp()}`
    );
    output_manager_default.print(
      `  There are no pending challenges. Finish the issuance by running: 
`
    );
    output_manager_default.print(
      `  ${import_chalk20.default.cyan(getCommandName(`certs issue ${cns.join(" ")}`))}
`
    );
    return 0;
  }
  output_manager_default.log(
    `A certificate issuance for ${import_chalk20.default.bold(
      cns.join(", ")
    )} has been started ${stamp()}`
  );
  output_manager_default.print(
    `  Add the following TXT records with your registrar to be able to the solve the DNS challenge:

`
  );
  const [header, ...rows] = formatDNSTable(
    pendingChallenges.map((challenge) => {
      const subdomain = (0, import_tldts3.getSubdomain)(challenge.domain);
      if (subdomain === null) {
        throw new InvalidDomain(challenge.domain);
      }
      return [
        subdomain ? `_acme-challenge.${subdomain}` : `_acme-challenge`,
        "TXT",
        challenge.value
      ];
    })
  ).split("\n");
  output_manager_default.print(`${header}
`);
  client.stdout.write(`${rows.join("\n")}

`);
  output_manager_default.log(`To issue the certificate once the records are added, run:`);
  output_manager_default.print(
    `  ${import_chalk20.default.cyan(getCommandName(`certs issue ${cns.join(" ")}`))}
`
  );
  output_manager_default.print(
    "  Read more: https://err.sh/vercel/solve-challenges-manually\n"
  );
  return 0;
}

// src/commands/certs/ls.ts
var import_chalk21 = __toESM(require_source(), 1);
var import_ms6 = __toESM(require_ms(), 1);

// src/util/certs/get-certs.ts
async function getCerts(client, next, limit = 20) {
  let certsUrl = `/v4/certs?limit=${limit}`;
  if (next) {
    certsUrl += `&until=${next}`;
  }
  return await client.fetch(certsUrl);
}

// src/util/telemetry/commands/certs/ls.ts
var CertsLsTelemetryClient = class extends TelemetryClient {
  trackCliOptionLimit(limit) {
    if (limit) {
      this.trackCliOption({
        option: "limit",
        value: this.redactedValue
      });
    }
  }
  trackCliOptionNext(next) {
    if (next) {
      this.trackCliOption({
        option: "next",
        value: this.redactedValue
      });
    }
  }
};

// src/commands/certs/ls.ts
async function ls2(client, argv) {
  const { telemetryEventStore } = client;
  const telemetry2 = new CertsLsTelemetryClient({
    opts: {
      store: telemetryEventStore
    }
  });
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(listSubcommand3.options);
  try {
    parsedArgs = parseArguments(argv, flagsSpecification);
  } catch (err) {
    printError(err);
    return 1;
  }
  const { args, flags: opts } = parsedArgs;
  const validationResult = validateLsArgs({
    commandName: "certs ls",
    args
  });
  if (validationResult !== 0) {
    return validationResult;
  }
  telemetry2.trackCliOptionLimit(opts["--limit"]);
  telemetry2.trackCliOptionNext(opts["--next"]);
  let paginationOptions;
  try {
    paginationOptions = getPaginationOpts(opts);
  } catch (err) {
    output_manager_default.prettyError(err);
    return 1;
  }
  const lsStamp = stamp_default();
  const { certs, pagination } = await getCerts(client, ...paginationOptions);
  const { contextName } = await getScope(client);
  output_manager_default.log(
    `${certs.length > 0 ? "Certificates" : "No certificates"} found under ${import_chalk21.default.bold(contextName)} ${lsStamp()}`
  );
  if (certs.length > 0) {
    client.stdout.write(formatCertsTable(certs));
  }
  if (pagination && pagination.count === 20) {
    const flags = getCommandFlags(opts, ["_", "--next"]);
    output_manager_default.log(
      `To display the next page run ${getCommandName(
        `certs ls${flags} --next ${pagination.next}`
      )}`
    );
  }
  return 0;
}
function formatCertsTable(certsList) {
  return `${table(
    [formatCertsTableHead(), ...formatCertsTableBody(certsList)],
    { align: ["l", "l", "r", "c", "r"], hsep: 2 }
  ).replace(/^(.*)/gm, "  $1")}
`;
}
function formatCertsTableHead() {
  return [
    import_chalk21.default.dim("id"),
    import_chalk21.default.dim("cns"),
    import_chalk21.default.dim("expiration"),
    import_chalk21.default.dim("renew"),
    import_chalk21.default.dim("age")
  ];
}
function formatCertsTableBody(certsList) {
  const now = /* @__PURE__ */ new Date();
  return certsList.reduce(
    (result, cert) => result.concat(formatCert(now, cert)),
    []
  );
}
function formatCert(time, cert) {
  return cert.cns.map(
    (cn, idx) => idx === 0 ? formatCertFirstCn(time, cert, cn, cert.cns.length > 1) : formatCertNonFirstCn(cn, cert.cns.length > 1)
  );
}
function formatCertNonFirstCn(cn, multiple) {
  return ["", formatCertCn(cn, multiple), "", "", ""];
}
function formatCertCn(cn, multiple) {
  return multiple ? `${import_chalk21.default.gray("-")} ${import_chalk21.default.bold(cn)}` : import_chalk21.default.bold(cn);
}
function formatCertFirstCn(time, cert, cn, multiple) {
  return [
    cert.uid,
    formatCertCn(cn, multiple),
    formatExpirationDate(new Date(cert.expiration)),
    cert.autoRenew ? "yes" : "no",
    import_chalk21.default.gray((0, import_ms6.default)(time.getTime() - new Date(cert.created).getTime()))
  ];
}
function formatExpirationDate(date) {
  const diff = date.getTime() - Date.now();
  return diff < 0 ? import_chalk21.default.gray(`${(0, import_ms6.default)(-diff)} ago`) : import_chalk21.default.gray(`in ${(0, import_ms6.default)(diff)}`);
}
var ls_default = ls2;

// src/commands/certs/rm.ts
var import_chalk22 = __toESM(require_source(), 1);
var import_ms7 = __toESM(require_ms(), 1);
var import_pluralize4 = __toESM(require_pluralize(), 1);

// src/util/certs/delete-cert-by-id.ts
async function deleteCertById(client, id) {
  return client.fetch(`/v5/certs/${id}`, {
    method: "DELETE"
  });
}

// src/util/certs/get-cert-by-id.ts
async function getCertById(client, id) {
  try {
    return await client.fetch(`/v6/certs/${id}`);
  } catch (err) {
    if (isAPIError(err) && err.code === "cert_not_found") {
      return new CertNotFound(id);
    }
    throw err;
  }
}

// src/util/certs/get-custom-certs-for-domain.ts
import { stringify } from "querystring";
async function getCustomCertsForDomain(client, context, domain) {
  try {
    const { certs } = await client.fetch(
      `/v5/now/certs?${stringify({ domain, custom: true })}`
    );
    return certs;
  } catch (err) {
    if (isAPIError(err) && err.code === "forbidden") {
      return new CertsPermissionDenied(context, domain);
    }
    throw err;
  }
}

// src/util/telemetry/commands/certs/remove.ts
var CertsRemoveTelemetryClient = class extends TelemetryClient {
  trackCliArgumentId(v) {
    if (v) {
      this.trackCliArgument({
        arg: "id",
        value: this.redactedValue
      });
    }
  }
};

// src/commands/certs/rm.ts
async function rm2(client, argv) {
  const rmStamp = stamp_default();
  const { telemetryEventStore } = client;
  const telemetry2 = new CertsRemoveTelemetryClient({
    opts: {
      store: telemetryEventStore
    }
  });
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(removeSubcommand2.options);
  try {
    parsedArgs = parseArguments(argv, flagsSpecification);
  } catch (err) {
    printError(err);
    return 1;
  }
  const { args } = parsedArgs;
  const id = args[0];
  telemetry2.trackCliArgumentId(id);
  if (args.length !== 1) {
    output_manager_default.error(
      `Invalid number of arguments. Usage: ${import_chalk22.default.cyan(
        `${getCommandName("certs rm <id or cn>")}`
      )}`
    );
    return 1;
  }
  const { contextName } = await getScope(client);
  const certs = await getCertsToDelete(client, contextName, id);
  if (certs instanceof CertsPermissionDenied) {
    output_manager_default.error(
      `You don't have access to ${param(id)}'s certs under ${contextName}.`
    );
    return 1;
  }
  if (certs.length === 0) {
    if (id.includes(".")) {
      output_manager_default.error(
        `No custom certificates found for "${id}" under ${import_chalk22.default.bold(
          contextName
        )}`
      );
    } else {
      output_manager_default.error(
        `No certificates found by id "${id}" under ${import_chalk22.default.bold(contextName)}`
      );
    }
    return 1;
  }
  const yes = await readConfirmation(
    client,
    "The following certificates will be removed permanently",
    certs
  );
  if (!yes) {
    return 0;
  }
  await Promise.all(certs.map((cert) => deleteCertById(client, cert.uid)));
  output_manager_default.success(
    `${import_chalk22.default.bold(
      (0, import_pluralize4.default)("Certificate", certs.length, true)
    )} removed ${rmStamp()}`
  );
  return 0;
}
async function getCertsToDelete(client, contextName, id) {
  const cert = await getCertById(client, id);
  if (cert instanceof CertNotFound) {
    const certs = await getCustomCertsForDomain(client, contextName, id);
    if (certs instanceof CertsPermissionDenied) {
      return certs;
    }
    return certs;
  }
  return [cert];
}
function readConfirmation(client, msg, certs) {
  return new Promise((resolve6) => {
    output_manager_default.log(msg);
    output_manager_default.print(
      `${table(certs.map(formatCertRow), {
        align: ["l", "r", "l"],
        hsep: 6
      }).replace(/^(.*)/gm, "  $1")}
`
    );
    output_manager_default.print(
      `${import_chalk22.default.bold.red("> Are you sure?")} ${import_chalk22.default.gray("(y/N) ")}`
    );
    client.stdin.on("data", (d) => {
      process.stdin.pause();
      resolve6(d.toString().trim().toLowerCase() === "y");
    }).resume();
  });
}
function formatCertRow(cert) {
  return [
    cert.uid,
    import_chalk22.default.bold(cert.cns ? cert.cns.join(", ") : "\u2013"),
    ...cert.created ? [import_chalk22.default.gray(`${(0, import_ms7.default)(Date.now() - new Date(cert.created).getTime())} ago`)] : []
  ];
}
var rm_default = rm2;

// src/util/telemetry/commands/certs/index.ts
var CertsTelemetryClient = class extends TelemetryClient {
  trackCliSubcommandIssue(actual) {
    this.trackCliSubcommand({
      subcommand: "issue",
      value: actual
    });
  }
  trackCliSubcommandAdd(actual) {
    this.trackCliSubcommand({
      subcommand: "add",
      value: actual
    });
  }
  trackCliSubcommandRemove(actual) {
    this.trackCliSubcommand({
      subcommand: "remove",
      value: actual
    });
  }
  trackCliSubcommandList(actual) {
    this.trackCliSubcommand({
      subcommand: "list",
      value: actual
    });
  }
};

// src/commands/certs/index.ts
var COMMAND_CONFIG5 = {
  add: getCommandAliases(addSubcommand),
  issue: getCommandAliases(issueSubcommand),
  ls: getCommandAliases(listSubcommand3),
  rm: getCommandAliases(removeSubcommand2)
};
async function main4(client) {
  const { telemetryEventStore } = client;
  const telemetry2 = new CertsTelemetryClient({
    opts: {
      store: telemetryEventStore
    }
  });
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(certsCommand.options);
  try {
    parsedArgs = parseArguments(client.argv.slice(2), flagsSpecification, {
      permissive: true
    });
  } catch (err) {
    printError(err);
    return 1;
  }
  const { subcommand, subcommandOriginal, args } = getSubcommand3(
    parsedArgs.args.slice(1),
    COMMAND_CONFIG5
  );
  const needHelp = parsedArgs.flags["--help"];
  if (!subcommand && needHelp) {
    telemetry2.trackCliFlagHelp("certs", subcommand);
    output_manager_default.print(help(certsCommand, { columns: client.stderr.columns }));
    return 2;
  }
  function printHelp(command) {
    output_manager_default.print(
      help(command, { parent: certsCommand, columns: client.stderr.columns })
    );
  }
  switch (subcommand) {
    case "issue":
      if (needHelp) {
        telemetry2.trackCliFlagHelp("certs", subcommandOriginal);
        printHelp(issueSubcommand);
        return 2;
      }
      telemetry2.trackCliSubcommandIssue(subcommandOriginal);
      return issue(client, args);
    case "ls":
      if (needHelp) {
        telemetry2.trackCliFlagHelp("certs", subcommandOriginal);
        printHelp(listSubcommand3);
        return 2;
      }
      telemetry2.trackCliSubcommandList(subcommandOriginal);
      return ls_default(client, args);
    case "rm":
      if (needHelp) {
        telemetry2.trackCliFlagHelp("certs", subcommandOriginal);
        printHelp(removeSubcommand2);
        return 2;
      }
      telemetry2.trackCliSubcommandRemove(subcommandOriginal);
      return rm_default(client, args);
    case "add":
      if (needHelp) {
        telemetry2.trackCliFlagHelp("certs", subcommandOriginal);
        printHelp(addSubcommand);
        return 2;
      }
      telemetry2.trackCliSubcommandAdd(subcommandOriginal);
      return add_default(client, args);
    default:
      output_manager_default.error("Please specify a valid subcommand: ls | issue | rm");
      output_manager_default.print(help(certsCommand, { columns: client.stderr.columns }));
      return 2;
  }
}

// src/commands/curl/index.ts
import { spawn } from "child_process";

// src/commands/curl/utils.ts
var requoteArgs = (arg) => {
  if (arg.includes(" ")) {
    if (arg.includes('"')) {
      return `'${arg}'`;
    } else {
      return `"${arg}"`;
    }
  }
  return arg;
};

// src/util/telemetry/commands/curl/index.ts
var CurlTelemetryClient = class extends TelemetryClient {
  trackCliArgumentPath(path3) {
    if (path3) {
      const value = path3.startsWith("/") ? "slash" : "no-slash";
      this.trackCliArgument({
        arg: "path",
        value
      });
    }
  }
  trackCliOptionDeployment(deploymentId) {
    if (deploymentId) {
      const value = deploymentId.startsWith("http://") || deploymentId.startsWith("https://") ? "url" : deploymentId.startsWith("dpl_") ? "dpl_" : "no-prefix";
      this.trackCliOption({
        option: "deployment",
        value
      });
    }
  }
  trackCliOptionProtectionBypass(secret) {
    if (secret) {
      this.trackCliOption({
        option: "protection-bypass",
        value: this.redactedValue
      });
    }
  }
  trackCliFlagYes(yes) {
    if (yes) {
      this.trackCliFlag("yes");
    }
  }
};

// src/commands/curl/shared.ts
var import_chalk24 = __toESM(require_source(), 1);
var import_error_utils4 = __toESM(require_dist(), 1);

// src/commands/curl/bypass-token.ts
var import_chalk23 = __toESM(require_source(), 1);
async function createDeploymentProtectionToken(client, projectId, orgId) {
  if (!client.authConfig.token) {
    output_manager_default.debug(
      "No auth token available, skipping deployment protection token"
    );
    throw new Error(
      "Authentication required to create protection bypass token"
    );
  }
  try {
    const response = await client.fetch(`/v1/projects/${projectId}/protection-bypass`, {
      method: "PATCH",
      body: "{}",
      headers: {
        "Content-Type": "application/json"
      },
      accountId: orgId
    });
    const { protectionBypass } = response;
    output_manager_default.log(
      `You require a deployment protection bypass token to access this deployment... Generating one now...`
    );
    output_manager_default.log(
      `Successfully generated deployment protection bypass token for project ${import_chalk23.default.bold(projectId)}
`
    );
    output_manager_default.debug(`Protection Bypass Response: ${protectionBypass}`);
    await sleep(1e3);
    return getAutomationBypassToken(protectionBypass);
  } catch (error) {
    output_manager_default.debug(
      `Failed to generate deployment protection bypass token: ${error}`
    );
    output_manager_default.note(
      'To bypass deployment protection, create a "Protection Bypass for Automation" secret in your project settings:'
    );
    output_manager_default.log(`  1. Visit ${import_chalk23.default.cyan("https://vercel.com/dashboard")}`);
    output_manager_default.log(`  2. Go to your project settings \u2192 Deployment Protection`);
    output_manager_default.log(`  3. Generate a "Protection Bypass for Automation" secret`);
    output_manager_default.log(
      `  4. Use it with ${import_chalk23.default.cyan(
        "--protection-bypass"
      )} flag or set ${import_chalk23.default.cyan("VERCEL_AUTOMATION_BYPASS_SECRET")} env var`
    );
    output_manager_default.log("");
    throw new Error("Failed to create deployment protection bypass token");
  }
}
function getAutomationBypassToken(protectionBypass) {
  if (!protectionBypass) {
    throw new Error("No protection bypass tokens found");
  }
  const token = Object.keys(protectionBypass).find(
    (key) => protectionBypass[key].scope === "automation-bypass"
  );
  if (!token) {
    throw new Error(
      "No automation bypass token found in protection bypass settings"
    );
  }
  return token;
}
async function getOrCreateDeploymentProtectionToken(client, { project, org }) {
  if (process.env.VERCEL_AUTOMATION_BYPASS_SECRET) {
    output_manager_default.debug("Using protection bypass secret from environment variable");
    return process.env.VERCEL_AUTOMATION_BYPASS_SECRET;
  }
  if (project.protectionBypass && Object.values(project.protectionBypass).length) {
    const protectionBypass = getAutomationBypassToken(project.protectionBypass);
    if (protectionBypass) {
      output_manager_default.debug(
        `Using existing protection bypass token from project settings: ${protectionBypass}`
      );
      return protectionBypass;
    }
  }
  const token = await createDeploymentProtectionToken(
    client,
    project.id,
    org.id
  );
  return token;
}

// src/commands/curl/deployment-url.ts
async function getDeploymentUrlById(client, deploymentIdOrUrl, accountId) {
  try {
    if (deploymentIdOrUrl.startsWith("http://") || deploymentIdOrUrl.startsWith("https://")) {
      try {
        const url = new URL(deploymentIdOrUrl);
        return url.origin;
      } catch (err) {
        output_manager_default.debug(`Invalid deployment URL provided: ${deploymentIdOrUrl}`);
        return null;
      }
    }
    if (deploymentIdOrUrl.includes("vercel.app")) {
      return `https://${deploymentIdOrUrl}`;
    }
    let fullDeploymentId = deploymentIdOrUrl;
    if (!fullDeploymentId.startsWith("dpl_")) {
      fullDeploymentId = `dpl_${deploymentIdOrUrl}`;
    }
    const deployment = await client.fetch(
      `/v13/deployments/${fullDeploymentId}`,
      { accountId }
    );
    if (!deployment || !deployment.url) {
      return null;
    }
    return `https://${deployment.url}`;
  } catch (error) {
    output_manager_default.debug(`Failed to fetch deployment by ID: ${error}`);
    return null;
  }
}

// src/commands/curl/shared.ts
function setupCurlLikeCommand(client, command, telemetryClient) {
  const { print } = output_manager_default;
  let parsedArgs = null;
  const flagsSpecification = getFlagsSpecification(command.options);
  try {
    parsedArgs = parseArguments(client.argv.slice(2), flagsSpecification);
  } catch (err) {
    printError(err);
    return 1;
  }
  const { flags } = parsedArgs;
  if (parsedArgs.flags["--help"]) {
    print(help(command, { columns: client.stderr.columns }));
    return 2;
  }
  if (parsedArgs.args[0] === command.name) {
    parsedArgs.args.shift();
  }
  const separatorIndex = process.argv.indexOf("--");
  const path3 = parsedArgs.args[0];
  telemetryClient.trackCliArgumentPath(path3);
  const deploymentFlag = flags["--deployment"];
  if (deploymentFlag) {
    telemetryClient.trackCliOptionDeployment(deploymentFlag);
  }
  const protectionBypassFlag = flags["--protection-bypass"];
  if (protectionBypassFlag) {
    telemetryClient.trackCliOptionProtectionBypass(protectionBypassFlag);
  }
  if (!path3 || path3 === "--" || path3.startsWith("-")) {
    output_manager_default.error(
      `${getCommandName(`${command.name} <path>`)} requires an API path (e.g., '/' or '/api/hello' or 'api/hello')`
    );
    print(help(command, { columns: client.stderr.columns }));
    return 1;
  }
  if (path3.startsWith("http://") || path3.startsWith("https://")) {
    output_manager_default.error(
      `The <path> argument must be a relative API path (e.g., '/' or '/api/hello'), not a full URL.`
    );
    output_manager_default.print(
      `To target a specific deployment within the currently linked project, use the --deployment <id|url> flag.`
    );
    print(help(command, { columns: client.stderr.columns }));
    return 1;
  }
  const toolFlags = separatorIndex !== -1 ? process.argv.slice(separatorIndex + 1) : [];
  output_manager_default.debug(
    `${command.name} flags (${toolFlags.length} args): ${JSON.stringify(toolFlags)}`
  );
  return {
    path: path3,
    deploymentFlag,
    protectionBypassFlag,
    toolFlags,
    yes: !!flags["--yes"]
  };
}
async function getDeploymentUrlAndToken(client, commandName, path3, options) {
  const { deploymentFlag, protectionBypassFlag, autoConfirm } = options;
  let link;
  let scope;
  try {
    scope = await getScope(client);
  } catch (err) {
    if ((0, import_error_utils4.isErrnoException)(err) && (err.code === "NOT_AUTHORIZED" || err.code === "TEAM_DELETED")) {
      output_manager_default.error(err.message);
      return 1;
    }
    throw err;
  }
  try {
    link = await ensureLink(commandName, client, client.cwd, {
      autoConfirm
    });
  } catch (err) {
    if ((0, import_error_utils4.isErrnoException)(err) && err.code === "NOT_AUTHORIZED") {
      output_manager_default.error(err.message);
      return 1;
    }
    throw err;
  }
  if (typeof link === "number") {
    return link;
  }
  const { project } = link;
  const linkedProject = await getLinkedProject(client, client.cwd);
  if (linkedProject.status !== "linked") {
    output_manager_default.error("This command requires a linked project. Please run:");
    output_manager_default.print("  vercel link");
    return 1;
  }
  if (!linkedProject.project || !linkedProject.org) {
    output_manager_default.error("Failed to get project information");
    return 1;
  }
  const preferredAlias = linkedProject.project.targets?.production?.alias?.[0];
  const backupAlias = linkedProject.project.latestDeployments?.[0]?.url;
  const target = preferredAlias || backupAlias;
  let baseUrl;
  if (deploymentFlag) {
    const accountId = scope.team?.id || scope.user.id;
    const deploymentUrl = await getDeploymentUrlById(
      client,
      deploymentFlag,
      accountId
    );
    if (!deploymentUrl) {
      output_manager_default.error(`No deployment found for ID "${deploymentFlag}"`);
      return 1;
    }
    baseUrl = deploymentUrl;
  } else if (target) {
    baseUrl = `https://${target}`;
  } else {
    throw new Error("No deployment URL found for the project");
  }
  const fullUrl = `${baseUrl}${path3.startsWith("/") ? path3 : `/${path3}`}`;
  output_manager_default.debug(`${import_chalk24.default.cyan("Target URL:")} ${import_chalk24.default.bold(fullUrl)}`);
  let deploymentProtectionToken = null;
  if (project.id) {
    try {
      deploymentProtectionToken = protectionBypassFlag ?? await getOrCreateDeploymentProtectionToken(client, link);
    } catch (err) {
      output_manager_default.error(
        `Failed to get deployment protection bypass token: ${err instanceof Error ? err.message : String(err)}`
      );
      return 1;
    }
  }
  return {
    fullUrl,
    deploymentProtectionToken,
    link
  };
}

// src/commands/curl/index.ts
async function curl(client) {
  const telemetryClient = new CurlTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  const setup = setupCurlLikeCommand(client, curlCommand, telemetryClient);
  if (typeof setup === "number") {
    return setup;
  }
  const { path: path3, deploymentFlag, protectionBypassFlag, toolFlags } = setup;
  const result = await getDeploymentUrlAndToken(client, "curl", path3, {
    deploymentFlag,
    protectionBypassFlag,
    autoConfirm: setup.yes
  });
  if (typeof result === "number") {
    return result;
  }
  const { fullUrl, deploymentProtectionToken } = result;
  const curlFlags = [...toolFlags];
  if (deploymentProtectionToken) {
    curlFlags.unshift(
      "--header",
      `x-vercel-protection-bypass: ${deploymentProtectionToken}`
    );
  }
  curlFlags.unshift("--url", fullUrl);
  output_manager_default.debug(`Executing: curl ${curlFlags.map(requoteArgs).join(" ")}`);
  return new Promise((resolve6) => {
    const curlProcess = spawn("curl", curlFlags, {
      stdio: "inherit",
      shell: false
    });
    curlProcess.on("error", (err) => {
      if ("code" in err && err.code === "ENOENT") {
        output_manager_default.error("curl command not found. Please install curl.");
        resolve6(1);
      } else {
        output_manager_default.error(`Failed to execute curl: ${err.message}`);
        resolve6(1);
      }
    });
    curlProcess.on("close", (code2) => {
      resolve6(code2 ?? 1);
    });
  });
}

// src/commands/dns/add.ts
var import_chalk26 = __toESM(require_source(), 1);

// src/util/dns/add-dns-record.ts
async function addDNSRecord(client, domain, recordData) {
  try {
    const record = await client.fetch(
      `/v3/domains/${encodeURIComponent(domain)}/records`,
      {
        body: recordData,
        method: "POST"
      }
    );
    return record;
  } catch (err) {
    if (isAPIError(err)) {
      if (err.status === 400 && err.code === "invalid_type") {
        return new DNSInvalidType(recordData.type);
      }
      if (err.status === 400 && err.message.includes("port")) {
        return new DNSInvalidPort();
      }
      if (err.status === 400) {
        return err;
      }
      if (err.status === 403) {
        return new DNSPermissionDenied(domain);
      }
      if (err.status === 404) {
        return new DomainNotFound(domain);
      }
      if (err.status === 409) {
        const { oldId = "" } = err;
        return new DNSConflictingRecord(oldId);
      }
    }
    throw err;
  }
}

// src/util/dns/parse-add-dns-record-args.ts
function parseAddArgs(args) {
  if (!args || args.length < 1) {
    return null;
  }
  const [domain, ...rest] = args;
  if (domain && rest.length === 0) {
    return {
      domain,
      data: null
    };
  }
  const name = args[1] === "@" ? "" : args[1].toString();
  const type = args[2];
  const value = args[3];
  if (!(domain && typeof name === "string" && type)) {
    return null;
  }
  if (type === "MX" && args.length === 5) {
    return {
      domain,
      data: { name, type, value, mxPriority: Number(args[4]) }
    };
  }
  if (type === "SRV" && args.length === 7) {
    return {
      domain,
      data: {
        name,
        type,
        srv: {
          priority: Number(value),
          weight: Number(args[4]),
          port: Number(args[5]),
          target: args[6]
        }
      }
    };
  }
  if (args.length === 4) {
    return {
      domain,
      data: {
        name,
        type,
        value
      }
    };
  }
  return null;
}

// src/util/dns/get-dns-data.ts
var import_chalk25 = __toESM(require_source(), 1);
var RECORD_TYPES = ["A", "AAAA", "ALIAS", "CAA", "CNAME", "MX", "SRV", "TXT"];
async function getDNSData(client, data) {
  if (data) {
    return data;
  }
  try {
    const possibleTypes = new Set(RECORD_TYPES);
    const type = (await client.input.text({
      message: `- Record type (${RECORD_TYPES.join(", ")}): `,
      validate: (v) => Boolean(v && possibleTypes.has(v.trim().toUpperCase()))
    })).trim().toUpperCase();
    const name = await getRecordName(client, type);
    if (type === "SRV") {
      const priority = await getNumber(client, `- ${type} priority: `);
      const weight = await getNumber(client, `- ${type} weight: `);
      const port = await getNumber(client, `- ${type} port: `);
      const target = await getTrimmedString(client, `- ${type} target: `);
      output_manager_default.log(
        `${import_chalk25.default.cyan(name)} ${import_chalk25.default.bold(type)} ${import_chalk25.default.cyan(
          `${priority}`
        )} ${import_chalk25.default.cyan(`${weight}`)} ${import_chalk25.default.cyan(`${port}`)} ${import_chalk25.default.cyan(
          target
        )}.`
      );
      return await verifyData(client) ? {
        name,
        type,
        srv: {
          priority,
          weight,
          port,
          target
        }
      } : null;
    }
    if (type === "MX") {
      const mxPriority = await getNumber(client, `- ${type} priority: `);
      const value2 = await getTrimmedString(client, `- ${type} host: `);
      output_manager_default.log(
        `${import_chalk25.default.cyan(name)} ${import_chalk25.default.bold(type)} ${import_chalk25.default.cyan(
          `${mxPriority}`
        )} ${import_chalk25.default.cyan(value2)}`
      );
      return await verifyData(client) ? {
        name,
        type,
        value: value2,
        mxPriority
      } : null;
    }
    const value = await getTrimmedString(client, `- ${type} value: `);
    output_manager_default.log(`${import_chalk25.default.cyan(name)} ${import_chalk25.default.bold(type)} ${import_chalk25.default.cyan(value)}`);
    return await verifyData(client) ? {
      name,
      type,
      value
    } : null;
  } catch (error) {
    return null;
  }
}
async function verifyData(client) {
  return client.input.confirm("Is this correct?", false);
}
async function getRecordName(client, type) {
  const input = await client.input.text({
    message: `- ${type} name: `
  });
  return input === "@" ? "" : input;
}
async function getNumber(client, label) {
  return Number(
    await client.input.text({
      message: label,
      validate: (v) => Boolean(v && Number(v))
    })
  );
}
async function getTrimmedString(client, label) {
  const res = await client.input.text({
    message: label,
    validate: (v) => Boolean(v && v.trim().length > 0)
  });
  return res.trim();
}

// src/util/telemetry/commands/dns/add.ts
var ALLOWED_RECORD_TYPES = [
  "A",
  "AAAA",
  "ALIAS",
  "CNAME",
  "TXT",
  "MX",
  "SRV"
];
var DnsAddTelemetryClient = class extends TelemetryClient {
  trackCliArgumentDomain(domain) {
    if (domain) {
      this.trackCliArgument({
        arg: "domain",
        value: this.redactedValue
      });
    }
  }
  trackCliArgumentName(name) {
    if (name) {
      this.trackCliArgument({
        arg: "name",
        value: this.redactedValue
      });
    }
  }
  trackCliArgumentType(type) {
    if (type) {
      const allowedType = ALLOWED_RECORD_TYPES.includes(type) ? type : this.redactedValue;
      this.trackCliArgument({
        arg: "type",
        value: allowedType
      });
    }
  }
  trackCliArgumentValues(values) {
    if (values?.length) {
      this.trackCliArgument({
        arg: "values",
        value: this.redactedValue
      });
    }
  }
};

// src/commands/dns/add.ts
async function add2(client, argv) {
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(addSubcommand2.options);
  try {
    parsedArgs = parseArguments(argv, flagsSpecification);
  } catch (err) {
    printError(err);
    return 1;
  }
  const { args } = parsedArgs;
  const parsedParams = parseAddArgs(args);
  if (!parsedParams) {
    output_manager_default.error(
      `Invalid number of arguments. See: ${import_chalk26.default.cyan(
        `${getCommandName("dns --help")}`
      )} for usage.`
    );
    return 1;
  }
  const addStamp = stamp_default();
  const { domain, data: argData } = parsedParams;
  const valueArgs = args.slice(3);
  const telemetryClient = new DnsAddTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  telemetryClient.trackCliArgumentDomain(domain);
  telemetryClient.trackCliArgumentName(parsedParams.data?.name);
  telemetryClient.trackCliArgumentType(parsedParams.data?.type);
  telemetryClient.trackCliArgumentValues(valueArgs);
  const data = await getDNSData(client, argData);
  if (!data) {
    output_manager_default.log(`Canceled`);
    return 1;
  }
  const { contextName } = await getScope(client);
  const record = await addDNSRecord(client, domain, data);
  if (record instanceof DomainNotFound) {
    output_manager_default.error(
      `The domain ${domain} can't be found under ${import_chalk26.default.bold(
        contextName
      )} ${import_chalk26.default.gray(addStamp())}`
    );
    return 1;
  }
  if (record instanceof DNSPermissionDenied) {
    output_manager_default.error(
      `You don't have permissions to add records to domain ${domain} under ${import_chalk26.default.bold(
        contextName
      )} ${import_chalk26.default.gray(addStamp())}`
    );
    return 1;
  }
  if (record instanceof DNSInvalidPort) {
    output_manager_default.error(
      `Invalid <port> parameter. A number was expected ${import_chalk26.default.gray(
        addStamp()
      )}`
    );
    return 1;
  }
  if (record instanceof DNSInvalidType) {
    output_manager_default.error(
      `Invalid <type> parameter "${record.meta.type}". Expected one of A, AAAA, ALIAS, CAA, CNAME, MX, SRV, TXT ${import_chalk26.default.gray(
        addStamp()
      )}`
    );
    return 1;
  }
  if (record instanceof Error) {
    output_manager_default.error(record.message);
    return 1;
  }
  output_manager_default.success(
    `DNS record for domain ${import_chalk26.default.bold(domain)} ${import_chalk26.default.gray(
      `(${record.uid})`
    )} created under ${import_chalk26.default.bold(contextName)} ${import_chalk26.default.gray(addStamp())}`
  );
  return 0;
}

// src/commands/dns/import.ts
var import_chalk28 = __toESM(require_source(), 1);

// src/util/dns/import-zonefile.ts
var import_chalk27 = __toESM(require_source(), 1);
import { readFileSync as readFileSync2 } from "fs";
import { resolve as resolve5 } from "path";
async function importZonefile(client, contextName, domain, zonefilePath) {
  output_manager_default.spinner(
    `Importing Zone file for domain ${domain} under ${import_chalk27.default.bold(contextName)}`
  );
  const zonefile = readFileSync2(resolve5(zonefilePath), "utf8");
  try {
    const res = await client.fetch(
      `/v3/domains/${encodeURIComponent(domain)}/records`,
      {
        headers: { "Content-Type": "text/dns" },
        body: zonefile,
        method: "PUT",
        json: false
      }
    );
    const { recordIds } = await res.json();
    return recordIds;
  } catch (err) {
    if (isAPIError(err)) {
      if (err.code === "not_found") {
        return new DomainNotFound(domain, contextName);
      }
      if (err.code === "invalid_domain") {
        return new InvalidDomain(domain);
      }
    }
    throw err;
  }
}

// src/util/telemetry/commands/dns/import.ts
var DnsImportTelemetryClient = class extends TelemetryClient {
  trackCliArgumentDomain(domain) {
    if (domain) {
      this.trackCliArgument({
        arg: "domain",
        value: this.redactedValue
      });
    }
  }
  trackCliArgumentZonefile(path3) {
    if (path3) {
      this.trackCliArgument({
        arg: "zoneFilePath",
        value: this.redactedValue
      });
    }
  }
};

// src/commands/dns/import.ts
async function importZone(client, argv) {
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(importSubcommand.options);
  try {
    parsedArgs = parseArguments(argv, flagsSpecification);
  } catch (err) {
    printError(err);
    return 1;
  }
  const { args } = parsedArgs;
  const { telemetryEventStore } = client;
  const { contextName } = await getScope(client);
  const telemetry2 = new DnsImportTelemetryClient({
    opts: {
      store: telemetryEventStore
    }
  });
  if (args.length !== 2) {
    output_manager_default.error(
      `Invalid number of arguments. Usage: ${import_chalk28.default.cyan(
        `${getCommandName("dns import <domain> <zonefile>")}`
      )}`
    );
    return 1;
  }
  const addStamp = stamp_default();
  const [domain, zonefilePath] = args;
  telemetry2.trackCliArgumentDomain(domain);
  telemetry2.trackCliArgumentZonefile(zonefilePath);
  const recordIds = await importZonefile(
    client,
    contextName,
    domain,
    zonefilePath
  );
  if (recordIds instanceof DomainNotFound) {
    output_manager_default.error(
      `The domain ${domain} can't be found under ${import_chalk28.default.bold(
        contextName
      )} ${import_chalk28.default.gray(addStamp())}`
    );
    return 1;
  }
  if (recordIds instanceof InvalidDomain) {
    output_manager_default.error(
      `The domain ${domain} doesn't match with the one found in the Zone file ${import_chalk28.default.gray(
        addStamp()
      )}`
    );
    return 1;
  }
  output_manager_default.success(
    `${recordIds.length} DNS records for domain ${import_chalk28.default.bold(
      domain
    )} created under ${import_chalk28.default.bold(contextName)} ${import_chalk28.default.gray(addStamp())}`
  );
  return 0;
}

// src/commands/dns/ls.ts
var import_chalk30 = __toESM(require_source(), 1);
var import_ms8 = __toESM(require_ms(), 1);

// src/util/dns/get-domain-dns-records.ts
async function getDomainDNSRecords(client, domain, apiVersion = 3, nextTimestamp, limit = 20) {
  output_manager_default.debug(`Fetching for DNS records of domain ${domain}`);
  try {
    let url = `/v${apiVersion}/domains/${encodeURIComponent(
      domain
    )}/records?limit=${limit}`;
    if (nextTimestamp) {
      url += `&until=${nextTimestamp}`;
    }
    const data = await client.fetch(url);
    return data;
  } catch (err) {
    if (isAPIError(err) && err.code === "not_found") {
      return new DomainNotFound(domain);
    }
    throw err;
  }
}

// src/util/domains/get-domains.ts
async function getDomains(client, next, limit = 20) {
  let domainUrl = `/v5/domains?limit=${limit}`;
  if (next) {
    domainUrl += `&until=${next}`;
  }
  return await client.fetch(domainUrl);
}

// src/util/dns/get-dns-records.ts
var import_chalk29 = __toESM(require_source(), 1);
async function getDNSRecords(client, contextName, next) {
  const { domainNames, pagination } = await getDomainNames(
    client,
    contextName,
    next
  );
  const domainsRecords = await Promise.all(
    domainNames.map(createGetDomainRecords(client))
  );
  const onlyRecords = domainsRecords.map(
    (item) => item instanceof DomainNotFound ? [] : item
  );
  return {
    records: onlyRecords.reduce(getAddDomainName(domainNames), []),
    pagination
  };
}
function createGetDomainRecords(client) {
  return async (domainName) => {
    const data = await getDomainDNSRecords(client, domainName);
    if (data instanceof DomainNotFound) {
      return [];
    }
    return data.records;
  };
}
function getAddDomainName(domainNames) {
  return (prev, item, idx) => [
    ...prev,
    {
      domainName: domainNames[idx],
      records: item
    }
  ];
}
async function getDomainNames(client, contextName, next) {
  output_manager_default.spinner(`Fetching domains under ${import_chalk29.default.bold(contextName)}`);
  const { domains: domains2, pagination } = await getDomains(client, next);
  return { domainNames: domains2.map((domain) => domain.name), pagination };
}

// src/util/telemetry/commands/dns/ls.ts
var DnsLsTelemetryClient = class extends TelemetryClient {
  trackCliArgumentDomain(domainName) {
    if (domainName) {
      this.trackCliArgument({
        arg: "domain",
        value: this.redactedValue
      });
    }
  }
  trackCliOptionLimit(limit) {
    if (limit) {
      this.trackCliOption({
        option: "limit",
        value: this.redactedValue
      });
    }
  }
  trackCliOptionNext(next) {
    if (next) {
      this.trackCliOption({
        option: "next",
        value: this.redactedValue
      });
    }
  }
};

// src/commands/dns/ls.ts
async function ls3(client, argv) {
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(listSubcommand4.options);
  try {
    parsedArgs = parseArguments(argv, flagsSpecification);
  } catch (err) {
    printError(err);
    return 1;
  }
  const { args, flags: opts } = parsedArgs;
  const validationResult = validateLsArgs({
    commandName: "dns ls [domain]",
    args,
    maxArgs: 1,
    exitCode: 1
  });
  if (validationResult !== 0) {
    return validationResult;
  }
  const { telemetryEventStore } = client;
  const { contextName } = await getScope(client);
  const telemetry2 = new DnsLsTelemetryClient({
    opts: {
      store: telemetryEventStore
    }
  });
  const [domainName] = args;
  const lsStamp = stamp_default();
  telemetry2.trackCliArgumentDomain(domainName);
  telemetry2.trackCliOptionLimit(opts["--limit"]);
  telemetry2.trackCliOptionNext(opts["--next"]);
  let paginationOptions;
  try {
    paginationOptions = getPaginationOpts(opts);
  } catch (err) {
    output_manager_default.prettyError(err);
    return 1;
  }
  if (domainName) {
    const data = await getDomainDNSRecords(
      client,
      domainName,
      4,
      ...paginationOptions
    );
    if (data instanceof DomainNotFound) {
      output_manager_default.error(
        `The domain ${domainName} can't be found under ${import_chalk30.default.bold(
          contextName
        )} ${import_chalk30.default.gray(lsStamp())}`
      );
      return 1;
    }
    const { records, pagination: pagination2 } = data;
    output_manager_default.log(
      `${records.length > 0 ? "Records" : "No records"} found under ${import_chalk30.default.bold(contextName)} ${import_chalk30.default.gray(lsStamp())}`
    );
    client.stdout.write(getDNSRecordsTable([{ domainName, records }]));
    if (pagination2 && pagination2.count === 20) {
      const flags = getCommandFlags(opts, ["_", "--next"]);
      output_manager_default.log(
        `To display the next page run ${getCommandName(
          `dns ls ${domainName}${flags} --next ${pagination2.next}`
        )}`
      );
    }
    return 0;
  }
  const { records: dnsRecords, pagination } = await getDNSRecords(
    client,
    contextName,
    ...paginationOptions
  );
  const nRecords = dnsRecords.reduce((p, r) => r.records.length + p, 0);
  output_manager_default.log(
    `${nRecords > 0 ? "Records" : "No records"} found under ${import_chalk30.default.bold(
      contextName
    )} ${import_chalk30.default.gray(lsStamp())}`
  );
  output_manager_default.log(getDNSRecordsTable(dnsRecords));
  if (pagination && pagination.count === 20) {
    const flags = getCommandFlags(opts, ["_", "--next"]);
    output_manager_default.log(
      `To display the next page run ${getCommandName(
        `dns ls${flags} --next ${pagination.next}`
      )}`
    );
  }
  return 0;
}
function getDNSRecordsTable(dnsRecords) {
  return formatTable(
    ["", "id", "name", "type", "value", "created"],
    ["l", "r", "l", "l", "l", "l"],
    dnsRecords.map(({ domainName, records }) => ({
      name: import_chalk30.default.bold(domainName),
      rows: records.map(getDNSRecordRow)
    }))
  );
}
function getDNSRecordRow(record) {
  const isSystemRecord = record.creator === "system";
  const createdAt = `${(0, import_ms8.default)(
    Date.now() - new Date(Number(record.createdAt)).getTime()
  )} ago`;
  const priority = record.mxPriority || record.priority || null;
  return [
    "",
    !isSystemRecord ? record.id : "",
    record.name,
    record.type,
    priority ? `${priority} ${record.value}` : record.value,
    import_chalk30.default.gray(isSystemRecord ? "default" : createdAt)
  ];
}

// src/commands/dns/rm.ts
var import_chalk31 = __toESM(require_source(), 1);
var import_ms9 = __toESM(require_ms(), 1);

// src/util/dns/delete-dns-record-by-id.ts
async function deleteDNSRecordById(client, domain, recordId) {
  return client.fetch(
    `/v3/domains/${encodeURIComponent(domain)}/records/${recordId}`,
    {
      method: "DELETE"
    }
  );
}

// src/util/dns/get-dns-record-by-id.ts
async function getDNSRecordById(client, id) {
  return client.fetch(`/v5/domains/records/${id}`);
}

// src/util/telemetry/commands/dns/rm.ts
var DnsRmTelemetryClient = class extends TelemetryClient {
  trackCliArgumentId(recordId) {
    if (recordId) {
      this.trackCliArgument({
        arg: "recordId",
        value: this.redactedValue
      });
    }
  }
  trackCliFlagYes(yes) {
    if (yes) {
      this.trackCliFlag("yes");
    }
  }
};

// src/commands/dns/rm.ts
async function rm3(client, argv) {
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(removeSubcommand3.options);
  try {
    parsedArgs = parseArguments(argv, flagsSpecification);
  } catch (err) {
    printError(err);
    return 1;
  }
  const { args, flags } = parsedArgs;
  const { telemetryEventStore } = client;
  const telemetry2 = new DnsRmTelemetryClient({
    opts: {
      store: telemetryEventStore
    }
  });
  await getScope(client);
  const [recordId] = args;
  if (args.length !== 1) {
    output_manager_default.error(
      `Invalid number of arguments. Usage: ${import_chalk31.default.cyan(
        `${getCommandName("dns rm <id>")}`
      )}`
    );
    return 1;
  }
  telemetry2.trackCliArgumentId(recordId);
  telemetry2.trackCliFlagYes(flags["--yes"]);
  const record = await getDNSRecordById(client, recordId);
  if (!record) {
    output_manager_default.error("DNS record not found");
    return 1;
  }
  const { domain: domainName } = record;
  const skipConfirmation = flags["--yes"];
  const yes = skipConfirmation || await readConfirmation2(
    client,
    "The following record will be removed permanently",
    domainName,
    record
  );
  if (!yes) {
    output_manager_default.error(`User canceled.`);
    return 0;
  }
  const rmStamp = stamp_default();
  await deleteDNSRecordById(client, domainName, record.id);
  output_manager_default.success(
    `Record ${import_chalk31.default.gray(`${record.id}`)} removed ${import_chalk31.default.gray(rmStamp())}`
  );
  return 0;
}
function readConfirmation2(client, msg, domainName, record) {
  return new Promise((resolve6) => {
    output_manager_default.log(msg);
    output_manager_default.print(
      `${table([getDeleteTableRow(domainName, record)], {
        align: ["l", "r", "l"],
        hsep: 6
      }).replace(/^(.*)/gm, "  $1")}
`
    );
    output_manager_default.print(
      `${import_chalk31.default.bold.red("> Are you sure?")} ${import_chalk31.default.gray("(y/N) ")}`
    );
    client.stdin.on("data", (d) => {
      process.stdin.pause();
      resolve6(d.toString().trim().toLowerCase() === "y");
    }).resume();
  });
}
function getDeleteTableRow(domainName, record) {
  const recordName = `${record.name.length > 0 ? `${record.name}.` : ""}${domainName}`;
  return [
    record.id,
    import_chalk31.default.bold(
      `${recordName} ${record.type} ${record.value} ${record.mxPriority || ""}`
    ),
    import_chalk31.default.gray(
      `${(0, import_ms9.default)(Date.now() - new Date(Number(record.createdAt)).getTime())} ago`
    )
  ];
}

// src/util/telemetry/commands/dns/index.ts
var DnsTelemetryClient = class extends TelemetryClient {
  trackCliSubcommandAdd(actual) {
    this.trackCliSubcommand({
      subcommand: "add",
      value: actual
    });
  }
  trackCliSubcommandRemove(actual) {
    this.trackCliSubcommand({
      subcommand: "remove",
      value: actual
    });
  }
  trackCliSubcommandImport(actual) {
    this.trackCliSubcommand({
      subcommand: "import",
      value: actual
    });
  }
  trackCliSubcommandList(actual) {
    this.trackCliSubcommand({
      subcommand: "list",
      value: actual
    });
  }
};

// src/commands/dns/index.ts
var COMMAND_CONFIG6 = {
  add: getCommandAliases(addSubcommand2),
  import: getCommandAliases(importSubcommand),
  ls: getCommandAliases(listSubcommand4),
  rm: getCommandAliases(removeSubcommand3)
};
async function dns(client) {
  const { telemetryEventStore } = client;
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(dnsCommand.options);
  try {
    parsedArgs = parseArguments(client.argv.slice(2), flagsSpecification, {
      permissive: true
    });
  } catch (err) {
    printError(err);
    return 1;
  }
  const telemetry2 = new DnsTelemetryClient({
    opts: {
      store: telemetryEventStore
    }
  });
  const { subcommand, subcommandOriginal, args } = getSubcommand3(
    parsedArgs.args.slice(1),
    COMMAND_CONFIG6
  );
  const needHelp = parsedArgs.flags["--help"];
  if (!subcommand && needHelp) {
    telemetry2.trackCliFlagHelp("dns", subcommand);
    output_manager_default.print(help(dnsCommand, { columns: client.stderr.columns }));
    return 2;
  }
  function printHelp(command) {
    output_manager_default.print(
      help(command, { parent: dnsCommand, columns: client.stderr.columns })
    );
  }
  switch (subcommand) {
    case "add":
      if (needHelp) {
        telemetry2.trackCliFlagHelp("dns", subcommandOriginal);
        printHelp(addSubcommand2);
        return 2;
      }
      telemetry2.trackCliSubcommandAdd(subcommandOriginal);
      return add2(client, args);
    case "import":
      if (needHelp) {
        telemetry2.trackCliFlagHelp("dns", subcommandOriginal);
        printHelp(importSubcommand);
        return 2;
      }
      telemetry2.trackCliSubcommandImport(subcommandOriginal);
      return importZone(client, args);
    case "rm":
      if (needHelp) {
        telemetry2.trackCliFlagHelp("dns", subcommandOriginal);
        printHelp(removeSubcommand3);
        return 2;
      }
      telemetry2.trackCliSubcommandRemove(subcommandOriginal);
      return rm3(client, args);
    default:
      if (needHelp) {
        telemetry2.trackCliFlagHelp("dns", subcommandOriginal);
        printHelp(listSubcommand4);
        return 2;
      }
      telemetry2.trackCliSubcommandList(subcommandOriginal);
      return ls3(client, args);
  }
}

// src/commands/domains/add.ts
var import_chalk35 = __toESM(require_source(), 1);

// src/util/format-ns-table.ts
var import_chalk32 = __toESM(require_source(), 1);

// src/util/output/chars.ts
var chars = {
  tick: process.platform === "win32" ? "\u221A" : "\u2714",
  cross: process.platform === "win32" ? "\u2613" : "\u2718"
};
var chars_default = chars;

// src/util/format-ns-table.ts
function formatNSTable(intendedNameservers, currentNameservers, { extraSpace = "" } = {}) {
  const sortedIntended = intendedNameservers.sort();
  const sortedCurrent = currentNameservers.sort();
  const maxLength = Math.max(
    intendedNameservers.length,
    currentNameservers.length
  );
  const rows = [];
  for (let i = 0; i < maxLength; i++) {
    rows.push([
      sortedIntended[i] || import_chalk32.default.gray("-"),
      sortedCurrent[i] || import_chalk32.default.gray("-"),
      sortedIntended[i] === sortedCurrent[i] ? import_chalk32.default.green(chars_default.tick) : import_chalk32.default.red(chars_default.cross)
    ]);
  }
  return table(
    [
      [
        import_chalk32.default.gray("Intended Nameservers"),
        import_chalk32.default.gray("Current Nameservers"),
        ""
      ],
      ...rows
    ],
    { hsep: 4 }
  ).replace(/^(.*)/gm, `${extraSpace}$1`);
}

// src/util/domains/is-public-suffix.ts
function isPublicSuffix(domainName) {
  return domainName.endsWith(".vercel.app") || domainName.endsWith(".now.sh");
}

// src/util/domains/get-domain-config.ts
async function getDomainConfig(client, domainName) {
  try {
    const config = await client.fetch(
      `/v4/domains/${domainName}/config`
    );
    return config;
  } catch (err) {
    if (isAPIError(err) && err.status < 500) {
      return err;
    }
    throw err;
  }
}

// src/util/projects/add-domain-to-project.ts
var import_chalk33 = __toESM(require_source(), 1);
async function addDomainToProject(client, projectNameOrId, domain) {
  output_manager_default.spinner(
    `Adding domain ${domain} to project ${import_chalk33.default.bold(projectNameOrId)}`
  );
  try {
    const response = await client.fetch(
      `/projects/${encodeURIComponent(projectNameOrId)}/alias`,
      {
        method: "POST",
        body: JSON.stringify({
          target: "PRODUCTION",
          domain
        })
      }
    );
    const aliasTarget = response.find(
      (aliasTarget2) => aliasTarget2.domain === domain
    );
    if (!aliasTarget) {
      throw new Error(
        `Unexpected error when adding the domain "${domain}" to project "${projectNameOrId}".`
      );
    }
    return aliasTarget;
  } catch (err) {
    if (isAPIError(err) && err.status < 500) {
      return err;
    }
    throw err;
  }
}

// src/util/projects/remove-domain-from-project.ts
var import_chalk34 = __toESM(require_source(), 1);
async function removeDomainFromProject(client, projectNameOrId, domain) {
  output_manager_default.spinner(
    `Removing domain ${domain} from project ${import_chalk34.default.bold(projectNameOrId)}`
  );
  try {
    const response = await client.fetch(
      `/projects/${encodeURIComponent(
        projectNameOrId
      )}/alias?domain=${encodeURIComponent(domain)}`,
      {
        method: "DELETE"
      }
    );
    return response;
  } catch (err) {
    if (isAPIError(err) && err.status < 500) {
      return err;
    }
    throw err;
  }
}

// src/util/telemetry/commands/domains/add.ts
var DomainsAddTelemetryClient = class extends TelemetryClient {
  trackCliFlagForce(force) {
    if (force) {
      this.trackCliFlag("force");
    }
  }
  trackCliArgumentDomain(domainName) {
    if (domainName) {
      this.trackCliArgument({
        arg: "domain",
        value: this.redactedValue
      });
    }
  }
  trackCliArgumentProject(projectName) {
    if (projectName) {
      this.trackCliArgument({
        arg: "project",
        value: this.redactedValue
      });
    }
  }
};

// src/commands/domains/add.ts
async function add3(client, argv) {
  const telemetry2 = new DomainsAddTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(addSubcommand3.options);
  try {
    parsedArgs = parseArguments(argv, flagsSpecification);
  } catch (error) {
    printError(error);
    return 1;
  }
  const { args, flags: opts } = parsedArgs;
  const force = opts["--force"];
  telemetry2.trackCliFlagForce(force);
  const { contextName } = await getScope(client);
  const project = await getLinkedProject(client).then((result) => {
    if (result.status === "linked") {
      return result.project;
    }
    return null;
  });
  if (project && args.length !== 1) {
    output_manager_default.error(
      `${getCommandName("domains add <domain>")} expects one argument.`
    );
    return 1;
  }
  if (!project && args.length !== 2) {
    output_manager_default.error(
      `${getCommandName(
        "domains add <domain> <project>"
      )} expects two arguments.`
    );
    return 1;
  }
  const domainName = String(args[0]);
  const projectName = project ? project.name : String(args[1]);
  telemetry2.trackCliArgumentDomain(domainName);
  telemetry2.trackCliArgumentProject(args[1]);
  const addStamp = stamp_default();
  let aliasTarget = await addDomainToProject(client, projectName, domainName);
  if (aliasTarget instanceof Error) {
    if (aliasTarget instanceof APIError && aliasTarget.code === "ALIAS_DOMAIN_EXIST" && aliasTarget.project && aliasTarget.project.id) {
      if (force) {
        const removeResponse = await removeDomainFromProject(
          client,
          aliasTarget.project.id,
          domainName
        );
        if (removeResponse instanceof Error) {
          output_manager_default.prettyError(removeResponse);
          return 1;
        }
        aliasTarget = await addDomainToProject(client, projectName, domainName);
      }
    }
    if (aliasTarget instanceof Error) {
      output_manager_default.prettyError(aliasTarget);
      return 1;
    }
  }
  output_manager_default.success(
    `Domain ${import_chalk35.default.bold(domainName)} added to project ${import_chalk35.default.bold(
      projectName
    )}. ${addStamp()}`
  );
  if (isPublicSuffix(domainName)) {
    output_manager_default.log(
      "The domain will automatically get assigned to your latest production deployment."
    );
    return 0;
  }
  const domainResponse = await getDomain(client, contextName, domainName);
  if (domainResponse instanceof Error) {
    output_manager_default.prettyError(domainResponse);
    return 1;
  }
  const domainConfig = await getDomainConfig(client, domainName);
  if (domainConfig.misconfigured) {
    output_manager_default.warn(
      "This domain is not configured properly. To configure it you should either:"
    );
    output_manager_default.print(
      `  ${import_chalk35.default.grey("a)")} Set the following record on your DNS provider to continue: ${code(`A ${domainName} 76.76.21.21`)} ${import_chalk35.default.grey("[recommended]")}
`
    );
    output_manager_default.print(
      `  ${import_chalk35.default.grey("b)")} Change your Domains's nameservers to the intended set`
    );
    output_manager_default.print(
      `
${formatNSTable(
        domainResponse.intendedNameservers,
        domainResponse.nameservers,
        { extraSpace: "     " }
      )}

`
    );
    output_manager_default.print(
      "  We will run a verification for you and you will receive an email upon completion.\n"
    );
    output_manager_default.print("  Read more: https://vercel.link/domain-configuration\n\n");
  } else {
    output_manager_default.log(
      "The domain will automatically get assigned to your latest production deployment."
    );
  }
  return 0;
}

// src/commands/domains/buy.ts
var import_chalk36 = __toESM(require_source(), 1);
var import_tldts4 = __toESM(require_cjs(), 1);
var import_error_utils5 = __toESM(require_dist(), 1);

// src/util/telemetry/commands/domains/buy.ts
var DomainsBuyTelemetryClient = class extends TelemetryClient {
  trackCliArgumentDomain(v) {
    if (v) {
      this.trackCliArgument({
        arg: "domain",
        value: this.redactedValue
      });
    }
  }
};

// src/commands/domains/buy.ts
async function buy(client, argv) {
  const telemetry2 = new DomainsBuyTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(buySubcommand.options);
  try {
    parsedArgs = parseArguments(argv, flagsSpecification);
  } catch (error) {
    printError(error);
    return 1;
  }
  const { args } = parsedArgs;
  const [domainName] = args;
  const skipConfirmation = !!process.env.CI;
  telemetry2.trackCliArgumentDomain(domainName);
  if (!domainName) {
    output_manager_default.error(
      `Missing domain name. Run ${getCommandName(`domains --help`)}`
    );
    return 1;
  }
  const { contextName } = await getScope(client);
  const parsedDomain = (0, import_tldts4.parse)(domainName);
  const { domain: rootDomain, subdomain } = parsedDomain;
  if (subdomain || !rootDomain) {
    output_manager_default.error(
      `Invalid domain name "${domainName}". Run ${getCommandName(
        `domains --help`
      )}`
    );
    return 1;
  }
  const availableStamp = stamp_default();
  const domainPrice = await getDomainPrice(client, domainName);
  if (domainPrice instanceof Error) {
    output_manager_default.prettyError(domainPrice);
    return 1;
  }
  const { years, purchasePrice, renewalPrice } = domainPrice;
  if (purchasePrice === null || renewalPrice === null) {
    output_manager_default.error("Domain price not found");
    return 1;
  }
  if (!(await getDomainStatus(client, domainName)).available) {
    output_manager_default.error(
      `The domain ${param(domainName)} is ${import_chalk36.default.underline(
        "unavailable"
      )}! ${availableStamp()}`
    );
    return 1;
  }
  output_manager_default.log(
    `The domain ${param(domainName)} is ${import_chalk36.default.underline(
      "available"
    )} to buy under ${import_chalk36.default.bold(contextName)}! ${availableStamp()}`
  );
  if (skipConfirmation) {
    output_manager_default.error(
      "Domain purchase in CI mode is not supported. Please run this command interactively to provide contact information."
    );
    return 1;
  }
  if (!await client.input.confirm(
    `Buy now for ${import_chalk36.default.bold(`$${purchasePrice}`)} (${`${years}yr${years > 1 ? "s" : ""}`})?`,
    false
  )) {
    return 0;
  }
  const autoRenew = await client.input.confirm(
    years === 1 ? `Auto renew yearly for ${import_chalk36.default.bold(`$${renewalPrice}`)}?` : `Auto renew every ${years} years for ${import_chalk36.default.bold(
      `$${renewalPrice}`
    )}?`,
    true
  );
  const contactInformation = await collectContactInformation(client);
  let buyResult;
  const purchaseStamp = stamp_default();
  output_manager_default.spinner("Purchasing");
  try {
    buyResult = await purchaseDomain(
      client,
      domainName,
      purchasePrice,
      years,
      autoRenew,
      contactInformation
    );
  } catch (err) {
    output_manager_default.error(
      "An unexpected error occurred while purchasing your domain. Please try again later."
    );
    output_manager_default.debug(`Server response: ${(0, import_error_utils5.errorToString)(err)}`);
    return 1;
  }
  output_manager_default.stopSpinner();
  if (buyResult instanceof UnsupportedTLD) {
    output_manager_default.error(
      `The TLD for domain name ${buyResult.meta.domain} is not supported.`
    );
    return 1;
  }
  if (buyResult instanceof TLDNotSupportedViaCLI) {
    output_manager_default.error(
      `Purchased for the TLD for domain name ${buyResult.meta.domain} are not supported via the CLI. Use the REST API or the dashboard to purchase.`
    );
    return 1;
  }
  if (buyResult instanceof InvalidDomain) {
    output_manager_default.error(`The domain ${buyResult.meta.domain} is not valid.`);
    return 1;
  }
  if (buyResult instanceof DomainNotAvailable) {
    output_manager_default.error(`The domain ${buyResult.meta.domain} is not available.`);
    return 1;
  }
  if (buyResult instanceof UnexpectedDomainPurchaseError) {
    output_manager_default.error(`An unexpected error happened while performing the purchase.`);
    return 1;
  }
  if (buyResult instanceof DomainPaymentError) {
    output_manager_default.error(`Your card was declined.`);
    return 1;
  }
  output_manager_default.success(`Domain ${param(domainName)} purchased ${purchaseStamp()}`);
  output_manager_default.note(
    `You may now use your domain as an alias to your deployments. Run ${getCommandName(
      `alias --help`
    )}`
  );
  return 0;
}

// src/commands/domains/transfer-in.ts
var import_chalk37 = __toESM(require_source(), 1);

// src/util/domains/transfer-in-domain.ts
async function transferInDomain(client, name, authCode, expectedPrice, years) {
  const { team } = await getScope(client);
  const teamParam = team ? `?teamId=${team.slug}` : "";
  try {
    const { orderId } = await client.fetch(
      `/v1/registrar/domains/${name}/transfer${teamParam}`,
      {
        body: {
          authCode,
          autoRenew: true,
          years,
          expectedPrice,
          contactInformation: {
            firstName: "Vercel",
            lastName: "Whois",
            email: "domains@registrar.vercel.com",
            phone: "+14153985463",
            address1: "100 First Street, Suite 2400",
            city: "San Fransisco",
            state: "CA",
            zip: "94105",
            country: "US",
            companyName: "Vercel Inc."
          }
        },
        method: "POST"
      }
    );
    const order = await pollForOrder(client, orderId);
    if (order === null) {
      return new UnexpectedDomainTransferError(name);
    }
    if (order.status === "completed") {
      const domain = order.domains.find((domain2) => domain2.domainName === name);
      if (domain?.status === "completed") {
        return { ok: true };
      }
    }
    if (order.error?.code === "payment_failed") {
      return new DomainPaymentError();
    }
    return new UnexpectedDomainTransferError(name);
  } catch (err) {
    if (isAPIError(err)) {
      if (err.code === "invalid_name") {
        return new InvalidDomain(name);
      }
      if (err.code === "tld_not_supported") {
        return new UnsupportedTLD(name);
      }
      if (err.code === "domain_not_available") {
        return new DomainNotAvailable(name);
      }
    }
    throw err;
  }
}

// src/util/domains/get-auth-code.ts
async function getAuthCode(client, code2) {
  if (isValidAuthCode(code2)) {
    return code2;
  }
  return client.input.text({
    message: `- Transfer auth code: `,
    validate: isValidAuthCode
  });
}
function isValidAuthCode(code2) {
  return !!(code2 && code2.length > 0);
}

// src/util/is-root-domain.ts
var import_tldts5 = __toESM(require_cjs(), 1);
function isRootDomain(domainName) {
  const parsedDomain = (0, import_tldts5.parse)(domainName);
  const { domain: rootDomain, subdomain } = parsedDomain;
  return Boolean(!subdomain && rootDomain);
}

// src/util/telemetry/commands/domains/transfer-in.ts
var DomainsTransferInTelemetryClient = class extends TelemetryClient {
  trackCliOptionCode(code2) {
    if (code2) {
      this.trackCliOption({
        option: "code",
        value: this.redactedValue
      });
    }
  }
  trackCliArgumentDomain(domainName) {
    if (domainName) {
      this.trackCliArgument({
        arg: "domain",
        value: this.redactedValue
      });
    }
  }
};

// src/commands/domains/transfer-in.ts
async function transferIn(client, argv) {
  const telemetry2 = new DomainsTransferInTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(
    transferInSubcommand.options
  );
  try {
    parsedArgs = parseArguments(argv, flagsSpecification);
  } catch (error) {
    printError(error);
    return 1;
  }
  const { args, flags: opts } = parsedArgs;
  telemetry2.trackCliOptionCode(opts["--code"]);
  const [domainName] = args;
  if (!domainName) {
    output_manager_default.error(
      `Missing domain name. Run ${getCommandName(`domains --help`)}`
    );
    return 1;
  }
  telemetry2.trackCliArgumentDomain(domainName);
  if (!isRootDomain(domainName)) {
    output_manager_default.error(
      `Invalid domain name ${param(domainName)}. Run ${getCommandName(
        `domains --help`
      )}`
    );
    return 1;
  }
  const availableStamp = stamp_default();
  const domainPrice = await getDomainPrice(client, domainName);
  if (domainPrice instanceof Error) {
    output_manager_default.prettyError(domainPrice);
    return 1;
  }
  const { transferPrice, years } = domainPrice;
  if (transferPrice === null) {
    output_manager_default.error(`The domain ${param(domainName)} is not transferable.`);
    return 1;
  }
  const { contextName } = await getScope(client);
  output_manager_default.log(
    `The domain ${param(domainName)} is ${import_chalk37.default.underline(
      "available"
    )} to transfer under ${import_chalk37.default.bold(contextName)}! ${availableStamp()}`
  );
  const authCode = await getAuthCode(client, opts["--code"]);
  const shouldTransfer = await client.input.confirm(
    `Transfer now with 1yr renewal for ${import_chalk37.default.bold(`$${transferPrice}`)}?`,
    false
  );
  if (!shouldTransfer) {
    return 0;
  }
  const transferStamp = stamp_default();
  output_manager_default.spinner(`Initiating transfer for domain ${domainName}`);
  const transferInResult = await transferInDomain(
    client,
    domainName,
    authCode,
    transferPrice,
    years
  );
  if (transferInResult instanceof InvalidDomain) {
    output_manager_default.error(`The domain ${transferInResult.meta.domain} is not valid.`);
    return 1;
  }
  if (transferInResult instanceof DomainNotAvailable) {
    output_manager_default.error(
      `The domain "${transferInResult.meta.domain}" is not transferable.`
    );
    return 1;
  }
  if (transferInResult instanceof UnsupportedTLD) {
    output_manager_default.error(
      `The TLD for domain name ${transferInResult.meta.domain} is not supported.`
    );
    return 1;
  }
  if (transferInResult instanceof DomainPaymentError) {
    output_manager_default.error(`Your card was declined.`);
    return 1;
  }
  if (transferInResult instanceof UnexpectedDomainTransferError) {
    output_manager_default.error(`An unexpected error happened while initiating the transfer.`);
    return 1;
  }
  output_manager_default.success(
    `Domain ${param(domainName)} transfer started ${transferStamp()}`
  );
  output_manager_default.print(
    `  To finalize the transfer, we are waiting for approval from your current registrar.
`
  );
  output_manager_default.print(`  You will receive an email upon completion.
`);
  output_manager_default.warn(
    `Once transferred, your domain ${param(
      domainName
    )} will be using Vercel DNS.
`
  );
  output_manager_default.print(
    `  To transfer with previous DNS records, export the zone file from your previous registrar.
`
  );
  output_manager_default.print(`  Then import it to Vercel DNS by using:
`);
  output_manager_default.print(
    `    ${getCommandName(`dns import ${domainName} <zonefile>`)}

`
  );
  return 0;
}

// src/commands/domains/inspect.ts
var import_chalk38 = __toESM(require_source(), 1);

// src/util/projects/find-projects-for-domain.ts
async function findProjectsForDomain(client, domainName) {
  try {
    const result = [];
    for await (const chunk of client.fetchPaginated(
      "/v9/projects"
    )) {
      for (const project of chunk.projects) {
        if (project.targets?.production?.alias?.some?.(
          (alias2) => alias2.endsWith(domainName)
        )) {
          result.push(project);
        }
      }
    }
    return result;
  } catch (err) {
    if (isAPIError(err) && err.status < 500) {
      return err;
    }
    throw err;
  }
}

// src/util/domains/get-domain-registrar.ts
function getDomainRegistrar(domain) {
  if (domain.boughtAt) {
    return "Vercel";
  }
  if (typeof domain.orderedAt === "number" && !domain.boughtAt) {
    return "Purchase in Process";
  }
  return "Third Party";
}

// src/util/telemetry/commands/domains/inspect.ts
var DomainsInspectTelemetryClient = class extends TelemetryClient {
  trackCliArgumentDomain(name) {
    if (name) {
      this.trackCliArgument({
        arg: "domain",
        value: this.redactedValue
      });
    }
  }
};

// src/commands/domains/inspect.ts
async function inspect(client, argv) {
  const telemetry2 = new DomainsInspectTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(inspectSubcommand.options);
  try {
    parsedArgs = parseArguments(argv, flagsSpecification);
  } catch (error) {
    printError(error);
    return 1;
  }
  const { args } = parsedArgs;
  const [domainName] = args;
  const inspectStamp = stamp_default();
  if (!domainName) {
    output_manager_default.error(
      `${getCommandName(`domains inspect <domain>`)} expects one argument`
    );
    return 1;
  }
  telemetry2.trackCliArgumentDomain(domainName);
  if (args.length !== 1) {
    output_manager_default.error(
      `Invalid number of arguments. Usage: ${import_chalk38.default.cyan(
        `${getCommandName("domains inspect <domain>")}`
      )}`
    );
    return 1;
  }
  output_manager_default.debug(`Fetching domain info`);
  const { contextName } = await getScope(client);
  output_manager_default.spinner(
    `Fetching Domain ${domainName} under ${import_chalk38.default.bold(contextName)}`
  );
  const information = await fetchInformation({
    client,
    contextName,
    domainName
  });
  if (typeof information === "number") {
    return information;
  }
  const { domain, projects, renewalPrice, domainConfig } = information;
  output_manager_default.log(
    `Domain ${domainName} found under ${import_chalk38.default.bold(contextName)} ${import_chalk38.default.gray(
      inspectStamp()
    )}`
  );
  output_manager_default.print("\n");
  output_manager_default.print(import_chalk38.default.bold("  General\n\n"));
  output_manager_default.print(`    ${import_chalk38.default.cyan("Name")}			${domain.name}
`);
  output_manager_default.print(
    `    ${import_chalk38.default.cyan("Registrar")}			${getDomainRegistrar(domain)}
`
  );
  output_manager_default.print(
    `    ${import_chalk38.default.cyan("Expiration Date")}		${formatDate(domain.expiresAt)}
`
  );
  output_manager_default.print(
    `    ${import_chalk38.default.cyan("Creator")}			${domain.creator.username}
`
  );
  output_manager_default.print(
    `    ${import_chalk38.default.cyan("Created At")}			${formatDate(domain.createdAt)}
`
  );
  output_manager_default.print(`    ${import_chalk38.default.cyan("Edge Network")}		yes
`);
  output_manager_default.print(
    `    ${import_chalk38.default.cyan("Renewal Price")}		${domain.boughtAt && renewalPrice ? `$${renewalPrice} USD` : import_chalk38.default.gray("-")}
`
  );
  output_manager_default.print("\n");
  output_manager_default.print(import_chalk38.default.bold("  Nameservers\n\n"));
  output_manager_default.print(
    `${formatNSTable(domain.intendedNameservers, domain.nameservers, {
      extraSpace: "    "
    })}
`
  );
  output_manager_default.print("\n");
  if (Array.isArray(projects) && projects.length > 0) {
    output_manager_default.print(import_chalk38.default.bold("  Projects\n"));
    const table3 = formatTable(
      ["Project", "Domains"],
      ["l", "l"],
      [
        {
          rows: projects.map((project) => {
            const name = project.name;
            const domains2 = (project.targets?.production?.alias || []).filter(
              (alias2) => alias2.endsWith(domainName)
            );
            const cols = domains2.length ? domains2.join(", ") : "-";
            return [name, cols];
          })
        }
      ]
    );
    output_manager_default.print(
      table3.split("\n").map((line) => `   ${line}`).join("\n")
    );
    output_manager_default.print("\n");
  }
  if (domainConfig.misconfigured) {
    output_manager_default.warn(
      `This Domain is not configured properly. To configure it you should either:`,
      null,
      null,
      null
    );
    output_manager_default.print(
      `  ${import_chalk38.default.grey("a)")} Set the following record on your DNS provider to continue: ${code(`A ${domainName} 76.76.21.21`)} ${import_chalk38.default.grey("[recommended]")}
`
    );
    output_manager_default.print(
      `  ${import_chalk38.default.grey("b)")} Change your Domains's nameservers to the intended set detailed above.

`
    );
    output_manager_default.print(
      `  We will run a verification for you and you will receive an email upon completion.
`
    );
    const contextNameConst = contextName;
    const projectNames = Array.from(
      new Set(projects.map((project) => project.name))
    );
    if (projectNames.length) {
      projectNames.forEach((name, index) => {
        const prefix = index === 0 ? "  Read more:" : " ".repeat(12);
        output_manager_default.print(
          `${prefix} https://vercel.com/${contextNameConst}/${name}/settings/domains
`
        );
      });
    } else {
      output_manager_default.print(`  Read more: https://vercel.link/domain-configuration
`);
    }
    output_manager_default.print("\n");
  }
  return null;
}
async function fetchInformation({
  client,
  contextName,
  domainName
}) {
  const [domain, renewalPrice] = await Promise.all([
    getDomainByName(client, contextName, domainName, { ignoreWait: true }),
    getDomainPrice(client, domainName).then((res) => res instanceof Error ? null : res.renewalPrice).catch(() => null)
  ]);
  if (domain instanceof DomainNotFound) {
    output_manager_default.prettyError(domain);
    return 1;
  }
  if (domain instanceof DomainPermissionDenied) {
    output_manager_default.prettyError(domain);
    output_manager_default.log(`Run ${getCommandName(`domains ls`)} to see your domains.`);
    return 1;
  }
  const projects = await findProjectsForDomain(client, domainName);
  if (projects instanceof Error) {
    output_manager_default.prettyError(projects);
    return 1;
  }
  const domainConfig = await getDomainConfig(client, domainName);
  return {
    domain,
    projects,
    renewalPrice,
    domainConfig
  };
}

// src/commands/domains/ls.ts
var import_ms10 = __toESM(require_ms(), 1);
var import_chalk39 = __toESM(require_source(), 1);
var import_pluralize5 = __toESM(require_pluralize(), 1);

// src/util/telemetry/commands/domains/ls.ts
var DomainsLsTelemetryClient = class extends TelemetryClient {
  trackCliOptionLimit(limit) {
    if (limit) {
      this.trackCliOption({
        option: "limit",
        value: this.redactedValue
      });
    }
  }
  trackCliOptionNext(next) {
    if (next) {
      this.trackCliOption({
        option: "next",
        value: this.redactedValue
      });
    }
  }
};

// src/commands/domains/ls.ts
async function ls4(client, argv) {
  const telemetry2 = new DomainsLsTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(listSubcommand5.options);
  try {
    parsedArgs = parseArguments(argv, flagsSpecification);
  } catch (error) {
    printError(error);
    return 1;
  }
  const { args, flags: opts } = parsedArgs;
  const validationResult = validateLsArgs({
    commandName: "domains ls",
    args,
    maxArgs: 0,
    exitCode: 2
  });
  if (validationResult !== 0) {
    return validationResult;
  }
  telemetry2.trackCliOptionLimit(opts["--limit"]);
  telemetry2.trackCliOptionNext(opts["--next"]);
  telemetry2.trackCliOptionFormat(opts["--format"]);
  const formatResult = validateJsonOutput(opts);
  if (!formatResult.valid) {
    output_manager_default.error(formatResult.error);
    return 1;
  }
  const asJson = formatResult.jsonOutput;
  let paginationOptions;
  try {
    paginationOptions = getPaginationOpts(opts);
  } catch (err) {
    output_manager_default.prettyError(err);
    return 1;
  }
  const { contextName } = await getScope(client);
  const lsStamp = stamp_default();
  output_manager_default.spinner(`Fetching Domains under ${import_chalk39.default.bold(contextName)}`);
  const { domains: domains2, pagination } = await getDomains(
    client,
    ...paginationOptions
  );
  if (asJson) {
    output_manager_default.stopSpinner();
    const jsonOutput = {
      domains: domains2.map((domain) => ({
        name: domain.name,
        registrar: getDomainRegistrar(domain),
        nameservers: isDomainExternal(domain) ? "external" : "vercel",
        expiresAt: domain.expiresAt,
        createdAt: domain.createdAt,
        creator: domain.creator.username
      })),
      pagination
    };
    client.stdout.write(`${JSON.stringify(jsonOutput, null, 2)}
`);
  } else {
    output_manager_default.log(
      `${(0, import_pluralize5.default)("Domain", domains2.length, true)} found under ${import_chalk39.default.bold(
        contextName
      )} ${import_chalk39.default.gray(lsStamp())}`
    );
    if (domains2.length > 0) {
      output_manager_default.print(
        formatDomainsTable(domains2).replace(/^(.*)/gm, `${" ".repeat(1)}$1`)
      );
      output_manager_default.print("\n\n");
    }
    if (pagination && pagination.count === 20) {
      const flags = getCommandFlags(opts, ["_", "--next", "--format"]);
      output_manager_default.log(
        `To display the next page, run ${getCommandName(
          `domains ls${flags} --next ${pagination.next}`
        )}`
      );
    }
  }
  return 0;
}
function formatDomainsTable(domains2) {
  const current = Date.now();
  const rows = domains2.map((domain) => {
    const expiration = formatDateWithoutTime(domain.expiresAt);
    const age = domain.createdAt ? (0, import_ms10.default)(current - domain.createdAt) : "-";
    return [
      domain.name,
      getDomainRegistrar(domain),
      isDomainExternal(domain) ? "Third Party" : "Vercel",
      expiration,
      domain.creator.username,
      import_chalk39.default.gray(age)
    ];
  });
  return formatTable(
    ["Domain", "Registrar", "Nameservers", "Expiration Date", "Creator", "Age"],
    ["l", "l", "l", "l", "l", "l"],
    [{ rows }]
  );
}

// src/commands/domains/rm.ts
var import_chalk40 = __toESM(require_source(), 1);
var import_pluralize6 = __toESM(require_pluralize(), 1);

// src/util/domains/remove-domain-by-name.ts
async function removeDomainByName(now, contextName, domain) {
  try {
    return await now.fetch(`/v3/domains/${encodeURIComponent(domain)}`, {
      method: "DELETE"
    });
  } catch (err) {
    if (isAPIError(err)) {
      if (err.code === "not_found") {
        return new DomainNotFound(domain);
      }
      if (err.code === "forbidden") {
        return new DomainPermissionDenied(domain, contextName);
      }
      if (err.code === "domain_removal_conflict") {
        return new DomainRemovalConflict({
          aliases: err.aliases,
          certs: err.certs,
          message: err.message,
          pendingAsyncPurchase: err.pendingAsyncPurchase,
          resolvable: err.resolvable,
          suffix: err.suffix,
          transferring: err.transferring
        });
      }
    }
    throw err;
  }
}

// src/util/domains/set-custom-suffix.ts
async function setCustomSuffix(client, contextName, domain, suffix) {
  try {
    return await client.fetch(`/v1/custom-suffix`, {
      method: "PATCH",
      body: {
        suffix
      }
    });
  } catch (err) {
    if (isAPIError(err)) {
      if (err.code === "forbidden") {
        return new DomainPermissionDenied(domain, contextName);
      }
      if (err.code === "domain_external") {
        return new DomainExternal(domain);
      }
      if (err.code === "domain_invalid") {
        return new InvalidDomain(domain);
      }
      if (err.code === "domain_not_found") {
        return new DomainNotFound(domain);
      }
      if (err.code === "domain_not_verified") {
        return new DomainNotVerified(domain);
      }
      if (err.code === "domain_permission_denied") {
        return new DomainPermissionDenied(domain, contextName);
      }
    }
    throw err;
  }
}

// src/util/telemetry/commands/domains/rm.ts
var DomainsRmTelemetryClient = class extends TelemetryClient {
  trackCliArgumentDomain(v) {
    if (v) {
      this.trackCliArgument({
        arg: "domain",
        value: this.redactedValue
      });
    }
  }
  trackCliFlagYes(v) {
    if (v) {
      this.trackCliFlag("yes");
    }
  }
};

// src/commands/domains/rm.ts
async function rm4(client, argv) {
  const telemetry2 = new DomainsRmTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(removeSubcommand4.options);
  try {
    parsedArgs = parseArguments(argv, flagsSpecification);
  } catch (error) {
    printError(error);
    return 1;
  }
  const { args, flags: opts } = parsedArgs;
  const [domainName] = args;
  telemetry2.trackCliArgumentDomain(domainName);
  telemetry2.trackCliFlagYes(opts["--yes"]);
  if (!domainName) {
    output_manager_default.error(
      `${getCommandName(`domains rm <domain>`)} expects one argument`
    );
    return 1;
  }
  const { contextName } = await getScope(client);
  if (args.length !== 1) {
    output_manager_default.error(
      `Invalid number of arguments. Usage: ${import_chalk40.default.cyan(
        `${getCommandName("domains rm <domain>")}`
      )}`
    );
    return 1;
  }
  const domain = await getDomainByName(client, contextName, domainName);
  if (domain instanceof DomainNotFound || domain.name !== domainName) {
    output_manager_default.error(
      `Domain not found by "${domainName}" under ${import_chalk40.default.bold(contextName)}`
    );
    output_manager_default.log(`Run ${getCommandName(`domains ls`)} to see your domains.`);
    return 1;
  }
  if (domain instanceof DomainPermissionDenied) {
    output_manager_default.error(
      `You don't have access to the domain ${domainName} under ${import_chalk40.default.bold(
        contextName
      )}`
    );
    output_manager_default.log(`Run ${getCommandName(`domains ls`)} to see your domains.`);
    return 1;
  }
  const projects = await findProjectsForDomain(client, domain.name);
  if (Array.isArray(projects) && projects.length > 0) {
    output_manager_default.warn(
      `The domain is currently used by ${(0, import_pluralize6.default)(
        "project",
        projects.length,
        true
      )}.`
    );
  }
  const skipConfirmation = opts["--yes"] || false;
  if (!skipConfirmation && !await client.input.confirm(
    `Are you sure you want to remove ${param(domainName)}?`,
    false
  )) {
    output_manager_default.log("Canceled");
    return 0;
  }
  return removeDomain(client, contextName, skipConfirmation, domain);
}
async function removeDomain(client, contextName, skipConfirmation, domain, aliasIds = [], certIds = [], suffix = false, attempt = 1) {
  const removeStamp = stamp_default();
  output_manager_default.debug(`Removing domain`);
  for (const id of aliasIds) {
    output_manager_default.debug(`Removing alias ${id}`);
    try {
      await removeAliasById(client, id);
    } catch (err) {
      if (!isAPIError(err) || err.status !== 404) {
        throw err;
      }
    }
  }
  for (const id of certIds) {
    output_manager_default.debug(`Removing cert ${id}`);
    try {
      await deleteCertById(client, id);
    } catch (err) {
      if (!isAPIError(err) || err.status !== 404) {
        throw err;
      }
    }
  }
  if (suffix) {
    output_manager_default.debug(`Removing custom suffix`);
    await setCustomSuffix(client, contextName, domain.name, null);
  }
  const removeResult = await removeDomainByName(
    client,
    contextName,
    domain.name
  );
  if (removeResult instanceof DomainNotFound) {
    output_manager_default.error(`Domain not found under ${import_chalk40.default.bold(contextName)}`);
    output_manager_default.log(`Run ${getCommandName(`domains ls`)} to see your domains.`);
    return 1;
  }
  if (removeResult instanceof DomainPermissionDenied) {
    output_manager_default.error(
      `You don't have permissions over domain ${import_chalk40.default.underline(
        removeResult.meta.domain
      )} under ${import_chalk40.default.bold(removeResult.meta.context)}.`
    );
    return 1;
  }
  if (removeResult instanceof DomainRemovalConflict) {
    if (attempt >= 2) {
      output_manager_default.error(removeResult.message);
      return 1;
    }
    const {
      aliases,
      certs,
      suffix: suffix2,
      transferring,
      pendingAsyncPurchase,
      resolvable
    } = removeResult.meta;
    if (transferring) {
      output_manager_default.error(
        `${param(
          domain.name
        )} transfer should be declined or approved before removing.`
      );
      return 1;
    }
    if (pendingAsyncPurchase) {
      output_manager_default.error(
        `Cannot remove ${param(
          domain.name
        )} because it is still in the process of being purchased.`
      );
      return 1;
    }
    if (!resolvable) {
      output_manager_default.error(removeResult.message);
      return 1;
    }
    output_manager_default.log(
      `We found conflicts when attempting to remove ${param(domain.name)}.`
    );
    if (aliases.length > 0) {
      output_manager_default.warn(
        `This domain's ${import_chalk40.default.bold(
          (0, import_pluralize6.default)("alias", aliases.length, true)
        )} will be removed. Run ${getCommandName(`alias ls`)} to list them.`
      );
    }
    if (certs.length > 0) {
      output_manager_default.warn(
        `This domain's ${import_chalk40.default.bold(
          (0, import_pluralize6.default)("certificate", certs.length, true)
        )} will be removed. Run ${getCommandName(`cert ls`)} to list them.`
      );
    }
    if (suffix2) {
      output_manager_default.warn(
        `The ${import_chalk40.default.bold(`custom suffix`)} associated with this domain.`
      );
    }
    if (!skipConfirmation && !await client.input.confirm(
      `Remove conflicts associated with domain?`,
      false
    )) {
      output_manager_default.log("Canceled");
      return 0;
    }
    return removeDomain(
      client,
      contextName,
      skipConfirmation,
      domain,
      aliases,
      certs,
      suffix2,
      attempt + 1
    );
  }
  output_manager_default.success(`Domain ${import_chalk40.default.bold(domain.name)} removed ${removeStamp()}`);
  return 0;
}

// src/commands/domains/move.ts
var import_chalk41 = __toESM(require_source(), 1);
var import_pluralize7 = __toESM(require_pluralize(), 1);

// src/util/domains/move-out-domain.ts
async function moveOutDomain(client, contextName, name, destination) {
  try {
    return await client.fetch(
      `/v4/domains/${encodeURIComponent(name)}`,
      {
        body: { op: "move-out", destination },
        method: "PATCH"
      }
    );
  } catch (err) {
    if (isAPIError(err)) {
      if (err.code === "forbidden") {
        return new DomainPermissionDenied(name, contextName);
      }
      if (err.code === "not_found") {
        return new DomainNotFound(name);
      }
      if (err.code === "invalid_move_destination") {
        return new InvalidMoveDestination(destination);
      }
      if (err.code === "domain_move_conflict") {
        const { pendingAsyncPurchase, resolvable, suffix, message } = err;
        return new DomainMoveConflict({
          message,
          pendingAsyncPurchase,
          resolvable,
          suffix
        });
      }
    }
    throw err;
  }
}

// src/util/alias/get-domain-aliases.ts
async function getDomainAliases(client, domain) {
  const { aliases } = await getAliases(client);
  return aliases.filter((alias2) => alias2.alias.endsWith(domain));
}

// src/util/telemetry/commands/domains/move.ts
var DomainsMoveTelemetryClient = class extends TelemetryClient {
  trackCliFlagYes(yes) {
    if (yes) {
      this.trackCliFlag("yes");
    }
  }
  trackCliArgumentDomain(domainName) {
    if (domainName) {
      this.trackCliArgument({
        arg: "domain",
        value: this.redactedValue
      });
    }
  }
  trackCliArgumentDestination(destination) {
    if (destination) {
      this.trackCliArgument({
        arg: "destination",
        value: this.redactedValue
      });
    }
  }
};

// src/commands/domains/move.ts
async function move(client, argv) {
  const telemetry2 = new DomainsMoveTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(moveSubcommand.options);
  try {
    parsedArgs = parseArguments(argv, flagsSpecification);
  } catch (error) {
    printError(error);
    return 1;
  }
  const { args, flags: opts } = parsedArgs;
  telemetry2.trackCliFlagYes(opts["--yes"]);
  telemetry2.trackCliArgumentDomain(args[0]);
  telemetry2.trackCliArgumentDestination(args[1]);
  const { contextName, user } = await getScope(client);
  const { domainName, destination } = await getArgs(client, args);
  if (!isRootDomain(domainName)) {
    output_manager_default.error(
      `Invalid domain name "${domainName}". Run ${getCommandName(
        `domains --help`
      )}`
    );
    return 1;
  }
  const domain = await getDomainByName(client, contextName, domainName);
  if (domain instanceof DomainNotFound) {
    output_manager_default.error(`Domain not found under ${import_chalk41.default.bold(contextName)}`);
    output_manager_default.log(`Run ${getCommandName(`domains ls`)} to see your domains.`);
    return 1;
  }
  if (domain instanceof DomainPermissionDenied) {
    output_manager_default.error(
      `You don't have permissions over domain ${import_chalk41.default.underline(
        domain.meta.domain
      )} under ${import_chalk41.default.bold(domain.meta.context)}.`
    );
    return 1;
  }
  const teams2 = await getTeams(client);
  const matchId = await findDestinationMatch(destination, user, teams2);
  if (matchId && matchId === user.id && user.version === "northstar") {
    output_manager_default.error(`You may not move your domain to your user account.`);
    return 1;
  }
  if (!matchId && !opts["--yes"]) {
    output_manager_default.warn(
      `You're not a member of ${param(destination)}. ${param(
        destination
      )} will have 24 hours to accept your move request before it expires.`
    );
    if (!await client.input.confirm(
      `Are you sure you want to move ${param(domainName)} to ${param(
        destination
      )}?`,
      false
    )) {
      output_manager_default.log("Canceled");
      return 0;
    }
  }
  if (!opts["--yes"]) {
    const aliases = await getDomainAliases(client, domainName);
    if (aliases.length > 0) {
      output_manager_default.warn(
        `This domain's ${import_chalk41.default.bold(
          (0, import_pluralize7.default)("alias", aliases.length, true)
        )} will be removed. Run ${getCommandName(`alias ls`)} to list them.`
      );
      if (!await client.input.confirm(
        `Are you sure you want to move ${param(domainName)}?`,
        false
      )) {
        output_manager_default.log("Canceled");
        return 0;
      }
    }
  }
  const context = contextName;
  output_manager_default.spinner("Moving");
  const moveTokenResult = await moveOutDomain(
    client,
    context,
    domainName,
    matchId || destination
  );
  if (moveTokenResult instanceof DomainMoveConflict) {
    const { suffix, pendingAsyncPurchase } = moveTokenResult.meta;
    if (suffix) {
      output_manager_default.error(
        `Please remove custom suffix for ${param(domainName)} before moving out`
      );
      return 1;
    }
    if (pendingAsyncPurchase) {
      output_manager_default.error(
        `Cannot remove ${param(
          domain.name
        )} because it is still in the process of being purchased.`
      );
      return 1;
    }
    output_manager_default.error(moveTokenResult.message);
    return 1;
  }
  if (moveTokenResult instanceof DomainNotFound) {
    output_manager_default.error(`Domain not found under ${import_chalk41.default.bold(contextName)}`);
    output_manager_default.log(`Run ${getCommandName(`domains ls`)} to see your domains.`);
    return 1;
  }
  if (moveTokenResult instanceof DomainPermissionDenied) {
    output_manager_default.error(
      `You don't have permissions over domain ${import_chalk41.default.underline(
        moveTokenResult.meta.domain
      )} under ${import_chalk41.default.bold(moveTokenResult.meta.context)}.`
    );
    return 1;
  }
  if (moveTokenResult instanceof InvalidMoveDestination) {
    output_manager_default.error(
      `Destination ${import_chalk41.default.bold(
        destination
      )} is invalid. Please supply a valid username, email, team slug, user id, or team id.`
    );
    return 1;
  }
  const { moved } = moveTokenResult;
  if (moved) {
    output_manager_default.success(`${param(domainName)} was moved to ${param(destination)}.`);
  } else {
    output_manager_default.success(
      `Sent ${param(destination)} an email to approve the ${param(
        domainName
      )} move request.`
    );
  }
  return 0;
}
async function getArgs(client, args) {
  let [domainName, destination] = args;
  if (!domainName) {
    domainName = await client.input.text({
      message: `- Domain name: `,
      validate: isRootDomain
    });
  }
  if (!destination) {
    destination = await client.input.text({
      message: `- Destination: `,
      validate: (v) => Boolean(v && v.length > 0)
    });
  }
  return { domainName, destination };
}
async function findDestinationMatch(destination, user, teams2) {
  if (user.id === destination || user.username === destination) {
    return user.id;
  }
  for (const team of teams2) {
    if (team.id === destination || team.slug === destination) {
      return team.id;
    }
  }
  return null;
}

// src/util/telemetry/commands/domains/index.ts
var DomainsTelemetryClient = class extends TelemetryClient {
  trackCliSubcommandAdd(actual) {
    this.trackCliSubcommand({
      subcommand: "add",
      value: actual
    });
  }
  trackCliSubcommandInspect(actual) {
    this.trackCliSubcommand({
      subcommand: "inspect",
      value: actual
    });
  }
  trackCliSubcommandMove(actual) {
    this.trackCliSubcommand({
      subcommand: "move",
      value: actual
    });
  }
  trackCliSubcommandBuy(actual) {
    this.trackCliSubcommand({
      subcommand: "buy",
      value: actual
    });
  }
  trackCliSubcommandRemove(actual) {
    this.trackCliSubcommand({
      subcommand: "remove",
      value: actual
    });
  }
  trackCliSubcommandTransferIn(actual) {
    this.trackCliSubcommand({
      subcommand: "transfer-in",
      value: actual
    });
  }
  trackCliSubcommandList(actual) {
    this.trackCliSubcommand({
      subcommand: "list",
      value: actual
    });
  }
};

// src/commands/domains/index.ts
var COMMAND_CONFIG7 = {
  add: ["add"],
  buy: ["buy"],
  inspect: ["inspect"],
  ls: ["ls", "list"],
  move: ["move"],
  rm: ["rm", "remove"],
  transferIn: ["transfer-in"]
};
async function main5(client) {
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(domainsCommand.options);
  try {
    parsedArgs = parseArguments(client.argv.slice(2), flagsSpecification, {
      permissive: true
    });
  } catch (error) {
    printError(error);
    return 1;
  }
  const telemetry2 = new DomainsTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  const { subcommand, args, subcommandOriginal } = getSubcommand3(
    parsedArgs.args.slice(1),
    COMMAND_CONFIG7
  );
  const needHelp = parsedArgs.flags["--help"];
  if (!subcommand && needHelp) {
    telemetry2.trackCliFlagHelp("domains");
    output_manager_default.print(help(domainsCommand, { columns: client.stderr.columns }));
    return 2;
  }
  function printHelp(command) {
    output_manager_default.print(
      help(command, { parent: domainsCommand, columns: client.stderr.columns })
    );
    return 2;
  }
  switch (subcommand) {
    case "add":
      if (needHelp) {
        telemetry2.trackCliFlagHelp("domains", subcommandOriginal);
        return printHelp(addSubcommand3);
      }
      telemetry2.trackCliSubcommandAdd(subcommandOriginal);
      return add3(client, args);
    case "inspect":
      if (needHelp) {
        telemetry2.trackCliFlagHelp("domains", subcommandOriginal);
        return printHelp(inspectSubcommand);
      }
      telemetry2.trackCliSubcommandInspect(subcommandOriginal);
      return inspect(client, args);
    case "move":
      if (needHelp) {
        telemetry2.trackCliFlagHelp("domains", subcommandOriginal);
        return printHelp(moveSubcommand);
      }
      telemetry2.trackCliSubcommandMove(subcommandOriginal);
      return move(client, args);
    case "buy":
      if (needHelp) {
        telemetry2.trackCliFlagHelp("domains", subcommandOriginal);
        return printHelp(buySubcommand);
      }
      telemetry2.trackCliSubcommandBuy(subcommandOriginal);
      return buy(client, args);
    case "rm":
      if (needHelp) {
        telemetry2.trackCliFlagHelp("domains", subcommandOriginal);
        return printHelp(removeSubcommand4);
      }
      telemetry2.trackCliSubcommandRemove(subcommandOriginal);
      return rm4(client, args);
    case "transferIn":
      if (needHelp) {
        telemetry2.trackCliFlagHelp("domains", subcommandOriginal);
        return printHelp(transferInSubcommand);
      }
      telemetry2.trackCliSubcommandTransferIn(subcommandOriginal);
      return transferIn(client, args);
    default:
      if (needHelp) {
        telemetry2.trackCliFlagHelp("domains", subcommandOriginal);
        return printHelp(transferInSubcommand);
      }
      telemetry2.trackCliSubcommandList(subcommandOriginal);
      return ls4(client, args);
  }
}

// src/util/telemetry/commands/flags/index.ts
var FlagsTelemetryClient = class extends TelemetryClient {
  trackCliSubcommandList(actual) {
    this.trackCliSubcommand({
      subcommand: "ls",
      value: actual
    });
  }
  trackCliSubcommandInspect(actual) {
    this.trackCliSubcommand({
      subcommand: "inspect",
      value: actual
    });
  }
  trackCliSubcommandAdd(actual) {
    this.trackCliSubcommand({
      subcommand: "add",
      value: actual
    });
  }
  trackCliSubcommandRemove(actual) {
    this.trackCliSubcommand({
      subcommand: "rm",
      value: actual
    });
  }
  trackCliSubcommandArchive(actual) {
    this.trackCliSubcommand({
      subcommand: "archive",
      value: actual
    });
  }
  trackCliSubcommandDisable(actual) {
    this.trackCliSubcommand({
      subcommand: "disable",
      value: actual
    });
  }
  trackCliSubcommandEnable(actual) {
    this.trackCliSubcommand({
      subcommand: "enable",
      value: actual
    });
  }
  trackCliSubcommandSdkKeys(actual) {
    this.trackCliSubcommand({
      subcommand: "sdk-keys",
      value: actual
    });
  }
  trackCliSubcommandPrepare(actual) {
    this.trackCliSubcommand({
      subcommand: "prepare",
      value: actual
    });
  }
};

// src/commands/flags/ls.ts
var import_chalk42 = __toESM(require_source(), 1);
var import_ms11 = __toESM(require_ms(), 1);
var import_pluralize8 = __toESM(require_pluralize(), 1);

// src/util/flags/get-flags.ts
async function getFlags(client, projectId, state = "active") {
  output_manager_default.debug(`Fetching feature flags for project ${projectId}`);
  const url = `/v1/projects/${encodeURIComponent(projectId)}/feature-flags/flags?state=${state}`;
  const response = await client.fetch(url);
  return response.data;
}
async function getFlag(client, projectId, flagIdOrSlug) {
  output_manager_default.debug(
    `Fetching feature flag ${flagIdOrSlug} for project ${projectId}`
  );
  const url = `/v1/projects/${encodeURIComponent(projectId)}/feature-flags/flags/${encodeURIComponent(flagIdOrSlug)}`;
  const response = await client.fetch(url);
  return response;
}
async function getFlagSettings(client, projectId) {
  output_manager_default.debug(`Fetching feature flag settings for project ${projectId}`);
  const url = `/v1/projects/${encodeURIComponent(projectId)}/feature-flags/settings`;
  const response = await client.fetch(url);
  return response;
}

// src/util/telemetry/commands/flags/ls.ts
var FlagsLsTelemetryClient = class extends TelemetryClient {
  trackCliOptionState(state) {
    if (state) {
      this.trackCliOption({
        option: "state",
        value: state
      });
    }
  }
  trackCliFlagJson(json) {
    if (json) {
      this.trackCliFlag("json");
    }
  }
};

// src/commands/flags/ls.ts
async function ls5(client, argv) {
  const telemetryClient = new FlagsLsTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(listSubcommand6.options);
  try {
    parsedArgs = parseArguments(argv, flagsSpecification);
  } catch (err) {
    printError(err);
    return 1;
  }
  const { flags } = parsedArgs;
  const state = flags["--state"] || "active";
  const json = flags["--json"];
  telemetryClient.trackCliOptionState(state);
  telemetryClient.trackCliFlagJson(json);
  const link = await getLinkedProject(client);
  if (link.status === "error") {
    return link.exitCode;
  } else if (link.status === "not_linked") {
    output_manager_default.error(
      `Your codebase isn't linked to a project on Vercel. Run ${getCommandName("link")} to begin.`
    );
    return 1;
  }
  client.config.currentTeam = link.org.type === "team" ? link.org.id : void 0;
  const { project, org } = link;
  const projectSlugLink = formatProject(org.slug, project.name);
  const lsStamp = stamp_default();
  output_manager_default.spinner(`Fetching ${state} feature flags for ${projectSlugLink}`);
  try {
    const flagsList = await getFlags(client, project.id, state);
    output_manager_default.stopSpinner();
    const sortedFlags = flagsList.sort((a, b) => b.updatedAt - a.updatedAt);
    if (json) {
      outputJson(client, sortedFlags);
    } else if (flagsList.length === 0) {
      output_manager_default.log(
        `No ${state} feature flags found for ${projectSlugLink} ${import_chalk42.default.gray(lsStamp())}`
      );
    } else {
      output_manager_default.log(
        `${(0, import_pluralize8.default)("feature flag", flagsList.length, true)} found for ${projectSlugLink} ${import_chalk42.default.gray(lsStamp())}`
      );
      printFlagsTable(sortedFlags);
    }
  } catch (err) {
    output_manager_default.stopSpinner();
    printError(err);
    return 1;
  }
  return 0;
}
function outputJson(client, flags) {
  const jsonOutput = {
    flags: flags.map((flag) => ({
      id: flag.id,
      slug: flag.slug,
      description: flag.description ?? null,
      kind: flag.kind,
      state: flag.state,
      variants: flag.variants,
      createdAt: flag.createdAt,
      updatedAt: flag.updatedAt
    }))
  };
  client.stdout.write(`${JSON.stringify(jsonOutput, null, 2)}
`);
}
function printFlagsTable(flags) {
  const headers = ["Name", "Kind", "State", "Variants", "Updated"];
  const now = Date.now();
  const rows = flags.map((flag) => [
    import_chalk42.default.bold(flag.slug),
    flag.kind,
    flag.state === "active" ? import_chalk42.default.green(flag.state) : import_chalk42.default.gray(flag.state),
    String(flag.variants.length),
    (0, import_ms11.default)(now - flag.updatedAt) + " ago"
  ]);
  const table3 = formatTable(
    headers,
    ["l", "l", "l", "r", "l"],
    [{ name: "", rows }]
  );
  output_manager_default.print(`
${table3}
`);
}

// src/commands/flags/inspect.ts
var import_chalk43 = __toESM(require_source(), 1);

// src/util/flags/dashboard-url.ts
function getFlagDashboardUrl(orgSlug, projectName, flagSlug) {
  return `https://vercel.com/${orgSlug}/${projectName}/flag/${flagSlug}`;
}
function getFlagsDashboardUrl(orgSlug, projectName) {
  return `https://vercel.com/${orgSlug}/${projectName}/flags`;
}

// src/util/telemetry/commands/flags/inspect.ts
var FlagsInspectTelemetryClient = class extends TelemetryClient {
  trackCliArgumentFlag(flag) {
    if (flag) {
      this.trackCliArgument({
        arg: "flag",
        value: this.redactedValue
      });
    }
  }
};

// src/commands/flags/inspect.ts
async function inspect2(client, argv) {
  const telemetryClient = new FlagsInspectTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(inspectSubcommand2.options);
  try {
    parsedArgs = parseArguments(argv, flagsSpecification);
  } catch (err) {
    printError(err);
    return 1;
  }
  const { args } = parsedArgs;
  const [flagArg] = args;
  if (!flagArg) {
    output_manager_default.error(
      `Missing required argument: flag. Usage: ${getCommandName("flags inspect <flag>")}`
    );
    return 1;
  }
  telemetryClient.trackCliArgumentFlag(flagArg);
  const link = await getLinkedProject(client);
  if (link.status === "error") {
    return link.exitCode;
  } else if (link.status === "not_linked") {
    output_manager_default.error(
      `Your codebase isn't linked to a project on Vercel. Run ${getCommandName("link")} to begin.`
    );
    return 1;
  }
  client.config.currentTeam = link.org.type === "team" ? link.org.id : void 0;
  const { project, org } = link;
  const projectSlugLink = formatProject(org.slug, project.name);
  try {
    const [flag, settings] = await Promise.all([
      getFlag(client, project.id, flagArg),
      getFlagSettings(client, project.id)
    ]);
    printFlagDetails(flag, settings, projectSlugLink, org.slug, project.name);
  } catch (err) {
    printError(err);
    return 1;
  }
  return 0;
}
function resolveTargetingLabel(settings, entityKind, attribute, value) {
  const entity = settings.entities.find((e2) => e2.kind === entityKind);
  if (!entity)
    return void 0;
  const attr = entity.attributes.find((a) => a.key === attribute);
  if (!attr?.labels)
    return void 0;
  const labelEntry = attr.labels.find((l) => l.value === value);
  return labelEntry?.label;
}
function formatRuleOutcome(outcome, variants) {
  if (outcome.type === "variant") {
    const variant = variants.find((v) => v.id === outcome.variantId);
    return variant?.label || outcome.variantId;
  } else if (outcome.type === "split") {
    const weights = Object.entries(outcome.weights).map(([id, weight]) => {
      const variant = variants.find((v) => v.id === id);
      const label = variant?.label || id;
      return `${label}: ${weight}%`;
    }).join(", ");
    return `split (${weights})`;
  }
  return "unknown";
}
function formatCondition(condition, settings) {
  let lhs;
  if (condition.lhs.type === "segment") {
    lhs = "segment";
  } else {
    lhs = `${condition.lhs.kind}.${condition.lhs.attribute}`;
  }
  const cmp = import_chalk43.default.dim(formatComparison(condition.cmp));
  if (condition.rhs === void 0 || condition.rhs === null) {
    return { text: `${lhs} ${cmp}` };
  }
  if (typeof condition.rhs === "object") {
    if (condition.rhs.type === "list" && Array.isArray(condition.rhs.items)) {
      const items = condition.rhs.items.map((item) => {
        const itemValue = typeof item === "object" && item !== null && "value" in item ? String(item.value) : String(item);
        if (condition.lhs.type === "entity") {
          const label = resolveTargetingLabel(
            settings,
            condition.lhs.kind,
            condition.lhs.attribute,
            itemValue
          );
          return label ? `${itemValue} ${import_chalk43.default.gray(label)}` : itemValue;
        }
        return itemValue;
      });
      return { text: `${lhs} ${cmp}`, listItems: items };
    }
    return { text: `${lhs} ${cmp} ${JSON.stringify(condition.rhs)}` };
  }
  let rhs;
  if (condition.lhs.type === "entity") {
    const label = resolveTargetingLabel(
      settings,
      condition.lhs.kind,
      condition.lhs.attribute,
      String(condition.rhs)
    );
    rhs = label ? `${condition.rhs} ${import_chalk43.default.gray(label)}` : String(condition.rhs);
  } else {
    rhs = String(condition.rhs);
  }
  return { text: `${lhs} ${cmp} ${rhs}` };
}
function formatComparison(cmp) {
  const operators = {
    eq: "is",
    oneOf: "is in",
    gt: "is greater than",
    gte: "is greater than or equal to",
    lt: "is less than",
    lte: "is less than or equal to",
    ex: "has any value",
    "!ex": "has no value",
    startsWith: "starts with",
    endsWith: "ends with",
    containsAnyOf: "contains any of",
    containsAllOf: "contains all of",
    containsNoneOf: "contains none of"
  };
  return operators[cmp] || cmp;
}
function printFlagDetails(flag, settings, projectSlugLink, orgSlug, projectName) {
  const dashboardUrl = getFlagDashboardUrl(orgSlug, projectName, flag.slug);
  output_manager_default.log(
    `
Feature flag ${import_chalk43.default.bold(flag.slug)} for ${projectSlugLink}
`
  );
  output_manager_default.print(`  ${import_chalk43.default.cyan(dashboardUrl)}

`);
  output_manager_default.print(`  ${import_chalk43.default.dim("ID:")}           ${flag.id}
`);
  output_manager_default.print(`  ${import_chalk43.default.dim("Kind:")}         ${flag.kind}
`);
  output_manager_default.print(
    `  ${import_chalk43.default.dim("State:")}        ${flag.state === "active" ? import_chalk43.default.green(flag.state) : import_chalk43.default.gray(flag.state)}
`
  );
  if (flag.description) {
    output_manager_default.print(`  ${import_chalk43.default.dim("Description:")}  ${flag.description}
`);
  }
  output_manager_default.print(
    `  ${import_chalk43.default.dim("Created:")}      ${formatDate(flag.createdAt)}
`
  );
  output_manager_default.print(
    `  ${import_chalk43.default.dim("Updated:")}      ${formatDate(flag.updatedAt)}
`
  );
  output_manager_default.print(`
  ${import_chalk43.default.dim("Variants:")}
`);
  for (const variant of flag.variants) {
    output_manager_default.print(`    ${import_chalk43.default.cyan(variant.id)}
`);
    if (variant.label) {
      output_manager_default.print(`      ${import_chalk43.default.dim("Label:")} ${variant.label}
`);
    }
    output_manager_default.print(
      `      ${import_chalk43.default.dim("Value:")} ${import_chalk43.default.yellow(JSON.stringify(variant.value))}
`
    );
  }
  const envOrder = ["production", "preview", "development"];
  const sortedEnvs = Object.entries(flag.environments).sort(([a], [b]) => {
    const aIndex = envOrder.indexOf(a);
    const bIndex = envOrder.indexOf(b);
    if (aIndex === -1 && bIndex === -1)
      return a.localeCompare(b);
    if (aIndex === -1)
      return 1;
    if (bIndex === -1)
      return -1;
    return aIndex - bIndex;
  });
  output_manager_default.print(`
  ${import_chalk43.default.dim("Environments:")}
`);
  for (const [envName, envConfig] of sortedEnvs) {
    if (envConfig.active) {
      if (envConfig.reuse?.active) {
        output_manager_default.print(
          `    ${import_chalk43.default.bold(envName)}: reuses ${import_chalk43.default.cyan(envConfig.reuse.environment)} environment
`
        );
        continue;
      }
      output_manager_default.print(`    ${import_chalk43.default.bold(envName)}: ${import_chalk43.default.green("active")}
`);
      if (envConfig.targets && Object.keys(envConfig.targets).length > 0) {
        output_manager_default.print(`      ${import_chalk43.default.dim("Targeting:")}
`);
        for (const [variantId2, entityKinds] of Object.entries(
          envConfig.targets
        )) {
          const variant = flag.variants.find((v) => v.id === variantId2);
          const variantLabel = variant?.label || variantId2;
          for (const [entityKind, attributes] of Object.entries(entityKinds)) {
            for (const [attribute, values] of Object.entries(attributes)) {
              const valueList = values.map((v) => {
                const label = resolveTargetingLabel(
                  settings,
                  entityKind,
                  attribute,
                  v.value
                );
                return label ? `${v.value} ${import_chalk43.default.gray(label)}` : v.value;
              }).join(", ");
              output_manager_default.print(
                `        ${import_chalk43.default.dim(`${entityKind}.${attribute}:`)} ${valueList} ${import_chalk43.default.dim("\u2192")} ${variantLabel}
`
              );
            }
          }
        }
      }
      if (envConfig.rules && envConfig.rules.length > 0) {
        output_manager_default.print(`      ${import_chalk43.default.dim("Rules:")}
`);
        for (const rule of envConfig.rules) {
          const outcome = formatRuleOutcome(rule.outcome, flag.variants);
          output_manager_default.print(`        ${import_chalk43.default.dim("\u2192")} ${outcome}
`);
          for (const condition of rule.conditions) {
            const { text, listItems } = formatCondition(condition, settings);
            output_manager_default.print(`          ${import_chalk43.default.dim("if")} ${text}
`);
            if (listItems && listItems.length > 0) {
              for (const item of listItems) {
                output_manager_default.print(`             ${import_chalk43.default.dim("-")} ${item}
`);
              }
            }
          }
        }
      }
      if (envConfig.fallthrough) {
        const fallthrough = envConfig.fallthrough;
        if (fallthrough.type === "variant") {
          const defaultVariant = flag.variants.find(
            (v) => v.id === fallthrough.variantId
          );
          const defaultLabel = defaultVariant?.label || fallthrough.variantId;
          output_manager_default.print(`      ${import_chalk43.default.dim("Default:")} ${defaultLabel}
`);
        } else if (fallthrough.type === "split") {
          const weights = Object.entries(fallthrough.weights).map(([id, weight]) => {
            const variant = flag.variants.find((v) => v.id === id);
            const label = variant?.label || id;
            return `${label}: ${weight}%`;
          }).join(", ");
          output_manager_default.print(`      ${import_chalk43.default.dim("Default split:")} ${weights}
`);
        }
      }
    } else {
      output_manager_default.print(`    ${import_chalk43.default.bold(envName)}: ${import_chalk43.default.yellow("paused")}
`);
    }
  }
  output_manager_default.print("\n");
}

// src/commands/flags/add.ts
var import_chalk44 = __toESM(require_source(), 1);
import { randomBytes } from "crypto";

// src/util/flags/create-flag.ts
async function createFlag(client, projectId, request) {
  const url = `/v1/projects/${encodeURIComponent(projectId)}/feature-flags/flags`;
  output_manager_default.debug(
    `Creating feature flag ${request.slug} for project ${projectId}`
  );
  output_manager_default.debug(`API endpoint: PUT ${url}`);
  output_manager_default.debug(`Request body: ${JSON.stringify(request, null, 2)}`);
  try {
    const response = await client.fetch(url, {
      method: "PUT",
      body: request
    });
    output_manager_default.debug(`Response: ${JSON.stringify(response, null, 2)}`);
    return response;
  } catch (err) {
    output_manager_default.debug(`API error occurred`);
    if (err instanceof Error) {
      output_manager_default.debug(`Error message: ${err.message}`);
      output_manager_default.debug(`Error name: ${err.name}`);
      output_manager_default.debug(`Error stack: ${err.stack}`);
      const errWithBody = err;
      if (errWithBody.status) {
        output_manager_default.debug(`Error status: ${errWithBody.status}`);
      }
      if (errWithBody.body) {
        output_manager_default.debug(
          `Error body: ${JSON.stringify(errWithBody.body, null, 2)}`
        );
      }
    }
    throw err;
  }
}

// src/util/telemetry/commands/flags/add.ts
var FlagsAddTelemetryClient = class extends TelemetryClient {
  trackCliArgumentSlug(slug) {
    if (slug) {
      this.trackCliArgument({
        arg: "slug",
        value: this.redactedValue
      });
    }
  }
  trackCliOptionKind(kind) {
    if (kind) {
      this.trackCliOption({
        option: "kind",
        value: kind
      });
    }
  }
  trackCliOptionDescription(description) {
    if (description) {
      this.trackCliOption({
        option: "description",
        value: this.redactedValue
      });
    }
  }
};

// src/commands/flags/add.ts
function variantId(size = 21) {
  const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  const bytes4 = randomBytes(size);
  let id = "";
  for (let i = 0; i < size; i++) {
    id += alphabet[bytes4[i] % alphabet.length];
  }
  return id;
}
async function add4(client, argv) {
  const telemetryClient = new FlagsAddTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(addSubcommand4.options);
  try {
    parsedArgs = parseArguments(argv, flagsSpecification);
  } catch (err) {
    printError(err);
    return 1;
  }
  const { args, flags } = parsedArgs;
  const [slug] = args;
  if (!slug) {
    output_manager_default.error("Please provide a slug for the feature flag");
    output_manager_default.log(`Example: ${getCommandName("flags add my-feature")}`);
    return 1;
  }
  const kind = flags["--kind"] || "boolean";
  const description = flags["--description"];
  telemetryClient.trackCliArgumentSlug(slug);
  telemetryClient.trackCliOptionKind(kind);
  telemetryClient.trackCliOptionDescription(description);
  if (kind !== "boolean" && kind !== "string" && kind !== "number") {
    output_manager_default.error(
      `Invalid kind: ${kind}. Must be one of: boolean, string, number`
    );
    return 1;
  }
  const link = await getLinkedProject(client);
  if (link.status === "error") {
    return link.exitCode;
  } else if (link.status === "not_linked") {
    output_manager_default.error(
      `Your codebase isn't linked to a project on Vercel. Run ${getCommandName("link")} to begin.`
    );
    return 1;
  }
  client.config.currentTeam = link.org.type === "team" ? link.org.id : void 0;
  const { project } = link;
  const defaultVariants = getDefaultVariants(kind);
  const defaultEnvConfig = {
    revision: 0,
    active: false,
    pausedOutcome: {
      type: "variant",
      variantId: defaultVariants[0].id
    },
    fallthrough: {
      type: "variant",
      variantId: defaultVariants[0].id
    },
    rules: [],
    reuse: {
      active: false,
      environment: ""
    }
  };
  const request = {
    slug,
    kind,
    description: description || "",
    variants: defaultVariants,
    environments: {
      production: defaultEnvConfig,
      preview: defaultEnvConfig,
      development: defaultEnvConfig
    }
  };
  try {
    output_manager_default.spinner("Creating feature flag...");
    const flag = await createFlag(client, project.id, request);
    output_manager_default.stopSpinner();
    output_manager_default.success(
      `Feature flag ${import_chalk44.default.bold(flag.slug)} created successfully`
    );
    output_manager_default.log(`
  ${import_chalk44.default.dim("ID:")}    ${flag.id}`);
    output_manager_default.log(`  ${import_chalk44.default.dim("Kind:")}  ${flag.kind}`);
    output_manager_default.log(`  ${import_chalk44.default.dim("Slug:")}  ${flag.slug}
`);
    output_manager_default.log(
      `View in dashboard: ${import_chalk44.default.cyan(getFlagDashboardUrl(link.org.slug, project.name, flag.slug))}`
    );
  } catch (err) {
    output_manager_default.stopSpinner();
    printError(err);
    return 1;
  }
  return 0;
}
function getDefaultVariants(kind) {
  switch (kind) {
    case "boolean":
      return [
        { id: variantId(), value: false, label: "Off", description: "" },
        { id: variantId(), value: true, label: "On", description: "" }
      ];
    case "string":
      return [
        {
          id: variantId(),
          value: "value-1",
          label: "Value 1",
          description: ""
        },
        {
          id: variantId(),
          value: "value-2",
          label: "Value 2",
          description: ""
        }
      ];
    case "number":
      return [
        { id: variantId(), value: 0, label: "Off", description: "" },
        { id: variantId(), value: 1, label: "On", description: "" }
      ];
  }
}

// src/commands/flags/rm.ts
var import_chalk45 = __toESM(require_source(), 1);

// src/util/flags/delete-flag.ts
async function deleteFlag(client, projectId, flagIdOrSlug) {
  output_manager_default.debug(
    `Deleting feature flag ${flagIdOrSlug} for project ${projectId}`
  );
  const url = `/v1/projects/${encodeURIComponent(projectId)}/feature-flags/flags/${encodeURIComponent(flagIdOrSlug)}`;
  await client.fetch(url, {
    method: "DELETE"
  });
}

// src/util/telemetry/commands/flags/rm.ts
var FlagsRmTelemetryClient = class extends TelemetryClient {
  trackCliArgumentFlag(flag) {
    if (flag) {
      this.trackCliArgument({
        arg: "flag",
        value: this.redactedValue
      });
    }
  }
  trackCliFlagYes(yes) {
    if (yes) {
      this.trackCliFlag("yes");
    }
  }
};

// src/commands/flags/rm.ts
async function rm5(client, argv) {
  const telemetryClient = new FlagsRmTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(removeSubcommand5.options);
  try {
    parsedArgs = parseArguments(argv, flagsSpecification);
  } catch (err) {
    printError(err);
    return 1;
  }
  const { args, flags } = parsedArgs;
  const [flagArg] = args;
  const skipConfirmation = flags["--yes"];
  if (!flagArg) {
    output_manager_default.error("Please provide a flag slug or ID to delete");
    output_manager_default.log(`Example: ${getCommandName("flags rm my-feature")}`);
    return 1;
  }
  telemetryClient.trackCliArgumentFlag(flagArg);
  telemetryClient.trackCliFlagYes(skipConfirmation);
  const link = await getLinkedProject(client);
  if (link.status === "error") {
    return link.exitCode;
  } else if (link.status === "not_linked") {
    output_manager_default.error(
      `Your codebase isn't linked to a project on Vercel. Run ${getCommandName("link")} to begin.`
    );
    return 1;
  }
  client.config.currentTeam = link.org.type === "team" ? link.org.id : void 0;
  const { project } = link;
  try {
    output_manager_default.spinner("Fetching flag...");
    const flag = await getFlag(client, project.id, flagArg);
    output_manager_default.stopSpinner();
    if (flag.state !== "archived") {
      output_manager_default.error(
        `Flag ${import_chalk45.default.bold(flag.slug)} must be archived before it can be deleted. Run ${getCommandName(`flags archive ${flag.slug}`)} first.`
      );
      return 1;
    }
    if (!skipConfirmation) {
      const confirmed = await client.input.confirm(
        `Are you sure you want to delete ${import_chalk45.default.bold(flag.slug)}? This action cannot be undone.`,
        false
      );
      if (!confirmed) {
        output_manager_default.log("Aborted");
        return 0;
      }
    }
    output_manager_default.spinner("Deleting flag...");
    await deleteFlag(client, project.id, flagArg);
    output_manager_default.stopSpinner();
    output_manager_default.success(`Feature flag ${import_chalk45.default.bold(flag.slug)} has been deleted`);
  } catch (err) {
    output_manager_default.stopSpinner();
    printError(err);
    return 1;
  }
  return 0;
}

// src/commands/flags/archive.ts
var import_chalk46 = __toESM(require_source(), 1);

// src/util/flags/update-flag.ts
async function updateFlag(client, projectId, flagIdOrSlug, request) {
  output_manager_default.debug(
    `Updating feature flag ${flagIdOrSlug} for project ${projectId}`
  );
  const url = `/v1/projects/${encodeURIComponent(projectId)}/feature-flags/flags/${encodeURIComponent(flagIdOrSlug)}`;
  const response = await client.fetch(url, {
    method: "PATCH",
    body: request
  });
  return response;
}

// src/util/telemetry/commands/flags/archive.ts
var FlagsArchiveTelemetryClient = class extends TelemetryClient {
  trackCliArgumentFlag(flag) {
    if (flag) {
      this.trackCliArgument({
        arg: "flag",
        value: this.redactedValue
      });
    }
  }
  trackCliFlagYes(yes) {
    if (yes) {
      this.trackCliFlag("yes");
    }
  }
};

// src/commands/flags/archive.ts
async function archive(client, argv) {
  const telemetryClient = new FlagsArchiveTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(archiveSubcommand.options);
  try {
    parsedArgs = parseArguments(argv, flagsSpecification);
  } catch (err) {
    printError(err);
    return 1;
  }
  const { args, flags } = parsedArgs;
  const [flagArg] = args;
  const skipConfirmation = flags["--yes"];
  if (!flagArg) {
    output_manager_default.error("Please provide a flag slug or ID to archive");
    output_manager_default.log(`Example: ${getCommandName("flags archive my-feature")}`);
    return 1;
  }
  telemetryClient.trackCliArgumentFlag(flagArg);
  telemetryClient.trackCliFlagYes(skipConfirmation);
  const link = await getLinkedProject(client);
  if (link.status === "error") {
    return link.exitCode;
  } else if (link.status === "not_linked") {
    output_manager_default.error(
      `Your codebase isn't linked to a project on Vercel. Run ${getCommandName("link")} to begin.`
    );
    return 1;
  }
  client.config.currentTeam = link.org.type === "team" ? link.org.id : void 0;
  const { project } = link;
  try {
    output_manager_default.spinner("Fetching flag...");
    const flag = await getFlag(client, project.id, flagArg);
    output_manager_default.stopSpinner();
    if (flag.state === "archived") {
      output_manager_default.warn(`Flag ${import_chalk46.default.bold(flag.slug)} is already archived`);
      return 0;
    }
    if (!skipConfirmation) {
      const confirmed = await client.input.confirm(
        `Are you sure you want to archive ${import_chalk46.default.bold(flag.slug)}?`,
        false
      );
      if (!confirmed) {
        output_manager_default.log("Aborted");
        return 0;
      }
    }
    output_manager_default.spinner("Archiving flag...");
    await updateFlag(client, project.id, flagArg, {
      state: "archived",
      message: "Archived via CLI"
    });
    output_manager_default.stopSpinner();
    output_manager_default.success(`Feature flag ${import_chalk46.default.bold(flag.slug)} has been archived`);
    output_manager_default.log(
      `
To restore this flag, visit the dashboard: ${import_chalk46.default.cyan(getFlagsDashboardUrl(link.org.slug, project.name) + "/archive")}`
    );
  } catch (err) {
    output_manager_default.stopSpinner();
    printError(err);
    return 1;
  }
  return 0;
}

// src/commands/flags/disable.ts
var import_chalk47 = __toESM(require_source(), 1);

// src/util/flags/resolve-variant.ts
function formatAvailableVariants(variants) {
  return variants.map((v) => {
    const label = v.label ? ` (${v.label})` : "";
    return `  - ${JSON.stringify(v.value)}${label}`;
  }).join("\n");
}
function resolveVariant(input, variants) {
  const byId = variants.find((v) => v.id === input);
  if (byId) {
    return { variant: byId, error: null };
  }
  const byExactValue = variants.find((v) => v.value === input);
  if (byExactValue) {
    return { variant: byExactValue, error: null };
  }
  const parsedInput = parseVariantValue(input);
  const byValue = variants.find((v) => valuesMatch(v.value, parsedInput));
  if (byValue) {
    return { variant: byValue, error: null };
  }
  const inputLower = input.toLowerCase();
  const byLabel = variants.find((v) => v.label?.toLowerCase() === inputLower);
  if (byLabel) {
    return { variant: byLabel, error: null };
  }
  const availableList = formatAvailableVariants(variants);
  const error = `Variant "${input}" not found.

Available variants:
${availableList}

You can specify a variant by its value (e.g., "true", "false") or label.`;
  return { variant: null, error };
}
function parseVariantValue(input) {
  const lowerInput = input.toLowerCase();
  if (lowerInput === "true") {
    return true;
  }
  if (lowerInput === "false") {
    return false;
  }
  const num = Number(input);
  if (!isNaN(num) && input.trim() !== "") {
    return num;
  }
  return input;
}
function valuesMatch(variantValue, inputValue) {
  if (variantValue === inputValue) {
    return true;
  }
  if (String(variantValue) === String(inputValue)) {
    return true;
  }
  return false;
}

// src/util/telemetry/commands/flags/disable.ts
var FlagsDisableTelemetryClient = class extends TelemetryClient {
  trackCliArgumentFlag(flag) {
    if (flag) {
      this.trackCliArgument({
        arg: "flag",
        value: this.redactedValue
      });
    }
  }
  trackCliOptionEnvironment(environment) {
    if (environment) {
      this.trackCliOption({
        option: "environment",
        value: environment
      });
    }
  }
  trackCliOptionVariant(variant) {
    if (variant) {
      this.trackCliOption({
        option: "variant",
        value: this.redactedValue
      });
    }
  }
};

// src/commands/flags/disable.ts
var VALID_ENVIRONMENTS = ["production", "preview", "development"];
async function disable(client, argv) {
  const telemetryClient = new FlagsDisableTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(disableSubcommand.options);
  try {
    parsedArgs = parseArguments(argv, flagsSpecification);
  } catch (err) {
    printError(err);
    return 1;
  }
  const { args, flags } = parsedArgs;
  const [flagArg] = args;
  let environment = flags["--environment"];
  const variantId2 = flags["--variant"];
  if (!flagArg) {
    output_manager_default.error("Please provide a flag slug or ID to disable");
    output_manager_default.log(
      `Example: ${getCommandName("flags disable my-feature --environment production")}`
    );
    return 1;
  }
  telemetryClient.trackCliArgumentFlag(flagArg);
  telemetryClient.trackCliOptionEnvironment(environment);
  telemetryClient.trackCliOptionVariant(variantId2);
  const link = await getLinkedProject(client);
  if (link.status === "error") {
    return link.exitCode;
  } else if (link.status === "not_linked") {
    output_manager_default.error(
      `Your codebase isn't linked to a project on Vercel. Run ${getCommandName("link")} to begin.`
    );
    return 1;
  }
  client.config.currentTeam = link.org.type === "team" ? link.org.id : void 0;
  const { project } = link;
  try {
    output_manager_default.spinner("Fetching flag...");
    const flag = await getFlag(client, project.id, flagArg);
    output_manager_default.stopSpinner();
    if (flag.state === "archived") {
      output_manager_default.error(
        `Flag ${import_chalk47.default.bold(flag.slug)} is archived and cannot be disabled`
      );
      return 1;
    }
    if (flag.kind !== "boolean") {
      const dashboardUrl = getFlagDashboardUrl(
        link.org.slug,
        project.name,
        flag.slug
      );
      output_manager_default.warn(
        `The ${getCommandName("flags disable")} command only works with boolean flags.`
      );
      output_manager_default.log(
        `Flag ${import_chalk47.default.bold(flag.slug)} is a ${import_chalk47.default.cyan(flag.kind)} flag. You can update it on the dashboard:`
      );
      output_manager_default.log(`  ${import_chalk47.default.cyan(dashboardUrl)}`);
      return 0;
    }
    if (!environment) {
      const availableEnvs = Object.keys(flag.environments).filter(
        (env) => VALID_ENVIRONMENTS.includes(env)
      );
      if (availableEnvs.length === 0) {
        output_manager_default.error("No valid environments found for this flag");
        return 1;
      }
      environment = await client.input.select({
        message: "Select an environment to disable the flag in:",
        choices: availableEnvs.map((env) => {
          const config = flag.environments[env];
          const status3 = config?.active ? import_chalk47.default.green("active") : import_chalk47.default.yellow("paused");
          return {
            name: `${env} (${status3})`,
            value: env
          };
        })
      });
    }
    if (!VALID_ENVIRONMENTS.includes(environment)) {
      output_manager_default.error(
        `Invalid environment: ${environment}. Must be one of: ${VALID_ENVIRONMENTS.join(", ")}`
      );
      return 1;
    }
    const envConfig = flag.environments[environment];
    if (!envConfig) {
      output_manager_default.error(`Environment ${environment} not found for this flag`);
      return 1;
    }
    if (!envConfig.active) {
      output_manager_default.warn(
        `Flag ${import_chalk47.default.bold(flag.slug)} is already disabled in ${environment}`
      );
      return 0;
    }
    let selectedVariantId = variantId2;
    if (selectedVariantId) {
      const result = resolveVariant(selectedVariantId, flag.variants);
      if (result.error) {
        output_manager_default.error(result.error);
        return 1;
      }
      selectedVariantId = result.variant.id;
    } else if (flag.variants.length === 1) {
      selectedVariantId = flag.variants[0].id;
    } else if (flag.kind === "boolean") {
      const falseVariant = flag.variants.find((v) => v.value === false);
      selectedVariantId = falseVariant?.id ?? flag.variants[0].id;
    } else {
      selectedVariantId = await client.input.select({
        message: "Select which variant to serve while the flag is disabled:",
        choices: flag.variants.map((v) => ({
          name: `${v.id} (${import_chalk47.default.yellow(JSON.stringify(v.value))})${v.label ? ` - ${v.label}` : ""}`,
          value: v.id
        }))
      });
    }
    const updatedEnvConfig = {
      active: false,
      fallthrough: envConfig.fallthrough,
      rules: envConfig.rules,
      pausedOutcome: {
        type: "variant",
        variantId: selectedVariantId
      }
    };
    output_manager_default.spinner(`Disabling flag in ${environment}...`);
    await updateFlag(client, project.id, flagArg, {
      environments: {
        [environment]: updatedEnvConfig
      },
      message: `Disabled in ${environment} via CLI`
    });
    output_manager_default.stopSpinner();
    const variant = flag.variants.find((v) => v.id === selectedVariantId);
    const variantValue = variant ? JSON.stringify(variant.value) : selectedVariantId;
    output_manager_default.success(
      `Feature flag ${import_chalk47.default.bold(flag.slug)} has been disabled in ${import_chalk47.default.bold(environment)}`
    );
    output_manager_default.log(
      `  ${import_chalk47.default.dim("Serving variant:")} ${selectedVariantId} (${import_chalk47.default.yellow(variantValue)})`
    );
  } catch (err) {
    output_manager_default.stopSpinner();
    printError(err);
    return 1;
  }
  return 0;
}

// src/commands/flags/enable.ts
var import_chalk48 = __toESM(require_source(), 1);

// src/util/telemetry/commands/flags/enable.ts
var FlagsEnableTelemetryClient = class extends TelemetryClient {
  trackCliArgumentFlag(flag) {
    if (flag) {
      this.trackCliArgument({
        arg: "flag",
        value: this.redactedValue
      });
    }
  }
  trackCliOptionEnvironment(environment) {
    if (environment) {
      this.trackCliOption({
        option: "environment",
        value: environment
      });
    }
  }
};

// src/commands/flags/enable.ts
var VALID_ENVIRONMENTS2 = ["production", "preview", "development"];
async function enable(client, argv) {
  const telemetryClient = new FlagsEnableTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(enableSubcommand.options);
  try {
    parsedArgs = parseArguments(argv, flagsSpecification);
  } catch (err) {
    printError(err);
    return 1;
  }
  const { args, flags } = parsedArgs;
  const [flagArg] = args;
  let environment = flags["--environment"];
  if (!flagArg) {
    output_manager_default.error("Please provide a flag slug or ID to enable");
    output_manager_default.log(
      `Example: ${getCommandName("flags enable my-feature --environment production")}`
    );
    return 1;
  }
  telemetryClient.trackCliArgumentFlag(flagArg);
  telemetryClient.trackCliOptionEnvironment(environment);
  const link = await getLinkedProject(client);
  if (link.status === "error") {
    return link.exitCode;
  } else if (link.status === "not_linked") {
    output_manager_default.error(
      `Your codebase isn't linked to a project on Vercel. Run ${getCommandName("link")} to begin.`
    );
    return 1;
  }
  client.config.currentTeam = link.org.type === "team" ? link.org.id : void 0;
  const { project } = link;
  try {
    output_manager_default.spinner("Fetching flag...");
    const flag = await getFlag(client, project.id, flagArg);
    output_manager_default.stopSpinner();
    if (flag.state === "archived") {
      output_manager_default.error(
        `Flag ${import_chalk48.default.bold(flag.slug)} is archived and cannot be enabled`
      );
      return 1;
    }
    if (flag.kind !== "boolean") {
      const dashboardUrl = getFlagDashboardUrl(
        link.org.slug,
        project.name,
        flag.slug
      );
      output_manager_default.warn(
        `The ${getCommandName("flags enable")} command only works with boolean flags.`
      );
      output_manager_default.log(
        `Flag ${import_chalk48.default.bold(flag.slug)} is a ${import_chalk48.default.cyan(flag.kind)} flag. You can update it on the dashboard:`
      );
      output_manager_default.log(`  ${import_chalk48.default.cyan(dashboardUrl)}`);
      return 0;
    }
    if (!environment) {
      const availableEnvs = Object.keys(flag.environments).filter(
        (env) => VALID_ENVIRONMENTS2.includes(env)
      );
      if (availableEnvs.length === 0) {
        output_manager_default.error("No valid environments found for this flag");
        return 1;
      }
      environment = await client.input.select({
        message: "Select an environment to enable the flag in:",
        choices: availableEnvs.map((env) => {
          const config = flag.environments[env];
          const status3 = config?.active ? import_chalk48.default.green("active") : import_chalk48.default.yellow("paused");
          return {
            name: `${env} (${status3})`,
            value: env
          };
        })
      });
    }
    if (!VALID_ENVIRONMENTS2.includes(environment)) {
      output_manager_default.error(
        `Invalid environment: ${environment}. Must be one of: ${VALID_ENVIRONMENTS2.join(", ")}`
      );
      return 1;
    }
    const envConfig = flag.environments[environment];
    if (!envConfig) {
      output_manager_default.error(`Environment ${environment} not found for this flag`);
      return 1;
    }
    if (envConfig.active) {
      output_manager_default.warn(
        `Flag ${import_chalk48.default.bold(flag.slug)} is already enabled in ${environment}`
      );
      return 0;
    }
    const updatedEnvConfig = {
      ...envConfig,
      active: true
    };
    output_manager_default.spinner(`Enabling flag in ${environment}...`);
    await updateFlag(client, project.id, flagArg, {
      environments: {
        [environment]: updatedEnvConfig
      },
      message: `Enabled in ${environment} via CLI`
    });
    output_manager_default.stopSpinner();
    output_manager_default.success(
      `Feature flag ${import_chalk48.default.bold(flag.slug)} has been enabled in ${import_chalk48.default.bold(environment)}`
    );
    output_manager_default.log(
      `  ${import_chalk48.default.dim("The flag will now evaluate rules and serve variants based on its configuration.")}`
    );
  } catch (err) {
    output_manager_default.stopSpinner();
    printError(err);
    return 1;
  }
  return 0;
}

// src/util/telemetry/commands/flags/sdk-keys.ts
var FlagsSdkKeysTelemetryClient = class extends TelemetryClient {
  trackCliSubcommandList(actual) {
    this.trackCliSubcommand({
      subcommand: "ls",
      value: actual
    });
  }
  trackCliSubcommandAdd(actual) {
    this.trackCliSubcommand({
      subcommand: "add",
      value: actual
    });
  }
  trackCliSubcommandRemove(actual) {
    this.trackCliSubcommand({
      subcommand: "rm",
      value: actual
    });
  }
};
var FlagsSdkKeysLsTelemetryClient = class extends TelemetryClient {
  trackCliFlagJson(json) {
    if (json) {
      this.trackCliFlag("json");
    }
  }
};
var FlagsSdkKeysAddTelemetryClient = class extends TelemetryClient {
  trackCliOptionType(type) {
    if (type) {
      this.trackCliOption({
        option: "type",
        value: type
      });
    }
  }
  trackCliOptionEnvironment(environment) {
    if (environment) {
      this.trackCliOption({
        option: "environment",
        value: environment
      });
    }
  }
  trackCliOptionLabel(label) {
    if (label) {
      this.trackCliOption({
        option: "label",
        value: this.redactedValue
      });
    }
  }
};
var FlagsSdkKeysRmTelemetryClient = class extends TelemetryClient {
  trackCliArgumentKey(key) {
    if (key) {
      this.trackCliArgument({
        arg: "key",
        value: this.redactedValue
      });
    }
  }
  trackCliFlagYes(yes) {
    if (yes) {
      this.trackCliFlag("yes");
    }
  }
};

// src/commands/flags/sdk-keys-ls.ts
var import_chalk49 = __toESM(require_source(), 1);
var import_ms12 = __toESM(require_ms(), 1);

// src/util/flags/sdk-keys.ts
async function getSdkKeys(client, projectId) {
  output_manager_default.debug(`Fetching SDK keys for project ${projectId}`);
  const url = `/v1/projects/${encodeURIComponent(projectId)}/feature-flags/sdk-keys`;
  const response = await client.fetch(url);
  return response.data;
}
async function createSdkKey(client, projectId, request) {
  output_manager_default.debug(`Creating SDK key for project ${projectId}`);
  const url = `/v1/projects/${encodeURIComponent(projectId)}/feature-flags/sdk-keys`;
  const response = await client.fetch(url, {
    method: "PUT",
    body: request
  });
  return response;
}
async function deleteSdkKey(client, projectId, hashKey) {
  output_manager_default.debug(`Deleting SDK key ${hashKey} for project ${projectId}`);
  const url = `/v1/projects/${encodeURIComponent(projectId)}/feature-flags/sdk-keys/${encodeURIComponent(hashKey)}`;
  await client.fetch(url, {
    method: "DELETE",
    json: false
  });
}

// src/commands/flags/sdk-keys-ls.ts
async function sdkKeysLs(client, argv) {
  const telemetryClient = new FlagsSdkKeysLsTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(
    sdkKeysListSubcommand.options
  );
  try {
    parsedArgs = parseArguments(argv, flagsSpecification);
  } catch (err) {
    printError(err);
    return 1;
  }
  const { flags } = parsedArgs;
  const json = flags["--json"];
  telemetryClient.trackCliFlagJson(json);
  const link = await getLinkedProject(client);
  if (link.status === "error") {
    return link.exitCode;
  } else if (link.status === "not_linked") {
    output_manager_default.error(
      `Your codebase isn't linked to a project on Vercel. Run ${getCommandName("link")} to begin.`
    );
    return 1;
  }
  client.config.currentTeam = link.org.type === "team" ? link.org.id : void 0;
  const { project, org } = link;
  const projectSlugLink = formatProject(org.slug, project.name);
  try {
    output_manager_default.spinner("Fetching SDK keys...");
    const keys = await getSdkKeys(client, project.id);
    output_manager_default.stopSpinner();
    const sortedKeys = keys.sort((a, b) => b.createdAt - a.createdAt);
    if (json) {
      outputSdkKeysJson(client, sortedKeys);
    } else if (keys.length === 0) {
      output_manager_default.log(`No SDK keys found for ${projectSlugLink}`);
      output_manager_default.log(
        `
Create one with: ${getCommandName("flags sdk-keys add --type server --environment production")}`
      );
    } else {
      output_manager_default.log(
        `${import_chalk49.default.bold(keys.length)} SDK key${keys.length === 1 ? "" : "s"} found for ${projectSlugLink}`
      );
      printSdkKeysTable(sortedKeys);
    }
  } catch (err) {
    output_manager_default.stopSpinner();
    printError(err);
    return 1;
  }
  return 0;
}
function outputSdkKeysJson(client, keys) {
  const jsonOutput = {
    sdkKeys: keys.map((key) => ({
      hashKey: key.hashKey,
      type: key.type,
      environment: key.environment,
      label: key.label ?? null,
      createdAt: key.createdAt,
      updatedAt: key.updatedAt
    }))
  };
  client.stdout.write(`${JSON.stringify(jsonOutput, null, 2)}
`);
}
function printSdkKeysTable(keys) {
  const headers = ["Hash Key", "Type", "Environment", "Label", "Created"];
  const now = Date.now();
  const rows = keys.map((key) => [
    import_chalk49.default.dim(key.hashKey.slice(0, 12) + "..."),
    getTypeLabel(key.type),
    key.environment,
    key.label || import_chalk49.default.dim("-"),
    (0, import_ms12.default)(now - key.createdAt) + " ago"
  ]);
  const table3 = formatTable(
    headers,
    ["l", "l", "l", "l", "l"],
    [{ name: "", rows }]
  );
  output_manager_default.print(`
${table3}
`);
}
function getTypeLabel(type) {
  switch (type) {
    case "server":
      return import_chalk49.default.blue("server");
    case "client":
      return import_chalk49.default.green("client");
    case "mobile":
      return import_chalk49.default.yellow("mobile");
    default:
      return type;
  }
}

// src/commands/flags/sdk-keys-add.ts
var import_chalk50 = __toESM(require_source(), 1);
var VALID_TYPES = ["server", "client", "mobile"];
var VALID_ENVIRONMENTS3 = ["production", "preview", "development"];
async function sdkKeysAdd(client, argv) {
  const telemetryClient = new FlagsSdkKeysAddTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(
    sdkKeysAddSubcommand.options
  );
  try {
    parsedArgs = parseArguments(argv, flagsSpecification);
  } catch (err) {
    printError(err);
    return 1;
  }
  const { flags } = parsedArgs;
  let sdkKeyType = flags["--type"];
  let environment = flags["--environment"];
  const label = flags["--label"];
  telemetryClient.trackCliOptionType(sdkKeyType);
  telemetryClient.trackCliOptionEnvironment(environment);
  telemetryClient.trackCliOptionLabel(label);
  const link = await getLinkedProject(client);
  if (link.status === "error") {
    return link.exitCode;
  } else if (link.status === "not_linked") {
    output_manager_default.error(
      `Your codebase isn't linked to a project on Vercel. Run ${getCommandName("link")} to begin.`
    );
    return 1;
  }
  client.config.currentTeam = link.org.type === "team" ? link.org.id : void 0;
  const { project } = link;
  if (!sdkKeyType) {
    sdkKeyType = await client.input.select({
      message: "Select the SDK key type:",
      choices: [
        {
          name: "Server (for backend/server-side usage)",
          value: "server"
        },
        {
          name: "Client (for browser/frontend usage)",
          value: "client"
        },
        { name: "Mobile (for mobile app usage)", value: "mobile" }
      ]
    });
  }
  if (!VALID_TYPES.includes(sdkKeyType)) {
    output_manager_default.error(
      `Invalid type: ${sdkKeyType}. Must be one of: ${VALID_TYPES.join(", ")}`
    );
    return 1;
  }
  if (!environment) {
    environment = await client.input.select({
      message: "Select the environment:",
      choices: VALID_ENVIRONMENTS3.map((env) => ({
        name: env,
        value: env
      }))
    });
  }
  if (!VALID_ENVIRONMENTS3.includes(environment)) {
    output_manager_default.error(
      `Invalid environment: ${environment}. Must be one of: ${VALID_ENVIRONMENTS3.join(", ")}`
    );
    return 1;
  }
  let finalLabel = label;
  if (!finalLabel && client.stdin.isTTY) {
    finalLabel = await client.input.text({
      message: "Enter an optional label for this SDK key (press Enter to skip):"
    });
    if (finalLabel === "") {
      finalLabel = void 0;
    }
  }
  const request = {
    sdkKeyType,
    environment,
    label: finalLabel
  };
  try {
    output_manager_default.spinner("Creating SDK key...");
    const key = await createSdkKey(client, project.id, request);
    output_manager_default.stopSpinner();
    output_manager_default.success("SDK key created successfully");
    output_manager_default.print("\n");
    output_manager_default.print(`  ${import_chalk50.default.dim("Hash Key:")}     ${key.hashKey}
`);
    output_manager_default.print(`  ${import_chalk50.default.dim("Type:")}         ${key.type}
`);
    output_manager_default.print(`  ${import_chalk50.default.dim("Environment:")}  ${key.environment}
`);
    if (key.label) {
      output_manager_default.print(`  ${import_chalk50.default.dim("Label:")}        ${key.label}
`);
    }
    if (key.keyValue) {
      output_manager_default.print("\n");
      output_manager_default.warn("Save this key - it will not be shown again:");
      output_manager_default.print(`
  ${import_chalk50.default.cyan(key.keyValue)}
`);
    }
    if (key.connectionString) {
      output_manager_default.print("\n");
      output_manager_default.log(`${import_chalk50.default.dim("Connection string:")}`);
      output_manager_default.print(`  ${import_chalk50.default.cyan(key.connectionString)}
`);
    }
  } catch (err) {
    output_manager_default.stopSpinner();
    printError(err);
    return 1;
  }
  return 0;
}

// src/commands/flags/sdk-keys-rm.ts
var import_chalk51 = __toESM(require_source(), 1);
async function sdkKeysRm(client, argv) {
  const telemetryClient = new FlagsSdkKeysRmTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(
    sdkKeysRemoveSubcommand.options
  );
  try {
    parsedArgs = parseArguments(argv, flagsSpecification);
  } catch (err) {
    printError(err);
    return 1;
  }
  const { args, flags } = parsedArgs;
  let [hashKey] = args;
  const skipConfirmation = flags["--yes"];
  telemetryClient.trackCliArgumentKey(hashKey);
  telemetryClient.trackCliFlagYes(skipConfirmation);
  const link = await getLinkedProject(client);
  if (link.status === "error") {
    return link.exitCode;
  } else if (link.status === "not_linked") {
    output_manager_default.error(
      `Your codebase isn't linked to a project on Vercel. Run ${getCommandName("link")} to begin.`
    );
    return 1;
  }
  client.config.currentTeam = link.org.type === "team" ? link.org.id : void 0;
  const { project } = link;
  try {
    if (!hashKey) {
      output_manager_default.spinner("Fetching SDK keys...");
      const keys = await getSdkKeys(client, project.id);
      output_manager_default.stopSpinner();
      if (keys.length === 0) {
        output_manager_default.log("No SDK keys found");
        return 0;
      }
      hashKey = await client.input.select({
        message: "Select an SDK key to delete:",
        choices: keys.map((key) => ({
          name: `${key.hashKey.slice(0, 12)}... (${key.type}, ${key.environment}${key.label ? `, ${key.label}` : ""})`,
          value: key.hashKey
        }))
      });
    }
    if (!skipConfirmation) {
      const confirmed = await client.input.confirm(
        `Are you sure you want to delete SDK key ${import_chalk51.default.bold(hashKey.slice(0, 12) + "...")}?`,
        false
      );
      if (!confirmed) {
        output_manager_default.log("Aborted");
        return 0;
      }
    }
    output_manager_default.spinner("Deleting SDK key...");
    await deleteSdkKey(client, project.id, hashKey);
    output_manager_default.stopSpinner();
    output_manager_default.success(
      `SDK key ${import_chalk51.default.bold(hashKey.slice(0, 12) + "...")} has been deleted`
    );
  } catch (err) {
    output_manager_default.stopSpinner();
    printError(err);
    return 1;
  }
  return 0;
}

// src/commands/flags/sdk-keys.ts
var COMMAND_CONFIG8 = {
  ls: getCommandAliases(sdkKeysListSubcommand),
  add: getCommandAliases(sdkKeysAddSubcommand),
  rm: getCommandAliases(sdkKeysRemoveSubcommand)
};
async function sdkKeys(client) {
  const telemetry2 = new FlagsSdkKeysTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  const flagsSpecification = getFlagsSpecification(sdkKeysSubcommand.options);
  let parsedArgs;
  try {
    parsedArgs = parseArguments(client.argv.slice(4), flagsSpecification, {
      // eslint-disable-next-line no-restricted-syntax -- this is a routing file, not a leaf command
      permissive: true
    });
  } catch (err) {
    printError(err);
    return 1;
  }
  const subArgs = parsedArgs.args.slice(0);
  const { subcommand, args, subcommandOriginal } = getSubcommand3(
    subArgs,
    COMMAND_CONFIG8
  );
  const needHelp = parsedArgs.flags["--help"];
  if (!subcommand && needHelp) {
    telemetry2.trackCliFlagHelp("flags sdk-keys", subcommand);
    output_manager_default.print(
      help(sdkKeysSubcommand, {
        parent: flagsCommand,
        columns: client.stderr.columns
      })
    );
    return 2;
  }
  function printHelp(command) {
    output_manager_default.print(
      help(command, {
        parent: sdkKeysSubcommand,
        columns: client.stderr.columns
      })
    );
  }
  switch (subcommand) {
    case "ls":
      if (needHelp) {
        telemetry2.trackCliFlagHelp("flags sdk-keys", subcommandOriginal);
        printHelp(sdkKeysListSubcommand);
        return 2;
      }
      telemetry2.trackCliSubcommandList(subcommandOriginal);
      return sdkKeysLs(client, args);
    case "add":
      if (needHelp) {
        telemetry2.trackCliFlagHelp("flags sdk-keys", subcommandOriginal);
        printHelp(sdkKeysAddSubcommand);
        return 2;
      }
      telemetry2.trackCliSubcommandAdd(subcommandOriginal);
      return sdkKeysAdd(client, args);
    case "rm":
      if (needHelp) {
        telemetry2.trackCliFlagHelp("flags sdk-keys", subcommandOriginal);
        printHelp(sdkKeysRemoveSubcommand);
        return 2;
      }
      telemetry2.trackCliSubcommandRemove(subcommandOriginal);
      return sdkKeysRm(client, args);
    default:
      output_manager_default.error(getInvalidSubcommand(COMMAND_CONFIG8));
      output_manager_default.print(
        help(sdkKeysSubcommand, {
          parent: flagsCommand,
          columns: client.stderr.columns
        })
      );
      return 2;
  }
}

// src/commands/flags/emit-datafiles.ts
var import_env = __toESM(require_dist3(), 1);
async function emitDatafiles(client) {
  try {
    let localEnv = {};
    try {
      localEnv = (0, import_env.loadEnvConfig)(client.cwd, true).combinedEnv;
    } catch (err) {
      output_manager_default.debug(`Failed to load local env files: ${err}`);
    }
    await emitFlagsDatafiles(client.cwd, { ...localEnv, ...process.env });
    return 0;
  } catch (err) {
    printError(err);
    return 1;
  }
}

// src/commands/flags/index.ts
var COMMAND_CONFIG9 = {
  ls: getCommandAliases(listSubcommand6),
  inspect: getCommandAliases(inspectSubcommand2),
  add: getCommandAliases(addSubcommand4),
  rm: getCommandAliases(removeSubcommand5),
  archive: getCommandAliases(archiveSubcommand),
  disable: getCommandAliases(disableSubcommand),
  enable: getCommandAliases(enableSubcommand),
  "sdk-keys": getCommandAliases(sdkKeysSubcommand),
  prepare: getCommandAliases(prepareSubcommand)
};
async function main6(client) {
  const telemetry2 = new FlagsTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  const flagsSpecification = getFlagsSpecification(flagsCommand.options);
  let parsedArgs;
  try {
    parsedArgs = parseArguments(client.argv.slice(2), flagsSpecification, {
      permissive: true
    });
  } catch (err) {
    printError(err);
    return 1;
  }
  const subArgs = parsedArgs.args.slice(1);
  const { subcommand, args, subcommandOriginal } = getSubcommand3(
    subArgs,
    COMMAND_CONFIG9
  );
  const needHelp = parsedArgs.flags["--help"];
  if (!subcommand && needHelp) {
    telemetry2.trackCliFlagHelp("flags", subcommand);
    output_manager_default.print(help(flagsCommand, { columns: client.stderr.columns }));
    return 2;
  }
  function printHelp(command) {
    output_manager_default.print(
      help(command, { parent: flagsCommand, columns: client.stderr.columns })
    );
  }
  switch (subcommand) {
    case "ls":
      if (needHelp) {
        telemetry2.trackCliFlagHelp("flags", subcommandOriginal);
        printHelp(listSubcommand6);
        return 2;
      }
      telemetry2.trackCliSubcommandList(subcommandOriginal);
      return ls5(client, args);
    case "inspect":
      if (needHelp) {
        telemetry2.trackCliFlagHelp("flags", subcommandOriginal);
        printHelp(inspectSubcommand2);
        return 2;
      }
      telemetry2.trackCliSubcommandInspect(subcommandOriginal);
      return inspect2(client, args);
    case "add":
      if (needHelp) {
        telemetry2.trackCliFlagHelp("flags", subcommandOriginal);
        printHelp(addSubcommand4);
        return 2;
      }
      telemetry2.trackCliSubcommandAdd(subcommandOriginal);
      return add4(client, args);
    case "rm":
      if (needHelp) {
        telemetry2.trackCliFlagHelp("flags", subcommandOriginal);
        printHelp(removeSubcommand5);
        return 2;
      }
      telemetry2.trackCliSubcommandRemove(subcommandOriginal);
      return rm5(client, args);
    case "archive":
      if (needHelp) {
        telemetry2.trackCliFlagHelp("flags", subcommandOriginal);
        printHelp(archiveSubcommand);
        return 2;
      }
      telemetry2.trackCliSubcommandArchive(subcommandOriginal);
      return archive(client, args);
    case "disable":
      if (needHelp) {
        telemetry2.trackCliFlagHelp("flags", subcommandOriginal);
        printHelp(disableSubcommand);
        return 2;
      }
      telemetry2.trackCliSubcommandDisable(subcommandOriginal);
      return disable(client, args);
    case "enable":
      if (needHelp) {
        telemetry2.trackCliFlagHelp("flags", subcommandOriginal);
        printHelp(enableSubcommand);
        return 2;
      }
      telemetry2.trackCliSubcommandEnable(subcommandOriginal);
      return enable(client, args);
    case "sdk-keys":
      telemetry2.trackCliSubcommandSdkKeys(subcommandOriginal);
      return sdkKeys(client);
    case "prepare":
      if (needHelp) {
        telemetry2.trackCliFlagHelp("flags", subcommandOriginal);
        printHelp(prepareSubcommand);
        return 2;
      }
      telemetry2.trackCliSubcommandPrepare(subcommandOriginal);
      return emitDatafiles(client);
    default:
      if (needHelp) {
        telemetry2.trackCliFlagHelp("flags", subcommandOriginal);
        printHelp(listSubcommand6);
        return 2;
      }
      telemetry2.trackCliSubcommandList(subcommandOriginal);
      return ls5(client, args);
  }
}

// src/commands/git/connect.ts
var import_chalk52 = __toESM(require_source(), 1);
import { join as join2 } from "path";

// src/util/telemetry/commands/git/connect.ts
var GitConnectTelemetryClient = class extends TelemetryClient {
  trackCliArgumentGitUrl(name) {
    if (name) {
      this.trackCliArgument({
        arg: "gitUrl",
        value: this.redactedValue
      });
    }
  }
  trackCliFlagConfirm(confirm) {
    if (confirm) {
      this.trackCliFlag("confirm");
    }
  }
  trackCliFlagYes(yes) {
    if (yes) {
      this.trackCliFlag("yes");
    }
  }
};

// src/commands/git/connect.ts
async function connect(client, argv) {
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(connectSubcommand.options);
  try {
    parsedArgs = parseArguments(argv, flagsSpecification);
  } catch (error) {
    printError(error);
    return 1;
  }
  const { args, flags: opts } = parsedArgs;
  const { cwd } = client;
  const telemetry2 = new GitConnectTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  telemetry2.trackCliFlagConfirm(opts["--confirm"]);
  telemetry2.trackCliFlagYes(opts["--yes"]);
  if ("--confirm" in opts) {
    output_manager_default.warn("`--confirm` is deprecated, please use `--yes` instead");
    opts["--yes"] = opts["--confirm"];
  }
  const confirm = Boolean(opts["--yes"]);
  if (args.length > 1) {
    output_manager_default.error(
      `Invalid number of arguments. Usage: ${import_chalk52.default.cyan(
        `${getCommandName("project connect")}`
      )}`
    );
    return 2;
  }
  const repoArg = args[0];
  telemetry2.trackCliArgumentGitUrl(repoArg);
  const linkedProject = await ensureLink("git", client, client.cwd, {
    autoConfirm: confirm
  });
  if (typeof linkedProject === "number") {
    return linkedProject;
  }
  const { project, org } = linkedProject;
  const gitProviderLink = project.link;
  client.config.currentTeam = org.type === "team" ? org.id : void 0;
  const gitConfigPath = join2(cwd, ".git/config");
  const gitConfig = await parseGitConfig(gitConfigPath);
  if (repoArg) {
    const parsedUrlArg = parseRepoUrl(repoArg);
    if (!parsedUrlArg) {
      output_manager_default.error(
        `Failed to parse URL "${repoArg}". Please ensure the URL is valid.`
      );
      return 1;
    }
    if (gitConfig) {
      return await connectArgWithLocalGit({
        client,
        org,
        project,
        confirm,
        gitConfig,
        repoInfo: parsedUrlArg
      });
    }
    return await connectArg({
      client,
      confirm,
      org,
      project,
      repoInfo: parsedUrlArg
    });
  }
  if (!gitConfig) {
    output_manager_default.error(
      `No local Git repository found. Run ${import_chalk52.default.cyan(
        "`git clone <url>`"
      )} to clone a remote Git repository first.`
    );
    return 1;
  }
  const remoteUrls = pluckRemoteUrls(gitConfig);
  if (!remoteUrls) {
    output_manager_default.error(
      `No remote URLs found in your Git config. Make sure you've configured a remote repo in your local Git config. Run ${import_chalk52.default.cyan(
        "`git remote --help`"
      )} for more details.`
    );
    return 1;
  }
  const repoInfo = await selectAndParseRemoteUrl(client, remoteUrls);
  if (!repoInfo) {
    return Object.keys(remoteUrls).length > 1 ? 0 : 1;
  }
  const result = await checkExistsAndConnect({
    client,
    confirm,
    gitProviderLink,
    org,
    gitOrg: repoInfo.org,
    project,
    provider: repoInfo.provider,
    repo: repoInfo.repo,
    repoPath: `${repoInfo.org}/${repoInfo.repo}`
  });
  if (typeof result === "number") {
    return result;
  }
  return 0;
}
async function connectArg({
  client,
  confirm,
  org,
  project,
  repoInfo
}) {
  const { url: repoUrl } = repoInfo;
  const parsedRepoArg = parseRepoUrl(repoUrl);
  if (!parsedRepoArg) {
    output_manager_default.error(
      `Failed to parse URL "${repoUrl}". Please ensure the URL is valid.`
    );
    return 1;
  }
  const result = await checkExistsAndConnect({
    client,
    confirm,
    gitProviderLink: project.link,
    org,
    gitOrg: parsedRepoArg.org,
    project,
    provider: parsedRepoArg.provider,
    repo: parsedRepoArg.repo,
    repoPath: `${parsedRepoArg.org}/${parsedRepoArg.repo}`
  });
  if (typeof result === "number") {
    return result;
  }
  return 0;
}
async function connectArgWithLocalGit({
  client,
  org,
  project,
  confirm,
  gitConfig,
  repoInfo
}) {
  const remoteUrls = pluckRemoteUrls(gitConfig);
  if (remoteUrls) {
    const shouldConnect = await promptConnectArg({
      client,
      yes: confirm,
      repoInfo,
      remoteUrls
    });
    if (!shouldConnect) {
      return 1;
    }
    if (shouldConnect) {
      const result = await checkExistsAndConnect({
        client,
        confirm,
        gitProviderLink: project.link,
        org,
        gitOrg: repoInfo.org,
        project,
        provider: repoInfo.provider,
        repo: repoInfo.repo,
        repoPath: `${repoInfo.org}/${repoInfo.repo}`
      });
      if (typeof result === "number") {
        return result;
      }
    }
    return 0;
  }
  return await connectArg({ client, confirm, org, project, repoInfo });
}
async function promptConnectArg({
  client,
  yes,
  repoInfo: repoInfoFromArg,
  remoteUrls
}) {
  if (Object.keys(remoteUrls).length > 1) {
    output_manager_default.log("Found multiple Git repositories in your local Git config:");
    printRemoteUrls(remoteUrls);
  } else {
    const url = Object.values(remoteUrls)[0];
    const repoInfoFromGitConfig = parseRepoUrl(url);
    if (!repoInfoFromGitConfig) {
      output_manager_default.error(
        `Failed to parse URL "${url}". Please ensure the URL is valid.`
      );
      return false;
    }
    if (JSON.stringify(repoInfoFromGitConfig) === JSON.stringify(repoInfoFromArg)) {
      return true;
    }
    output_manager_default.log(
      `Found a repository in your local Git Config: ${import_chalk52.default.cyan(
        Object.values(remoteUrls)[0]
      )}`
    );
  }
  let shouldConnect = yes;
  if (!shouldConnect) {
    const { url: repoUrlFromArg } = repoInfoFromArg;
    shouldConnect = await client.input.confirm(
      `Do you still want to connect ${link_default(repoUrlFromArg)}?`,
      false
    );
    if (!shouldConnect) {
      output_manager_default.log("Canceled. Repo not connected.");
    }
  }
  return shouldConnect;
}

// src/commands/git/disconnect.ts
var import_chalk53 = __toESM(require_source(), 1);

// src/util/telemetry/commands/git/disconnect.ts
var GitDisconnectTelemetryClient = class extends TelemetryClient {
  trackCliFlagConfirm(confirm) {
    if (confirm) {
      this.trackCliFlag("confirm");
    }
  }
  trackCliFlagYes(yes) {
    if (yes) {
      this.trackCliFlag("yes");
    }
  }
};

// src/commands/git/disconnect.ts
async function disconnect(client, argv) {
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(
    disconnectSubcommand.options
  );
  try {
    parsedArgs = parseArguments(argv, flagsSpecification);
  } catch (error) {
    printError(error);
    return 1;
  }
  const { args, flags: opts } = parsedArgs;
  const telemetry2 = new GitDisconnectTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  telemetry2.trackCliFlagConfirm(opts["--confirm"]);
  telemetry2.trackCliFlagYes(opts["--yes"]);
  if ("--confirm" in opts) {
    output_manager_default.warn("`--confirm` is deprecated, please use `--yes` instead");
    opts["--yes"] = opts["--confirm"];
  }
  if (args.length !== 0) {
    output_manager_default.error(
      `Invalid number of arguments. Usage: ${import_chalk53.default.cyan(
        `${getCommandName("project disconnect")}`
      )}`
    );
    return 2;
  }
  const autoConfirm = Boolean(parsedArgs.flags["--yes"]);
  const linkedProject = await ensureLink("git", client, client.cwd, {
    autoConfirm
  });
  if (typeof linkedProject === "number") {
    return linkedProject;
  }
  const { org, project } = linkedProject;
  client.config.currentTeam = org.type === "team" ? org.id : void 0;
  if (project.link) {
    const { org: linkOrg, repo } = project.link;
    output_manager_default.print(
      `Your Vercel project will no longer create deployments when you push to this repository.
`
    );
    const confirmDisconnect = autoConfirm || await client.input.confirm(
      `Are you sure you want to disconnect ${import_chalk53.default.cyan(
        `${linkOrg}/${repo}`
      )} from your project?`,
      false
    );
    if (confirmDisconnect) {
      await disconnectGitProvider(client, org, project.id);
      output_manager_default.log(`Disconnected ${import_chalk53.default.cyan(`${linkOrg}/${repo}`)}.`);
    } else {
      output_manager_default.log("Canceled");
    }
  } else {
    output_manager_default.error(
      `No Git repository connected. Run ${getCommandName(
        "project connect"
      )} to connect one.`
    );
    return 1;
  }
  return 0;
}

// src/util/telemetry/commands/git/index.ts
var GitTelemetryClient = class extends TelemetryClient {
  trackCliSubcommandConnect(actual) {
    this.trackCliSubcommand({
      subcommand: "connect",
      value: actual
    });
  }
  trackCliSubcommandDisconnect(actual) {
    this.trackCliSubcommand({
      subcommand: "disconnect",
      value: actual
    });
  }
};

// src/commands/git/index.ts
var COMMAND_CONFIG10 = {
  connect: ["connect"],
  disconnect: ["disconnect"]
};
async function main7(client) {
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(gitCommand.options);
  try {
    parsedArgs = parseArguments(client.argv.slice(2), flagsSpecification, {
      permissive: true
    });
  } catch (error) {
    printError(error);
    return 1;
  }
  const telemetry2 = new GitTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  const { subcommand, args, subcommandOriginal } = getSubcommand3(
    parsedArgs.args.slice(1),
    COMMAND_CONFIG10
  );
  if (parsedArgs.flags["--help"]) {
    telemetry2.trackCliFlagHelp("git", subcommand);
    output_manager_default.print(help(gitCommand, { columns: client.stderr.columns }));
    return 2;
  }
  switch (subcommand) {
    case "connect":
      telemetry2.trackCliSubcommandConnect(subcommandOriginal);
      return connect(client, args);
    case "disconnect":
      telemetry2.trackCliSubcommandDisconnect(subcommandOriginal);
      return disconnect(client, args);
    default:
      output_manager_default.error(getInvalidSubcommand(COMMAND_CONFIG10));
      output_manager_default.print(help(gitCommand, { columns: client.stderr.columns }));
      return 2;
  }
}

// src/commands/guidance/status.ts
var import_chalk54 = __toESM(require_source(), 1);
async function status(client) {
  const enabled = client.config.guidance?.enabled !== false;
  const status3 = enabled ? import_chalk54.default.green("Enabled") : import_chalk54.default.red("Disabled");
  output_manager_default.print("\n");
  output_manager_default.log(`${import_chalk54.default.bold("Guidance status")}: ${status3}`);
  output_manager_default.print("\n");
  return 0;
}

// src/commands/guidance/enable.ts
async function enable2(client) {
  client.config = {
    ...client.config,
    guidance: {
      ...client.config.guidance,
      enabled: true
    }
  };
  writeToConfigFile(client.config);
  await status(client);
  return 0;
}

// src/commands/guidance/disable.ts
async function disable2(client) {
  client.config = {
    ...client.config,
    guidance: {
      ...client.config.guidance,
      enabled: false
    }
  };
  writeToConfigFile(client.config);
  await status(client);
  return 0;
}

// src/util/telemetry/commands/guidance/index.ts
var GuidanceTelemetryClient = class extends TelemetryClient {
  trackCliSubcommandStatus(actual) {
    this.trackCliSubcommand({
      subcommand: "status",
      value: actual
    });
  }
  trackCliSubcommandEnable(actual) {
    this.trackCliSubcommand({
      subcommand: "enable",
      value: actual
    });
  }
  trackCliSubcommandDisable(actual) {
    this.trackCliSubcommand({
      subcommand: "disable",
      value: actual
    });
  }
};

// src/commands/guidance/index.ts
var COMMAND_CONFIG11 = {
  status: getCommandAliases(statusSubcommand),
  enable: getCommandAliases(enableSubcommand2),
  disable: getCommandAliases(disableSubcommand2)
};
async function guidance(client) {
  if (!process.env.FF_GUIDANCE_MODE) {
    output_manager_default.error("The guidance subcommand does not exist");
    return 1;
  }
  const telemetryClient = new GuidanceTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  let parsedArguments;
  const flagsSpecification = getFlagsSpecification(guidanceCommand.options);
  try {
    parsedArguments = parseArguments(client.argv.slice(2), flagsSpecification);
  } catch (err) {
    printError(err);
    return 1;
  }
  const { subcommand, subcommandOriginal } = getSubcommand3(
    parsedArguments.args.slice(1),
    COMMAND_CONFIG11
  );
  const needHelp = parsedArguments.flags["--help"];
  function printHelp(command) {
    output_manager_default.print(
      help(command, {
        columns: client.stderr.columns,
        parent: guidanceCommand
      })
    );
  }
  if (!subcommand && needHelp) {
    telemetryClient.trackCliFlagHelp("guidance", subcommand);
    output_manager_default.print(help(guidanceCommand, { columns: client.stderr.columns }));
    return 2;
  }
  switch (subcommand) {
    case "status":
      if (needHelp) {
        telemetryClient.trackCliFlagHelp("guidance", subcommandOriginal);
        printHelp(statusSubcommand);
        return 2;
      }
      telemetryClient.trackCliSubcommandStatus(subcommandOriginal);
      return status(client);
    case "enable":
      if (needHelp) {
        telemetryClient.trackCliFlagHelp("guidance", subcommandOriginal);
        printHelp(enableSubcommand2);
        return 2;
      }
      telemetryClient.trackCliSubcommandEnable(subcommandOriginal);
      return enable2(client);
    case "disable":
      if (needHelp) {
        telemetryClient.trackCliFlagHelp("guidance", subcommandOriginal);
        printHelp(disableSubcommand2);
        return 2;
      }
      return disable2(client);
    default: {
      output_manager_default.print(help(guidanceCommand, { columns: client.stderr.columns }));
      return 2;
    }
  }
}

// src/commands/httpstat/index.ts
import { spawn as spawn2 } from "child_process";

// src/util/telemetry/commands/httpstat/index.ts
var HttpstatTelemetryClient = class extends TelemetryClient {
  trackCliArgumentPath(path3) {
    if (path3) {
      const value = path3.startsWith("/") ? "slash" : "no-slash";
      this.trackCliArgument({
        arg: "path",
        value
      });
    }
  }
  trackCliOptionDeployment(deploymentId) {
    if (deploymentId) {
      const value = deploymentId.startsWith("http://") || deploymentId.startsWith("https://") ? "url" : deploymentId.startsWith("dpl_") ? "dpl_" : "no-prefix";
      this.trackCliOption({
        option: "deployment",
        value
      });
    }
  }
  trackCliOptionProtectionBypass(secret) {
    if (secret) {
      this.trackCliOption({
        option: "protection-bypass",
        value: this.redactedValue
      });
    }
  }
  trackCliFlagYes(yes) {
    if (yes) {
      this.trackCliFlag("yes");
    }
  }
};

// src/commands/httpstat/index.ts
async function httpstat(client) {
  const telemetryClient = new HttpstatTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  const setup = setupCurlLikeCommand(client, httpstatCommand, telemetryClient);
  if (typeof setup === "number") {
    return setup;
  }
  const { path: path3, deploymentFlag, protectionBypassFlag, toolFlags } = setup;
  const result = await getDeploymentUrlAndToken(client, "httpstat", path3, {
    deploymentFlag,
    protectionBypassFlag,
    autoConfirm: setup.yes
  });
  if (typeof result === "number") {
    return result;
  }
  const { fullUrl, deploymentProtectionToken } = result;
  const httpstatFlags = [...toolFlags];
  if (deploymentProtectionToken) {
    httpstatFlags.unshift(
      "-H",
      `x-vercel-protection-bypass: ${deploymentProtectionToken}`
    );
  }
  httpstatFlags.unshift(fullUrl);
  output_manager_default.debug(
    `Executing: httpstat ${httpstatFlags.map(requoteArgs).join(" ")}`
  );
  return new Promise((resolve6) => {
    const httpstatProcess = spawn2("httpstat", httpstatFlags, {
      stdio: "inherit",
      shell: false
    });
    httpstatProcess.on("error", (err) => {
      if ("code" in err && err.code === "ENOENT") {
        output_manager_default.error("httpstat command not found. Please install httpstat.");
        output_manager_default.log("");
        output_manager_default.log("Installation instructions:");
        output_manager_default.log("  macOS: brew install httpstat");
        output_manager_default.log("  pip: pip install httpstat");
        output_manager_default.log("  npm: npm install -g httpstat");
        output_manager_default.log("");
        output_manager_default.log(
          "Or visit: https://github.com/reorx/httpstat for more details"
        );
        resolve6(1);
      } else {
        output_manager_default.error(`Failed to execute httpstat: ${err.message}`);
        resolve6(1);
      }
    });
    httpstatProcess.on("close", (code2) => {
      resolve6(code2 ?? 1);
    });
  });
}

// src/commands/init/init.ts
var import_tar_fs = __toESM(require_tar_fs(), 1);
var import_chalk55 = __toESM(require_source(), 1);
import fs from "fs";
import path2 from "path";
var EXAMPLE_API = "https://examples.vercel.sh";
async function init(client, opts, args, telemetry2) {
  const [name, dir] = args;
  const force = opts["--force"];
  const examples = await fetchExampleList(client);
  if (!examples) {
    throw new Error("Could not fetch example list.");
  }
  const exampleList = examples.filter((x) => x.visible).map((x) => x.name);
  if (!name) {
    if (client.stdin.isTTY !== true) {
      output_manager_default.print("No framework provided");
      return 0;
    }
    const chosen = await chooseFromDropdown(
      client,
      "Select example:",
      exampleList
    );
    if (!chosen) {
      output_manager_default.log("Canceled");
      return 0;
    }
    return extractExample(client, chosen, dir, force);
  }
  if (exampleList.includes(name)) {
    telemetry2.trackCliArgumentExample(name, true);
    return extractExample(client, name, dir, force);
  }
  const oldExample = examples.find((x) => !x.visible && x.name === name);
  if (oldExample) {
    telemetry2.trackCliArgumentExample(name, true);
    return extractExample(client, name, dir, force, "v1");
  }
  telemetry2.trackCliArgumentExample(name, false);
  const found = await guess(client, exampleList, name);
  if (typeof found === "string") {
    return extractExample(client, found, dir, force);
  }
  output_manager_default.log("No changes made.");
  return 0;
}
async function fetchExampleList(client) {
  output_manager_default.spinner("Fetching examples");
  const url = `${EXAMPLE_API}/v2/list.json`;
  const body = await client.fetch(url);
  output_manager_default.stopSpinner();
  return body;
}
async function chooseFromDropdown(client, message, exampleList) {
  const choices = exampleList.map((name) => ({
    name,
    value: name,
    short: name
  }));
  return list(client, {
    message,
    choices
  });
}
async function extractExample(client, name, dir, force, ver = "v2") {
  const folder = prepareFolder(client.cwd, dir || name, force);
  output_manager_default.spinner(`Fetching ${name}`);
  const url = `${EXAMPLE_API}/${ver}/download/${name}.tar.gz`;
  return client.fetch(url, { json: false }).then(async (res) => {
    output_manager_default.stopSpinner();
    if (res.status !== 200) {
      throw new Error(`Could not get ${name}.tar.gz`);
    }
    await new Promise((resolve6, reject) => {
      const extractor = import_tar_fs.default.extract(folder);
      res.body.on("error", reject);
      extractor.on("error", reject);
      extractor.on("finish", resolve6);
      res.body.pipe(extractor);
    });
    const successLog = `Initialized "${import_chalk55.default.bold(
      name
    )}" example in ${import_chalk55.default.bold(humanizePath(folder))}.`;
    const folderRel = path2.relative(client.cwd, folder);
    const deployHint = folderRel === "" ? list_item_default(`To deploy, run ${getCommandName()}.`) : list_item_default(
      `To deploy, ${cmd(
        `cd ${folderRel}`
      )} and run ${getCommandName()}.`
    );
    output_manager_default.success(`${successLog}
${deployHint}`);
    return 0;
  }).catch((e2) => {
    output_manager_default.stopSpinner();
    throw e2;
  });
}
function prepareFolder(cwd, folder, force) {
  const dest = path2.join(cwd, folder);
  if (fs.existsSync(dest)) {
    if (!fs.lstatSync(dest).isDirectory()) {
      throw new Error(
        `Destination path "${import_chalk55.default.bold(
          folder
        )}" already exists and is not a directory.`
      );
    }
    if (!force && fs.readdirSync(dest).length !== 0) {
      throw new Error(
        `Destination path "${import_chalk55.default.bold(
          folder
        )}" already exists and is not an empty directory. You may use ${cmd(
          "--force"
        )} or ${cmd("-f")} to override it.`
      );
    }
  } else if (dest !== cwd) {
    try {
      fs.mkdirSync(dest);
    } catch (e2) {
      throw new Error(`Could not create directory "${import_chalk55.default.bold(folder)}".`);
    }
  }
  return dest;
}
async function guess(client, exampleList, name) {
  const GuessError = new Error(
    `No example found for ${import_chalk55.default.bold(name)}, run ${getCommandName(
      "init"
    )} to see the list of available examples.`
  );
  if (client.stdin.isTTY !== true) {
    throw GuessError;
  }
  const found = did_you_mean_default(name, exampleList, 0.7);
  if (typeof found === "string") {
    if (await client.input.confirm(`Did you mean ${import_chalk55.default.bold(found)}?`, false)) {
      return found;
    }
  } else {
    throw GuessError;
  }
}

// src/commands/init/index.ts
var import_error_utils6 = __toESM(require_dist(), 1);

// src/util/telemetry/commands/init/index.ts
var InitTelemetryClient = class extends TelemetryClient {
  trackCliArgumentExample(v, knownValue) {
    if (v) {
      this.trackCliArgument({
        arg: "example",
        value: knownValue ? v : this.redactedValue
      });
    }
  }
  trackCliArgumentDir(v) {
    if (v) {
      this.trackCliArgument({
        arg: "dir",
        value: this.redactedValue
      });
    }
  }
  trackCliFlagForce(v) {
    if (v) {
      this.trackCliFlag("force");
    }
  }
};

// src/commands/init/index.ts
var COMMAND_CONFIG12 = {
  init: ["init"]
};
async function main8(client) {
  let parsedArgs;
  const flagsSpecification = getFlagsSpecification(initCommand.options);
  try {
    parsedArgs = parseArguments(client.argv.slice(2), flagsSpecification);
  } catch (error) {
    printError(error);
    return 1;
  }
  const telemetry2 = new InitTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  if (parsedArgs.flags["--help"]) {
    telemetry2.trackCliFlagHelp("init");
    output_manager_default.print(help(initCommand, { columns: client.stderr.columns }));
    return 2;
  }
  const args = getSubcommand3(parsedArgs.args.slice(1), COMMAND_CONFIG12).args;
  if (parsedArgs.args.length > 3) {
    output_manager_default.error("Too many arguments.");
    return 1;
  }
  telemetry2.trackCliArgumentDir(parsedArgs.args[2]);
  telemetry2.trackCliFlagForce(parsedArgs.flags["--force"]);
  try {
    return await init(client, parsedArgs.flags, args, telemetry2);
  } catch (err) {
    output_manager_default.prettyError(err);
    if ((0, import_error_utils6.isError)(err) && typeof err.stack === "string") {
      output_manager_default.debug(err.stack);
    }
    return 1;
  }
}

// src/commands/inspect/index.ts
var import_error_utils7 = __toESM(require_dist(), 1);
var import_chalk58 = __toESM(require_source(), 1);
var import_ms13 = __toESM(require_ms(), 1);
var import_title = __toESM(require_lib2(), 1);
import { URL as URL2 } from "url";

// src/util/output/builds.ts
var import_chalk56 = __toESM(require_source(), 1);
var import_bytes3 = __toESM(require_bytes(), 1);

// src/util/build-state.ts
var isReady = ({ readyState }) => readyState === "READY";
var isFailed = ({ readyState }) => readyState.endsWith("_ERROR") || readyState === "ERROR";

// src/util/output/builds.ts
var padding = 8;
var MAX_BUILD_GROUPS = 5;
var MAX_OUTPUTS_PER_GROUP = 5;
var hasOutput = (b) => Array.isArray(b.output) && b.output.length > 0;
var getCommonPath = (buildGroup) => {
  const commonPath = [];
  const splits = buildGroup.map(
    (build) => getDirPath(build.entrypoint).split("/")
  );
  const shortest = splits.reduce(
    (prevValue, currentValue) => Math.min(prevValue, currentValue.length),
    Infinity
  );
  for (let i = 0; i <= shortest; i++) {
    const first = splits[0][i];
    if (splits.every((pathParts) => pathParts[i] === first)) {
      commonPath.push(first);
      continue;
    }
    break;
  }
  return commonPath.join("/") || "/";
};
var styleBuild = (build, times, longestSource) => {
  const { entrypoint, id } = build;
  const time = typeof times[id] === "string" ? times[id] : "";
  let pathColor = import_chalk56.default.cyan;
  if (isFailed(build)) {
    pathColor = import_chalk56.default.red;
  }
  const entry = entrypoint.padEnd(longestSource + padding);
  const prefix = hasOutput(build) ? "\u250C" : "\u2576";
  return `${import_chalk56.default.grey(prefix)} ${pathColor(entry)}${time}`;
};
var styleHiddenBuilds = (commonPath, buildGroup, times, longestSource, isHidden2 = false) => {
  const { id } = buildGroup[0];
  const entry = commonPath.padEnd(longestSource + padding);
  const time = typeof times[id] === "string" ? times[id] : "";
  const prefix = isHidden2 === false && buildGroup.some(hasOutput) ? "\u250C" : "\u2576";
  let pathColor = import_chalk56.default.cyan;
  if (buildGroup.every(isFailed)) {
    pathColor = import_chalk56.default.red;
  }
  if (isHidden2) {
    pathColor = import_chalk56.default.grey;
  }
  return `${import_chalk56.default.grey(prefix)} ${pathColor(entry)}${time}`;
};
var styleOutput = (output, readyState, isLast) => {
  const { type, path: path3, size, lambda } = output;
  const prefix = type === "lambda" ? "\u03BB " : "";
  const finalSize = size ? ` ${import_chalk56.default.grey(`(${(0, import_bytes3.default)(size)})`)}` : "";
  let color = import_chalk56.default.grey;
  let finalRegion = "";
  if (isReady({ readyState })) {
    color = import_chalk56.default;
  } else if (isFailed({ readyState })) {
    color = import_chalk56.default.red;
  }
  if (lambda) {
    const { deployedTo } = lambda;
    if (deployedTo && deployedTo.length > 0) {
      finalRegion = ` ${import_chalk56.default.grey(`[${deployedTo.join(", ")}]`)}`;
    }
  }
  const corner = isLast ? "\u2514\u2500\u2500" : "\u251C\u2500\u2500";
  const main17 = prefix + path3 + finalSize + finalRegion;
  return `${import_chalk56.default.grey(corner)} ${color(main17)}`;
};
var getDirPath = (path3, level = 0, highestLevel = null) => {
  const parts = path3.split("/").slice(0, -1);
  if (highestLevel === null || level === 0) {
    return parts.join("/");
  }
  const reverseLevel = highestLevel - level;
  return parts.slice(0, reverseLevel).join("/");
};
var sortByEntrypoint = (a, b) => {
  const aPath = getDirPath(a.entrypoint);
  const bPath = getDirPath(b.entrypoint);
  if (aPath === "") {
    return 1;
  }
  if (bPath === "") {
    return -1;
  }
  if (aPath > bPath) {
    return 1;
  }
  if (bPath > aPath) {
    return -1;
  }
  return 0;
};
var groupBuilds = (buildList, highestLevel, counter) => {
  const currentIndex = counter % buildList.length;
  const __level = Math.ceil(counter / buildList.length);
  const _level = (__level === 0 ? 1 : __level) - 1;
  const level = _level > highestLevel ? highestLevel : _level;
  const currentPath = getDirPath(
    buildList[currentIndex][0].entrypoint,
    level,
    highestLevel
  );
  const nextList = [];
  const currentGroup = [];
  for (let i = 0; i < buildList.length; i++) {
    const group = buildList[i];
    const path3 = getDirPath(group[0].entrypoint, level, highestLevel);
    if (path3 === currentPath) {
      currentGroup.push(...group);
    } else {
      nextList.push(group);
    }
  }
  if (currentIndex === 0) {
    nextList.unshift(currentGroup);
  } else {
    nextList.splice(currentIndex, 0, currentGroup);
  }
  return nextList;
};
var builds_default = (builds, times) => {
  let path3 = builds.sort(sortByEntrypoint).map((build) => [build]);
  const highestLevel = builds.reduce((prev, curr) => {
    const partCounter = curr.entrypoint.split("/").length - 1;
    return partCounter > prev ? partCounter : prev;
  }, 0);
  let counter = 0;
  while (path3.length > MAX_BUILD_GROUPS) {
    path3 = groupBuilds(path3, highestLevel, counter);
    counter++;
  }
  path3 = path3.reverse();
  const longestSource = builds.reduce((final2, current) => {
    const { length } = current.entrypoint;
    return length > final2 ? length : final2;
  }, 0);
  const final = [];
  let finalBuildsLength = path3.length;
  let lengthWithoutRootPaths = path3.length;
  const hiddenBuildGroup = [];
  path3 = (() => {
    const nextList = [];
    const rootList = [];
    for (const group of path3) {
      if (getCommonPath(group) === "/") {
        group.map((item) => rootList.push([item]));
      } else {
        nextList.push(group);
      }
    }
    lengthWithoutRootPaths = nextList.length;
    rootList.map((group) => nextList.push(group));
    return nextList;
  })();
  for (const buildGroup of path3) {
    const commonPath = getCommonPath(buildGroup);
    if (commonPath === "/") {
      if (lengthWithoutRootPaths <= MAX_BUILD_GROUPS && finalBuildsLength <= MAX_BUILD_GROUPS) {
        const item = buildGroup[0];
        final.push(`${styleBuild(item, times, longestSource)}
`);
        finalBuildsLength++;
      } else {
        hiddenBuildGroup.push(buildGroup[0]);
        continue;
      }
    } else if (buildGroup.length === 1) {
      const item = buildGroup[0];
      final.push(`${styleBuild(item, times, longestSource)}
`);
      finalBuildsLength++;
    } else {
      final.push(
        `${styleHiddenBuilds(
          `${commonPath}/*`,
          buildGroup,
          times,
          longestSource
        )}
`
      );
      finalBuildsLength++;
    }
    const outputs = [];
    for (const build of buildGroup) {
      if (Array.isArray(build.output)) {
        outputs.push(...build.output);
      }
    }
    outputs.slice(0, MAX_OUTPUTS_PER_GROUP).forEach(
      (output, index) => final.push(
        `${styleOutput(output, "READY", outputs.length === index + 1)}
`
      )
    );
    if (outputs.length > MAX_OUTPUTS_PER_GROUP) {
      final.push(
        import_chalk56.default.grey(
          `\u2514\u2500\u2500 ${outputs.length - MAX_OUTPUTS_PER_GROUP} output items hidden
`
        )
      );
    }
  }
  if (hiddenBuildGroup.length) {
    final.push(
      `${styleHiddenBuilds(
        `${hiddenBuildGroup.length} builds hidden`,
        hiddenBuildGroup,
        times,
        longestSource,
        true
      )}
`
    );
  }
  return {
    lines: final.length + 1,
    toPrint: `${final.join("")}`
  };
};

// src/util/output/routes.ts
var import_chalk57 = __toESM(require_source(), 1);
var longestProperty = (routes2, name) => {
  const longestItem = routes2.sort((a, b) => {
    const aName = a[name];
    const bName = b[name];
    const firstItem = typeof aName === "string" ? aName.length : 0;
    const secondItem = typeof bName === "string" ? bName.length : 0;
    return secondItem - firstItem;
  })[0];
  const val = longestItem[name];
  return typeof val === "string" ? val.length : 0;
};
function routes(routes2) {
  let toPrint = "";
  const longestSrc = longestProperty(routes2, "src");
  const longestDest = longestProperty(routes2, "dest");
  const padding2 = 6;
  const space = " ".repeat(padding2);
  const destSpace = " ".repeat(longestDest || 10);
  const arrow = import_chalk57.default.grey("->");
  for (const item of routes2) {
    if ("handle" in item) {
      toPrint += `${import_chalk57.default.grey("\u2576")} ${import_chalk57.default.cyan(item.handle)}`;
      continue;
    }
    const { src, dest, status: status3, headers } = item;
    const last = routes2.indexOf(item) === routes2.length - 1;
    const suffix = last ? "" : `
`;
    const finalSrc = import_chalk57.default.cyan(src.padEnd(longestSrc + padding2));
    const finalDest = dest ? `${arrow}${space}${dest}` : `  ${space}${destSpace}`;
    const finalStatus = status3 ? import_chalk57.default.grey(`[${status3}]`) : "";
    let finalHeaders = null;
    if (headers) {
      finalHeaders = `
`;
      const headerKeys = Object.keys(headers);
      for (const header of headerKeys) {
        const value = headers[header];
        const last2 = headerKeys.indexOf(header) === headerKeys.length - 1;
        const suffix2 = last2 ? "" : `
`;
        const prefix2 = import_chalk57.default.grey(last2 ? "\u2514\u2500\u2500" : "\u251C\u2500\u2500");
        finalHeaders += `${prefix2} ${header}: ${value}${suffix2}`;
      }
    }
    const prefix = import_chalk57.default.grey(finalHeaders ? "\u250C" : "\u2576");
    const fill = `${finalSrc}${finalDest}${space}${finalStatus}`;
    toPrint += `${prefix} ${fill}${finalHeaders || ""}${suffix}`;
  }
  return toPrint;
}

// src/util/telemetry/commands/inspect/index.ts
var InspectTelemetryClient = class extends TelemetryClient {
  trackCliArgumentUrlOrDeploymentId(idOrHost) {
    if (idOrHost) {
      this.trackCliArgument({
        arg: "deploymentIdOrHost",
        value: this.redactedValue
      });
    }
  }
  trackCliOptionTimeout(timeout) {
    if (timeout) {
      this.trackCliOption({
        option: "timeout",
        value: this.redactedValue
      });
    }
  }
  trackCliFlagLogs(logs2) {
    if (logs2) {
      this.trackCliFlag("logs");
    }
  }
  trackCliFlagWait(wait) {
    if (wait) {
      this.trackCliFlag("wait");
    }
  }
  trackCliFlagJson(json) {
    if (json) {
      this.trackCliFlag("json");
    }
  }
};

// src/commands/inspect/index.ts
async function inspect3(client) {
  const { print, error, warn } = output_manager_default;
  const telemetry2 = new InspectTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  let parsedArguments;
  const flagsSpecification = getFlagsSpecification(inspectCommand.options);
  try {
    parsedArguments = parseArguments(client.argv.slice(2), flagsSpecification);
  } catch (err) {
    printError(err);
    return 1;
  }
  if (parsedArguments.flags["--help"]) {
    telemetry2.trackCliFlagHelp("inspect");
    print(help(inspectCommand, { columns: client.stderr.columns }));
    return 2;
  }
  if (parsedArguments.args[0] === inspectCommand.name) {
    parsedArguments.args.shift();
  }
  let [deploymentIdOrHost] = parsedArguments.args;
  if (!deploymentIdOrHost) {
    const stdInput = await readStandardInput(client.stdin);
    if (stdInput) {
      deploymentIdOrHost = stdInput;
    }
  }
  if (!deploymentIdOrHost) {
    error(`${getCommandName("inspect <url>")} expects exactly one argument`);
    print(help(inspectCommand, { columns: client.stderr.columns }));
    return 1;
  }
  telemetry2.trackCliArgumentUrlOrDeploymentId(deploymentIdOrHost);
  telemetry2.trackCliOptionTimeout(parsedArguments.flags["--timeout"]);
  telemetry2.trackCliFlagLogs(parsedArguments.flags["--logs"]);
  telemetry2.trackCliFlagWait(parsedArguments.flags["--wait"]);
  telemetry2.trackCliOptionFormat(parsedArguments.flags["--format"]);
  telemetry2.trackCliFlagJson(parsedArguments.flags["--json"]);
  const timeout = (0, import_ms13.default)(parsedArguments.flags["--timeout"] ?? "3m");
  if (timeout === void 0) {
    error(`Invalid timeout "${parsedArguments.flags["--timeout"]}"`);
    return 1;
  }
  let contextName = null;
  try {
    ({ contextName } = await getScope(client));
  } catch (err) {
    if ((0, import_error_utils7.isErrnoException)(err) && (err.code === "NOT_AUTHORIZED" || err.code === "TEAM_DELETED")) {
      error(err.message);
      return 1;
    }
    throw err;
  }
  const until = Date.now() + timeout;
  const wait = parsedArguments.flags["--wait"] ?? false;
  const withLogs = parsedArguments.flags["--logs"];
  const formatResult = validateJsonOutput(parsedArguments.flags);
  if (!formatResult.valid) {
    error(formatResult.error);
    return 1;
  }
  const asJson = formatResult.jsonOutput;
  const startTimestamp = Date.now();
  try {
    deploymentIdOrHost = new URL2(deploymentIdOrHost).hostname;
  } catch {
  }
  output_manager_default.spinner(
    `Fetching deployment "${deploymentIdOrHost}" in ${import_chalk58.default.bold(contextName)}`
  );
  let deployment = await getDeployment(client, contextName, deploymentIdOrHost);
  let abortController;
  if (withLogs && !asJson) {
    let promise;
    ({ abortController, promise } = displayBuildLogs(client, deployment, wait));
    if (wait) {
      promise.catch((error2) => warn(`Failed to read build logs: ${error2}`));
    } else {
      await promise;
    }
  }
  while (wait) {
    await sleep(250);
    deployment = await getDeployment(client, contextName, deploymentIdOrHost);
    if (!isDeploying(deployment.readyState)) {
      abortController?.abort();
      break;
    }
    if (Date.now() > until) {
      warn(`stopped waiting after ${(0, import_ms13.default)(timeout, { long: true })}`);
      abortController?.abort();
      break;
    }
  }
  if (asJson) {
    output_manager_default.stopSpinner();
    await printJson({ deployment, contextName, client });
  } else if (withLogs) {
    print(`${import_chalk58.default.cyan("status")}	${stateString(deployment.readyState)}
`);
  } else {
    await printDetails({ deployment, contextName, client, startTimestamp });
  }
  return exitCode(deployment.readyState);
}
function stateString(s) {
  const CIRCLE = "\u25CF ";
  const sTitle = s && (0, import_title.default)(s);
  switch (s) {
    case "INITIALIZING":
    case "BUILDING":
      return import_chalk58.default.yellow(CIRCLE) + sTitle;
    case "ERROR":
      return import_chalk58.default.red(CIRCLE) + sTitle;
    case "READY":
      return import_chalk58.default.green(CIRCLE) + sTitle;
    case "QUEUED":
      return import_chalk58.default.gray(CIRCLE) + sTitle;
    case "CANCELED":
      return import_chalk58.default.gray(CIRCLE) + sTitle;
    default:
      return import_chalk58.default.gray("UNKNOWN");
  }
}
async function printDetails({
  deployment,
  contextName,
  client,
  startTimestamp
}) {
  output_manager_default.log(
    `Fetched deployment "${import_chalk58.default.bold(deployment.url)}" in ${import_chalk58.default.bold(
      contextName
    )} ${elapsed(Date.now() - startTimestamp)}`
  );
  const {
    id,
    name,
    url,
    createdAt,
    routes: routes2,
    readyState,
    alias: aliases
  } = deployment;
  const { print, link } = output_manager_default;
  const { builds } = deployment.version === 2 ? await client.fetch(`/v11/deployments/${id}/builds`) : { builds: [] };
  print("\n");
  print(import_chalk58.default.bold("  General\n\n"));
  print(`    ${import_chalk58.default.cyan("id")}		${id}
`);
  print(`    ${import_chalk58.default.cyan("name")}	${name}
`);
  const customEnvironmentSlug = deployment.customEnvironment?.slug;
  const target = customEnvironmentSlug ?? deployment.target ?? "preview";
  print(`    ${import_chalk58.default.cyan("target")}	`);
  print(
    deployment.customEnvironment && deployment.team?.slug ? `${link(
      `${target}`,
      `https://vercel.com/${deployment.team.slug}/${name}/settings/environments/${deployment.customEnvironment.id}`,
      { fallback: () => target, color: false }
    )}
` : `${target}
`
  );
  print(`    ${import_chalk58.default.cyan("status")}	${stateString(readyState)}
`);
  print(`    ${import_chalk58.default.cyan("url")}		https://${url}
`);
  if (createdAt) {
    print(
      `    ${import_chalk58.default.cyan("created")}	${new Date(createdAt)} ${elapsed(
        Date.now() - createdAt,
        true
      )}
`
    );
  }
  print("\n\n");
  if (aliases !== void 0 && aliases.length > 0) {
    print(import_chalk58.default.bold("  Aliases\n\n"));
    let aliasList = "";
    for (const alias2 of aliases) {
      aliasList += `${import_chalk58.default.gray("\u2576")} https://${alias2}
`;
    }
    print(indent_default(aliasList, 4));
    print("\n\n");
  }
  if (builds.length > 0) {
    const times = {};
    for (const build of builds) {
      const { id: id2, createdAt: createdAt2, readyStateAt } = build;
      times[id2] = createdAt2 && readyStateAt ? elapsed(readyStateAt - createdAt2) : null;
    }
    print(import_chalk58.default.bold("  Builds\n\n"));
    print(indent_default(builds_default(builds, times).toPrint, 4));
    print("\n\n");
  }
  if (Array.isArray(routes2) && routes2.length > 0) {
    print(import_chalk58.default.bold("  Routes\n\n"));
    print(indent_default(routes(routes2), 4));
    print(`

`);
  }
}
async function printJson({
  deployment,
  contextName,
  client
}) {
  const {
    id,
    name,
    url,
    createdAt,
    routes: routes2,
    readyState,
    alias: aliases,
    target,
    customEnvironment
  } = deployment;
  const { builds } = deployment.version === 2 ? await client.fetch(`/v11/deployments/${id}/builds`) : { builds: [] };
  const jsonOutput = {
    id,
    name,
    url,
    target: customEnvironment?.slug ?? target ?? "preview",
    readyState,
    createdAt,
    ...aliases && aliases.length > 0 && { aliases },
    ...builds.length > 0 && { builds },
    ...Array.isArray(routes2) && routes2.length > 0 && { routes: routes2 },
    ...contextName && { contextName }
  };
  client.stdout.write(`${JSON.stringify(jsonOutput, null, 2)}
`);
}
function exitCode(state) {
  if (state === "ERROR" || state === "CANCELED") {
    return 1;
  }
  return 0;
}

// src/commands/integration/add.ts
var import_chalk62 = __toESM(require_source(), 1);
var import_open3 = __toESM(require_open(), 1);

// src/util/integration/post-provision-setup.ts
var import_chalk59 = __toESM(require_source(), 1);
var VALID_ENVIRONMENTS4 = [
  "production",
  "preview",
  "development"
];
function validateEnvironments(environments) {
  const invalid = environments.filter(
    (env) => !VALID_ENVIRONMENTS4.includes(env)
  );
  if (invalid.length > 0) {
    return { valid: false, invalid };
  }
  return { valid: true };
}
async function postProvisionSetup(client, resourceName, resourceId, contextName, options = {}) {
  const dashboardUrl = `https://vercel.com/${contextName}/~/stores/integration/${resourceId}`;
  output_manager_default.log(
    indent_default(`Dashboard: ${output_manager_default.link(dashboardUrl, dashboardUrl)}`, 4)
  );
  if (options.noConnect) {
    return 0;
  }
  const linkedProject = await getLinkedProject(client);
  if (linkedProject.status === "error") {
    return linkedProject.exitCode;
  }
  if (linkedProject.status === "not_linked") {
    return 0;
  }
  const { project } = linkedProject;
  const environments = [
    ...new Set(
      options.environments && options.environments.length > 0 ? options.environments : [...VALID_ENVIRONMENTS4]
    )
  ];
  output_manager_default.debug(`Selected environments: ${JSON.stringify(environments)}`);
  output_manager_default.spinner(
    `Connecting ${import_chalk59.default.bold(resourceName)} to ${import_chalk59.default.bold(project.name)}...`
  );
  output_manager_default.debug(`Connecting resource ${resourceId} to project ${project.id}`);
  try {
    await connectResourceToProject(
      client,
      project.id,
      resourceId,
      environments
    );
  } catch (error) {
    output_manager_default.stopSpinner();
    output_manager_default.error(`Failed to connect: ${error.message}`);
    return 1;
  }
  output_manager_default.stopSpinner();
  output_manager_default.log(
    `${import_chalk59.default.bold(resourceName)} successfully connected to ${import_chalk59.default.bold(project.name)}`
  );
  if (!options.noEnvPull) {
    const pullExitCode = await pull(
      client,
      ["--yes"],
      "vercel-cli:integration:add"
    );
    if (pullExitCode !== 0) {
      output_manager_default.warn(
        "Failed to pull environment variables. You can run `vercel env pull` manually."
      );
    }
  }
  return 0;
}
async function getLinkedProjectField(client, noConnect, field = "name") {
  if (noConnect) {
    return { value: void 0 };
  }
  const linkedProject = await getLinkedProject(client);
  if (linkedProject.status === "error") {
    return { value: void 0, exitCode: linkedProject.exitCode };
  }
  if (linkedProject.status === "linked") {
    return { value: linkedProject.project[field] };
  }
  return { value: void 0 };
}

// src/util/integration/prompt-for-terms.ts
var MARKETPLACE_ADDENDUM_URL = "https://vercel.com/legal/integration-marketplace-end-users-addendum";
async function promptForTermAcceptance(client, integration) {
  if (client.isAgent) {
    output_manager_default.error(
      "Term acceptance cannot be performed by an AI agent. Run this command directly in your terminal."
    );
    return null;
  }
  if (!client.stdin.isTTY) {
    output_manager_default.error(
      "Term acceptance requires an interactive terminal. Run this command in a TTY."
    );
    return null;
  }
  const addendumAccepted = await client.input.confirm(
    `Accept Vercel Marketplace End User Addendum? (${MARKETPLACE_ADDENDUM_URL})`,
    false
  );
  if (!addendumAccepted) {
    output_manager_default.error(
      "Vercel Marketplace End User Addendum must be accepted to continue."
    );
    return null;
  }
  const acceptedPolicies = {
    toc: (/* @__PURE__ */ new Date()).toISOString()
  };
  if (integration.privacyDocUri) {
    const accepted = await client.input.confirm(
      `Accept privacy policy? (${integration.privacyDocUri})`,
      false
    );
    if (!accepted) {
      output_manager_default.error("Privacy policy must be accepted to continue.");
      return null;
    }
    acceptedPolicies.privacy = (/* @__PURE__ */ new Date()).toISOString();
  }
  if (integration.eulaDocUri) {
    const accepted = await client.input.confirm(
      `Accept terms of service? (${integration.eulaDocUri})`,
      false
    );
    if (!accepted) {
      output_manager_default.error("Terms of service must be accepted to continue.");
      return null;
    }
    acceptedPolicies.eula = (/* @__PURE__ */ new Date()).toISOString();
  }
  return acceptedPolicies;
}

// src/commands/integration/wizard.ts
var supportedUIControls = /* @__PURE__ */ new Set([
  "input",
  "select",
  "region",
  "vercel-region"
]);
function createHiddenStep(key, schema) {
  if (schema["ui:hidden"] !== true && schema["ui:hidden"] !== "create") {
    throw new Error(
      `HiddenStep: Expected "ui:hidden" to have value 'true' or '"create"' for key "${key}", but was "${schema["ui:hidden"]}"`
    );
  }
  return {
    key,
    run: async () => {
      const value = schema.default;
      return [key, value];
    }
  };
}
function createInputStep(key, schema) {
  if (schema["ui:control"] !== "input") {
    throw new Error(
      `InputStep: Expected control "input" for key "${key}", but was "${schema["ui:control"]}"`
    );
  }
  switch (schema.type) {
    case "string": {
      return {
        key,
        run: async (client) => {
          const value = await client.input.text({
            message: schema["ui:placeholder"] || schema["ui:label"] || key,
            default: schema.default
          });
          return [key, value];
        }
      };
    }
    case "number": {
      return {
        key,
        run: async (client) => {
          const value = await client.input.text({
            message: schema["ui:placeholder"] || schema["ui:label"] || key,
            default: schema.default,
            validate: (value2) => {
              const number = Number(value2);
              if (Number.isNaN(number)) {
                return `Value "${value2}" must be a number.`;
              }
              if (schema.minimum !== void 0 && schema.minimum > number) {
                return `Value "${value2}" must be greater or equal ${schema.minimum}.`;
              }
              if (schema.maximum !== void 0 && schema.maximum < number) {
                return `Value "${value2}" must be smaller or equal ${schema.maximum}.`;
              }
              return true;
            }
          });
          return [key, value];
        }
      };
    }
    default: {
      throw new Error(
        `[Input Step] Unsupported schema type for input control of key "${key}": ${schema.type}`
      );
    }
  }
}
function createSelectStep(key, schema) {
  if (!["select", "region", "vercel-region"].includes(schema["ui:control"])) {
    throw new Error(
      `SelectStep: Expected control "select", "region" or "vercel-region", but was "${schema["ui:control"]}"`
    );
  }
  if (!schema["ui:options"]?.length) {
    throw new Error(
      `SelectStep: Expected control for key "${key}" to have options, but was ${JSON.stringify(schema["ui:options"])}`
    );
  }
  const options = schema["ui:options"];
  const choices = [];
  const defaultValue = schema.default;
  for (const option of options) {
    if (typeof option === "string") {
      choices.push({
        name: option,
        value: option,
        short: option,
        selected: Boolean(defaultValue && option === defaultValue)
      });
    } else {
      if (option.hidden) {
        continue;
      }
      choices.push({
        name: option.label,
        value: option.value,
        short: option.label,
        selected: Boolean(defaultValue && option.value === defaultValue)
      });
    }
  }
  return {
    key,
    run: async (client) => {
      const value = await list(client, {
        message: schema["ui:placeholder"] || schema["ui:label"] || key,
        choices
      });
      return [key, value];
    }
  };
}
function createMetadataWizard(metadataSchema) {
  const properties = metadataSchema.properties;
  let isSupported = true;
  let allFieldsAreReadonly = true;
  const steps = [];
  for (const [key, schema] of Object.entries(properties)) {
    try {
      if (isHidden(schema)) {
        steps.push(createHiddenStep(key, schema));
        continue;
      }
      if (isDisabled(schema)) {
        continue;
      }
      if (!supportedUIControls.has(schema["ui:control"])) {
        isSupported = false;
        break;
      }
      if (!isReadOnly(schema)) {
        allFieldsAreReadonly = false;
      }
    } catch (error) {
      if (error instanceof ExpressionError) {
        isSupported = false;
        break;
      }
      throw error;
    }
    switch (schema["ui:control"]) {
      case "input": {
        steps.push(createInputStep(key, schema));
        break;
      }
      case "region":
      case "vercel-region":
      case "select": {
        steps.push(createSelectStep(key, schema));
        break;
      }
      default: {
        throw new Error(
          `Unsupported metadata control: ${schema["ui:control"]}`
        );
      }
    }
  }
  return {
    isSupported,
    run: async (client, initialValues) => allFieldsAreReadonly ? getMetadataFromReadOnlyFields(metadataSchema) : getMetadataFromSteps(client, steps, initialValues)
  };
}
function getMetadataFromReadOnlyFields(metadataSchema) {
  const metadata = {};
  for (const [key, schema] of Object.entries(metadataSchema.properties)) {
    if (isHidden(schema)) {
      continue;
    }
    if (!isReadOnly(schema)) {
      throw new Error(`Field "${key}" must be read-only.`);
    }
    metadata[key] = schema.default;
  }
  return metadata;
}
async function getMetadataFromSteps(client, steps, initialValues) {
  const metadataEntries = [];
  for (const step of steps) {
    if (initialValues && initialValues[step.key] !== void 0) {
      metadataEntries.push([step.key, initialValues[step.key]]);
    } else {
      metadataEntries.push(await step.run(client));
    }
  }
  return Object.fromEntries(metadataEntries);
}
function isHidden(schema) {
  if (instanceOfExpression(schema["ui:hidden"])) {
    throw new ExpressionError("Expression found in schema");
  }
  return Boolean(
    schema["ui:hidden"] === true || schema["ui:hidden"] === "create"
  );
}
function isReadOnly(schema) {
  if (instanceOfExpression(schema["ui:read-only"])) {
    throw new ExpressionError("Expression found in schema");
  }
  return Boolean(
    schema["ui:read-only"] === true || schema["ui:read-only"] === "create"
  );
}
function isDisabled(schema) {
  if (instanceOfExpression(schema["ui:disabled"])) {
    throw new ExpressionError("Expression found in schema");
  }
  return Boolean(
    schema["ui:disabled"] === true || schema["ui:disabled"] === "create"
  );
}
function instanceOfExpression(obj) {
  const checkedAsObject = Object(obj);
  if (obj !== checkedAsObject) {
    return false;
  }
  return "expr" in checkedAsObject;
}
var ExpressionError = class extends Error {
};

// src/util/integration/provision-store-resource.ts
async function provisionStoreResource(client, installationId, productId, billingPlanId, name, metadata, authorizationId) {
  return await client.fetch(
    "/v1/storage/stores/integration",
    {
      method: "POST",
      json: true,
      body: {
        billingPlanId,
        integrationConfigurationId: installationId,
        integrationProductIdOrSlug: productId,
        metadata,
        name,
        authorizationId,
        source: "cli"
      }
    }
  );
}

// src/util/integration/generate-resource-name.ts
var COLORS = [
  "gray",
  "red",
  "rose",
  "yellow",
  "amber",
  "green",
  "lime",
  "emerald",
  "blue",
  "cyan",
  "purple",
  "violet",
  "fuchsia",
  "orange",
  "pink",
  "indigo",
  "teal",
  "sky",
  "aero",
  "alizarin",
  "almond",
  "amethyst",
  "apricot",
  "aqua",
  "aquamarine",
  "aureolin",
  "beige",
  "bisque",
  "bistre",
  "bole",
  "bronze",
  "byzantine",
  "byzantium",
  "camel",
  "canary",
  "carmine",
  "celeste",
  "cerise",
  "cerulean",
  "champagne",
  "charcoal",
  "chestnut",
  "cinereous",
  "cinnabar",
  "citrine",
  "citron",
  "claret",
  "cobalt",
  "coffee",
  "copper",
  "coquelicot",
  "coral",
  "cordovan",
  "crimson",
  "cyclamen",
  "erin",
  "fulvous"
];
var NOUNS = [
  "apple",
  "ball",
  "car",
  "dog",
  "elephant",
  "flower",
  "garden",
  "house",
  "island",
  "jacket",
  "kite",
  "lamp",
  "mountain",
  "notebook",
  "ocean",
  "park",
  "queen",
  "river",
  "school",
  "tree",
  "umbrella",
  "village",
  "window",
  "xylophone",
  "yacht",
  "zebra",
  "book",
  "chair",
  "door",
  "grass",
  "anchor",
  "arrow",
  "basket",
  "battery",
  "bell",
  "blanket",
  "branch",
  "bridge",
  "brush",
  "bucket",
  "button",
  "cable",
  "candle",
  "canvas",
  "castle",
  "cave",
  "clock",
  "cloud",
  "coin",
  "compass",
  "crystal",
  "curtain",
  "cushion",
  "desert",
  "diamond",
  "drawer",
  "drum",
  "engine",
  "envelope",
  "feather",
  "fence",
  "ferry",
  "field",
  "flame",
  "flask",
  "forest",
  "fountain",
  "globe",
  "harbor",
  "helmet",
  "horizon",
  "kettle",
  "ladder",
  "lantern",
  "leaf",
  "lens",
  "lever",
  "lighthouse",
  "magnet",
  "marble",
  "mirror",
  "nest",
  "paddle",
  "pebble",
  "pendant",
  "pillar",
  "pillow",
  "planet",
  "plank",
  "pocket",
  "prism",
  "ribbon",
  "ridge",
  "saddle",
  "sail"
];
function randomElement(arr) {
  return arr[Math.floor(arr.length * Math.random())];
}
function generateRandomNameSuffix() {
  return `${randomElement(COLORS)}-${randomElement(NOUNS)}`;
}
function generateDefaultResourceName(productSlug, maxLength = 128) {
  const suffix = generateRandomNameSuffix();
  const fullName = `${productSlug}-${suffix}`;
  if (fullName.length <= maxLength) {
    return fullName;
  }
  return fullName.slice(0, maxLength).replace(/-+$/, "");
}
var DEFAULT_VALIDATION_RULE = {
  minLength: 1,
  maxLength: 128,
  pattern: /^[a-zA-Z0-9_-]*$/,
  patternErrorMessage: "Resource name can only contain letters, numbers, underscores, and hyphens"
};
var VALIDATION_RULES = {
  "aws-dsql": {
    minLength: 1,
    maxLength: 128,
    pattern: /^[a-zA-Z0-9_-]*$/,
    patternErrorMessage: "Resource name can only contain letters, numbers, underscores, and hyphens"
  },
  "aws-apg": {
    minLength: 1,
    maxLength: 50,
    pattern: /^[a-zA-Z][a-zA-Z0-9-]*$/,
    patternErrorMessage: "Resource name must start with a letter and can only contain letters, numbers, and hyphens",
    customValidation: (name) => {
      if (name.endsWith("-")) {
        return "Resource name cannot end with a hyphen";
      }
      if (name.includes("--")) {
        return "Resource name cannot contain consecutive hyphens";
      }
      return void 0;
    }
  },
  "aws-dynamodb": {
    minLength: 3,
    maxLength: 128,
    pattern: /^[a-zA-Z0-9_-]*$/,
    patternErrorMessage: "Resource name can only contain letters, numbers, underscores, and hyphens"
  }
};
function getValidationRuleForProduct(productSlug) {
  if (!productSlug) {
    return DEFAULT_VALIDATION_RULE;
  }
  return VALIDATION_RULES[productSlug.toLowerCase()] ?? DEFAULT_VALIDATION_RULE;
}
function validateResourceName(name, productSlug) {
  const rule = getValidationRuleForProduct(productSlug);
  if (!name || name.trim().length === 0) {
    return "Resource name cannot be empty";
  }
  if (name.length < rule.minLength) {
    return `Resource name must be at least ${rule.minLength} character${rule.minLength === 1 ? "" : "s"}`;
  }
  if (name.length > rule.maxLength) {
    return `Resource name cannot exceed ${rule.maxLength} characters`;
  }
  if (!rule.pattern.test(name)) {
    return rule.patternErrorMessage;
  }
  if (rule.customValidation) {
    const customError = rule.customValidation(name);
    if (customError) {
      return customError;
    }
  }
  return void 0;
}
function resolveResourceName(productSlug, resourceNameArg) {
  const rule = getValidationRuleForProduct(productSlug);
  const isAutoGenerated = resourceNameArg === void 0;
  const resourceName = resourceNameArg ?? generateDefaultResourceName(productSlug, rule.maxLength);
  const validationError = validateResourceName(resourceName, productSlug);
  if (validationError) {
    return {
      error: isAutoGenerated ? `${validationError}. Use --name to provide a valid resource name.` : validationError
    };
  }
  return { resourceName };
}

// src/util/integration/format-schema-help.ts
var import_chalk60 = __toESM(require_source(), 1);
function isHiddenOnCreate(prop) {
  return prop["ui:hidden"] === true || prop["ui:hidden"] === "create";
}
function getAllOptionValues(prop) {
  const raw = prop["ui:options"];
  if (!raw)
    return void 0;
  const values = raw.map(
    (opt) => typeof opt === "string" ? opt : opt.value
  );
  return values.length > 0 ? values : void 0;
}
function getVisibleOptions(prop) {
  const raw = prop["ui:options"];
  if (!raw)
    return void 0;
  const options = [];
  for (const opt of raw) {
    if (typeof opt === "string") {
      if (opt)
        options.push(opt);
    } else if (!opt.hidden && opt.value) {
      options.push(opt.value);
    }
  }
  return options.length > 0 ? options : void 0;
}
function generateExample(key, prop) {
  if (prop.type === "boolean") {
    return `-m ${key}=true`;
  }
  if (prop.type === "array") {
    const options2 = getVisibleOptions(prop);
    if (options2 && options2.length >= 2) {
      return `-m "${key}=${options2[0]},${options2[1]}"`;
    }
    if (options2 && options2.length === 1) {
      return `-m "${key}=${options2[0]}"`;
    }
    if (prop.items?.type === "number") {
      if (prop.default !== void 0) {
        return `-m ${key}=${prop.default}`;
      }
      return `-m ${key}=N,N`;
    }
    return `-m "${key}=value1,value2"`;
  }
  if (prop.type === "number") {
    if (prop.default !== void 0) {
      return `-m ${key}=${prop.default}`;
    }
    if (prop.minimum !== void 0) {
      return `-m ${key}=${prop.minimum}`;
    }
    return `-m ${key}=N`;
  }
  const options = getVisibleOptions(prop);
  if (options && options.length > 0) {
    return `-m ${key}=${options[0]}`;
  }
  return `-m ${key}=<value>`;
}
function formatMetadataSchemaHelp(schema, integrationName, productSlug) {
  const lines = [];
  lines.push("");
  const header = productSlug ? `  Metadata options for "${integrationName}/${productSlug}":` : `  Metadata options for "${integrationName}":`;
  lines.push(import_chalk60.default.bold(header));
  lines.push("");
  const required = new Set(schema.required ?? []);
  const entries = Object.entries(schema.properties);
  if (entries.length === 0) {
    lines.push("    No metadata options available.");
    return lines.join("\n");
  }
  for (const [key, prop] of entries) {
    if (isHiddenOnCreate(prop)) {
      continue;
    }
    const isRequired = required.has(key);
    const requiredSuffix = isRequired ? import_chalk60.default.red(" (required)") : "";
    const typeHint = prop.type === "boolean" ? import_chalk60.default.dim(" (true/false)") : prop.type === "array" ? import_chalk60.default.dim(" (comma-separated)") : "";
    lines.push(`    ${import_chalk60.default.cyan(key)}${requiredSuffix}${typeHint}`);
    if (prop.description) {
      lines.push(`      ${prop.description}`);
    }
    const visibleOptions = getVisibleOptions(prop);
    if (visibleOptions) {
      lines.push(`      Options: ${visibleOptions.join(", ")}`);
    }
    if (prop.minimum !== void 0 || prop.maximum !== void 0) {
      const range = [];
      if (prop.minimum !== void 0)
        range.push(`min: ${prop.minimum}`);
      if (prop.maximum !== void 0)
        range.push(`max: ${prop.maximum}`);
      lines.push(`      Range: ${range.join(", ")}`);
    }
    if (prop.default !== void 0) {
      lines.push(`      Default: ${prop.default}`);
    }
    const example = generateExample(key, prop);
    if (example) {
      lines.push(`      Example: ${import_chalk60.default.dim(example)}`);
    }
    lines.push("");
  }
  return lines.join("\n");
}

// src/util/integration/parse-metadata.ts
function parseMetadataFlags(rawMetadata, schema) {
  const metadata = {};
  const errors = [];
  if (!rawMetadata?.length) {
    return { metadata, errors };
  }
  for (const item of rawMetadata) {
    const eqIndex = item.indexOf("=");
    if (eqIndex === -1) {
      errors.push(`Invalid metadata format: "${item}". Expected KEY=VALUE`);
      continue;
    }
    const key = item.slice(0, eqIndex);
    const value = item.slice(eqIndex + 1);
    const propSchema = schema.properties[key];
    if (!propSchema) {
      errors.push(`Unknown metadata key: "${key}"`);
      continue;
    }
    if (propSchema.type === "boolean") {
      if (value === "true") {
        metadata[key] = true;
      } else if (value === "false") {
        metadata[key] = false;
      } else {
        errors.push(
          `Metadata "${key}" must be "true" or "false", got: "${value}"`
        );
        continue;
      }
    } else if (propSchema.type === "number") {
      if (value === "") {
        errors.push(`Metadata "${key}" must be a number, got: ""`);
        continue;
      }
      const num = Number(value);
      if (Number.isNaN(num) || !Number.isFinite(num)) {
        errors.push(`Metadata "${key}" must be a number, got: "${value}"`);
        continue;
      }
      if (propSchema.minimum !== void 0 && num < propSchema.minimum) {
        errors.push(`Metadata "${key}" must be >= ${propSchema.minimum}`);
        continue;
      }
      if (propSchema.maximum !== void 0 && num > propSchema.maximum) {
        errors.push(`Metadata "${key}" must be <= ${propSchema.maximum}`);
        continue;
      }
      metadata[key] = num;
    } else if (propSchema.type === "array") {
      const items = value.split(",").map((v) => v.trim());
      const itemType = propSchema.items?.type;
      if (itemType === "number") {
        const nums = [];
        let hasError = false;
        for (const item2 of items) {
          if (item2 === "") {
            errors.push(`Metadata "${key}" contains invalid number: ""`);
            hasError = true;
            break;
          }
          const num = Number(item2);
          if (Number.isNaN(num) || !Number.isFinite(num)) {
            errors.push(`Metadata "${key}" contains invalid number: "${item2}"`);
            hasError = true;
            break;
          }
          if (propSchema.minimum !== void 0 && num < propSchema.minimum) {
            errors.push(
              `Metadata "${key}" contains number ${num} below minimum ${propSchema.minimum}`
            );
            hasError = true;
            break;
          }
          if (propSchema.maximum !== void 0 && num > propSchema.maximum) {
            errors.push(
              `Metadata "${key}" contains number ${num} above maximum ${propSchema.maximum}`
            );
            hasError = true;
            break;
          }
          nums.push(num);
        }
        if (!hasError) {
          metadata[key] = nums;
        }
      } else {
        const validValues = getAllOptionValues(propSchema);
        if (validValues) {
          const prevErrorCount = errors.length;
          for (const item2 of items) {
            if (!validValues.includes(item2)) {
              errors.push(
                `Metadata "${key}" contains invalid value: "${item2}". Must be one of: ${validValues.join(", ")}`
              );
            }
          }
          if (errors.length > prevErrorCount) {
            continue;
          }
        }
        metadata[key] = items;
      }
    } else {
      const validValues = getAllOptionValues(propSchema);
      if (validValues) {
        if (!validValues.includes(value)) {
          errors.push(
            `Metadata "${key}" must be one of: ${validValues.join(", ")}`
          );
          continue;
        }
      }
      metadata[key] = value;
    }
  }
  return { metadata, errors };
}
function validateRequiredMetadata(metadata, schema) {
  const errors = [];
  const required = schema.required ?? [];
  for (const key of required) {
    const propSchema = schema.properties[key];
    if (propSchema && isHiddenOnCreate(propSchema)) {
      continue;
    }
    if (metadata[key] === void 0 && propSchema?.default === void 0) {
      errors.push(`Required metadata missing: "${key}"`);
    }
  }
  return errors;
}
function validateAndPrintRequiredMetadata(metadata, schema) {
  const errors = validateRequiredMetadata(metadata, schema);
  for (const error of errors) {
    output_manager_default.error(error);
  }
  return errors.length === 0;
}

// src/commands/integration/add-auto-provision.ts
var import_chalk61 = __toESM(require_source(), 1);
var import_open2 = __toESM(require_open(), 1);

// src/util/integration/auto-provision-resource.ts
function isAutoProvisionFallback(error) {
  return typeof error === "object" && error !== null && "kind" in error && ["metadata", "unknown"].includes(
    error.kind
  ) && "url" in error && "integration" in error && "product" in error;
}
async function autoProvisionResource(client, integrationSlug, productSlug, name, metadata, acceptedPolicies, billingPlanId) {
  const endpoint = `/v1/integrations/integration/${encodeURIComponent(integrationSlug)}/marketplace/auto-provision/${encodeURIComponent(productSlug)}`;
  const body = {
    name,
    metadata,
    acceptedPolicies,
    source: "cli",
    ...billingPlanId ? { billingPlanId } : {}
  };
  output_manager_default.debug(`Auto-provision request: POST ${endpoint}`);
  output_manager_default.debug(`Auto-provision body: ${JSON.stringify(body, null, 2)}`);
  try {
    const res = await client.fetch(endpoint, {
      method: "POST",
      json: false,
      body
    });
    if (res.ok) {
      return res.json();
    }
    throw new Error(`Auto-provision failed: ${res.status}`);
  } catch (error) {
    if (error instanceof APIError && error.status === 422 && isAutoProvisionFallback(error)) {
      output_manager_default.debug(`Auto-provision returned 422 fallback response`);
      return error;
    }
    output_manager_default.debug(`Auto-provision error: ${error}`);
    throw error;
  }
}

// src/util/integration/fetch-integration.ts
async function fetchIntegration(client, slug) {
  return client.fetch(`/v2/integrations/integration/${slug}`, {
    json: true
  });
}
async function fetchIntegrationWithTelemetry(client, integrationSlug, telemetry2) {
  let knownIntegrationSlug = false;
  try {
    const integration = await fetchIntegration(client, integrationSlug);
    knownIntegrationSlug = true;
    return integration;
  } catch (error) {
    output_manager_default.error(
      `Failed to get integration "${integrationSlug}": ${error.message}`
    );
    return null;
  } finally {
    telemetry2.trackCliArgumentIntegration(
      integrationSlug,
      knownIntegrationSlug
    );
  }
}

// src/util/integration/fetch-installations.ts
async function fetchInstallations(client, integration) {
  const searchParams = new URLSearchParams();
  searchParams.set("view", "account");
  searchParams.set("installationType", "marketplace");
  searchParams.set("integrationIdOrSlug", integration.id);
  return client.fetch(
    `/v2/integrations/configurations?${searchParams}`,
    {
      json: true
    }
  );
}

// src/util/integration/select-product.ts
async function selectProduct(client, products, productSlug) {
  if (productSlug) {
    const match = products.find((p) => p.slug === productSlug);
    if (!match) {
      const available = products.map((p) => p.slug).join(", ");
      output_manager_default.error(
        `Product "${productSlug}" not found. Available products: ${available}`
      );
      return;
    }
    return match;
  }
  if (products.length === 1) {
    return products[0];
  }
  return client.input.select({
    message: "Select a product",
    choices: products.map((p) => ({
      name: p.name,
      value: p,
      description: p.shortDescription
    }))
  });
}

// src/util/telemetry/commands/integration/add.ts
var IntegrationAddTelemetryClient = class extends TelemetryClient {
  trackCliArgumentIntegration(v, known) {
    if (v) {
      this.trackCliArgument({
        arg: "integration",
        value: known ? v : this.redactedValue
      });
    }
  }
  trackCliOptionName(v) {
    if (v) {
      this.trackCliOption({
        option: "name",
        value: this.redactedValue
      });
    }
  }
  trackCliOptionMetadata(v) {
    if (v?.length) {
      this.trackCliOption({
        option: "metadata",
        value: this.redactedValue
      });
    }
  }
  trackCliOptionPlan(v) {
    if (v) {
      this.trackCliOption({
        option: "plan",
        value: this.redactedValue
      });
    }
  }
  trackCliFlagNoConnect(v) {
    if (v) {
      this.trackCliFlag("no-connect");
    }
  }
  trackCliFlagNoEnvPull(v) {
    if (v) {
      this.trackCliFlag("no-env-pull");
    }
  }
  trackCliOptionEnvironment(v) {
    if (v?.length) {
      this.trackCliOption({
        option: "environment",
        value: this.redactedValue
      });
    }
  }
};

// src/commands/integration/add-auto-provision.ts
async function addAutoProvision(client, integrationSlug, resourceNameArg, options = {}) {
  const telemetry2 = new IntegrationAddTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  telemetry2.trackCliOptionName(resourceNameArg);
  telemetry2.trackCliOptionMetadata(options.metadata);
  telemetry2.trackCliFlagNoConnect(options.noConnect);
  telemetry2.trackCliFlagNoEnvPull(options.noEnvPull);
  telemetry2.trackCliOptionPlan(options.billingPlanId);
  telemetry2.trackCliOptionEnvironment(options.environments);
  const { contextName, team } = await getScope(client);
  if (!team) {
    output_manager_default.error("Team not found");
    return 1;
  }
  const integration = await fetchIntegrationWithTelemetry(
    client,
    integrationSlug,
    telemetry2
  );
  if (!integration) {
    return 1;
  }
  if (!integration.products?.length) {
    output_manager_default.error(
      `Integration "${integrationSlug}" is not a Marketplace integration`
    );
    return 1;
  }
  if (!options.productSlug && integration.products.length > 1 && !client.stdin.isTTY) {
    const choices = integration.products.map((p) => `  ${integrationSlug}/${p.slug}`).join("\n");
    output_manager_default.error(
      `Integration "${integrationSlug}" has multiple products. Specify one with:

${choices}

Example: vercel integration add ${integrationSlug}/${integration.products[0].slug}`
    );
    return 1;
  }
  const [productResult, installationsResult] = await Promise.allSettled([
    selectProduct(client, integration.products, options.productSlug),
    fetchInstallations(client, integration)
  ]);
  if (productResult.status === "rejected") {
    output_manager_default.error(
      `Failed to select product: ${productResult.reason.message}`
    );
    return 1;
  }
  if (!productResult.value) {
    return 1;
  }
  if (installationsResult.status === "rejected") {
    output_manager_default.error(
      `Failed to get integration installations: ${installationsResult.reason.message}`
    );
    return 1;
  }
  const product = productResult.value;
  const installations = installationsResult.value;
  output_manager_default.log(
    `Installing ${import_chalk61.default.bold(product.name)} by ${import_chalk61.default.bold(integration.name)} under ${import_chalk61.default.bold(contextName)}`
  );
  output_manager_default.debug(`Selected product: ${product.slug} (id: ${product.id})`);
  output_manager_default.debug(
    `Product metadataSchema: ${JSON.stringify(product.metadataSchema, null, 2)}`
  );
  const teamInstallation = installations.find(
    (i) => i.ownerId === team.id && i.installationType === "marketplace"
  );
  let acceptedPolicies = {};
  if (!teamInstallation) {
    const policies = await promptForTermAcceptance(client, integration);
    if (!policies) {
      return 1;
    }
    acceptedPolicies = policies;
  }
  let metadata;
  if (options.metadata?.length) {
    output_manager_default.debug(
      `Parsing metadata from flags: ${JSON.stringify(options.metadata)}`
    );
    const { metadata: parsed, errors } = parseMetadataFlags(
      options.metadata,
      product.metadataSchema
    );
    if (errors.length) {
      for (const error of errors) {
        output_manager_default.error(error);
      }
      return 1;
    }
    if (!validateAndPrintRequiredMetadata(parsed, product.metadataSchema)) {
      return 1;
    }
    metadata = parsed;
  } else {
    metadata = {};
  }
  const nameResult = resolveResourceName(product.slug, resourceNameArg);
  if ("error" in nameResult) {
    output_manager_default.error(nameResult.error);
    return 1;
  }
  const { resourceName } = nameResult;
  output_manager_default.debug(`Collected metadata: ${JSON.stringify(metadata)}`);
  output_manager_default.debug(`Resource name: ${resourceName}`);
  output_manager_default.spinner("Provisioning resource...");
  let result;
  try {
    result = await autoProvisionResource(
      client,
      integration.slug,
      product.slug,
      resourceName,
      metadata,
      acceptedPolicies,
      options.billingPlanId
    );
  } catch (error) {
    output_manager_default.stopSpinner();
    output_manager_default.error(error.message);
    return 1;
  }
  output_manager_default.stopSpinner();
  output_manager_default.debug(`Auto-provision result: ${JSON.stringify(result, null, 2)}`);
  if (result.kind !== "provisioned") {
    output_manager_default.debug(`Fallback required - kind: ${result.kind}`);
    output_manager_default.debug(`Fallback URL from API: ${result.url}`);
    const projectLink = await getLinkedProjectField(
      client,
      options.noConnect,
      "name"
    );
    if (projectLink.exitCode !== void 0) {
      return projectLink.exitCode;
    }
    output_manager_default.log("Additional setup required. Opening browser...");
    const url = new URL(result.url);
    url.searchParams.set("defaultResourceName", resourceName);
    url.searchParams.set("source", "cli");
    if (Object.keys(metadata).length > 0) {
      url.searchParams.set("metadata", JSON.stringify(metadata));
    }
    if (projectLink.value) {
      url.searchParams.set("projectSlug", projectLink.value);
    }
    if (options.billingPlanId) {
      url.searchParams.set("planId", options.billingPlanId);
    }
    output_manager_default.debug(`Opening URL: ${url.href}`);
    (0, import_open2.default)(url.href).catch(
      (err) => output_manager_default.debug(`Failed to open browser: ${err}`)
    );
    return 1;
  }
  output_manager_default.debug(
    `Provisioned resource: ${JSON.stringify(result.resource, null, 2)}`
  );
  output_manager_default.debug(`Installation: ${JSON.stringify(result.installation, null, 2)}`);
  output_manager_default.debug(`Billing plan: ${JSON.stringify(result.billingPlan, null, 2)}`);
  output_manager_default.success(
    `${product.name} successfully provisioned: ${import_chalk61.default.bold(resourceName)}`
  );
  return postProvisionSetup(
    client,
    resourceName,
    result.resource.id,
    contextName,
    options
  );
}

// src/util/integration/fetch-billing-plans.ts
async function fetchBillingPlans(client, integration, product, metadata) {
  const searchParams = new URLSearchParams();
  searchParams.set("metadata", JSON.stringify(metadata));
  return client.fetch(
    `/v1/integrations/integration/${integration.id}/products/${product.id}/plans?${searchParams}`,
    {
      json: true
    }
  );
}

// src/util/integration/create-authorization.ts
async function createAuthorization(client, integrationIdOrSlug, installationId, productId, billingPlanId, metadata, prepaymentAmountCents) {
  return await client.fetch("/v1/integrations/billing/authorization", {
    method: "POST",
    json: true,
    body: {
      billingPlanId,
      integrationIdOrSlug,
      integrationConfigurationId: installationId,
      productId,
      metadata: JSON.stringify(metadata),
      prepaymentAmountCents
    }
  });
}

// src/util/integration/fetch-authorization.ts
async function fetchAuthorization(client, authorizationId) {
  return client.fetch(
    `/v1/integrations/billing/authorization/${authorizationId}`,
    {
      json: true
    }
  );
}

// src/commands/integration/add.ts
async function add5(client, args, flags) {
  const resourceNameArg = flags["--name"];
  const metadataFlags = flags["--metadata"];
  const billingPlanId = flags["--plan"];
  const options = {
    noConnect: flags["--no-connect"],
    noEnvPull: flags["--no-env-pull"],
    environments: flags["--environment"]
  };
  if (args.length > 1) {
    output_manager_default.error("Cannot install more than one integration at a time");
    return 1;
  }
  const rawArg = args[0];
  if (!rawArg) {
    output_manager_default.error("You must pass an integration slug");
    return 1;
  }
  let integrationSlug;
  let productSlug;
  const slashIndex = rawArg.indexOf("/");
  if (slashIndex !== -1) {
    integrationSlug = rawArg.substring(0, slashIndex);
    productSlug = rawArg.substring(slashIndex + 1);
    if (!integrationSlug || !productSlug) {
      output_manager_default.error(
        "Invalid format. Expected: <integration-name>/<product-slug>"
      );
      return 1;
    }
  } else {
    integrationSlug = rawArg;
  }
  if (options.environments?.length) {
    const envValidation = validateEnvironments(options.environments);
    if (!envValidation.valid) {
      output_manager_default.error(
        `Invalid environment value: ${envValidation.invalid.map((e2) => `"${e2}"`).join(", ")}. Must be one of: ${VALID_ENVIRONMENTS4.join(", ")}`
      );
      return 1;
    }
  }
  if (process.env.FF_AUTO_PROVISION_INSTALL === "1") {
    return await addAutoProvision(client, integrationSlug, resourceNameArg, {
      productSlug,
      metadata: metadataFlags,
      billingPlanId,
      noConnect: options.noConnect,
      noEnvPull: options.noEnvPull,
      environments: options.environments
    });
  }
  const telemetry2 = new IntegrationAddTelemetryClient({
    opts: {
      store: client.telemetryEventStore
    }
  });
  telemetry2.trackCliOptionName(resourceNameArg);
  telemetry2.trackCliOptionMetadata(metadataFlags);
  telemetry2.trackCliOptionPlan(billingPlanId);
  telemetry2.trackCliFlagNoConnect(options.noConnect);
  telemetry2.trackCliFlagNoEnvPull(options.noEnvPull);
  telemetry2.trackCliOptionEnvironment(options.environments);
  const { contextName, team } = await getScope(client);
  if (!team) {
    output_manager_default.error("Team not found");
    return 1;
  }
  const integration = await fetchIntegrationWithTelemetry(
    client,
    integrationSlug,
    telemetry2
  );
  if (!integration) {
    return 1;
  }
  if (!integration.products?.length) {
    output_manager_default.error(
      `Integration "${integrationSlug}" is not a Marketplace integration`
    );
    return 1;
  }
  const [productResult, installationsResult] = await Promise.allSettled([
    selectProduct(client, integration.products, productSlug),
    fetchInstallations(client, integration)
  ]);
  if (productResult.status === "rejected") {
    output_manager_default.error(
      `Failed to select product: ${productResult.reason.message}`
    );
    return 1;
  }
  if (!productResult.value) {
    if (!productSlug) {
      output_manager_default.error("Product not found");
    }
    return 1;
  }
  if (installationsResult.status === "rejected") {
    output_manager_default.error(
      `Failed to get integration installations: ${installationsResult.reason.message}`
    );
    return 1;
  }
  const product = productResult.value;
  const installations = installationsResult.value;
  const teamInstallations = installations.filter(
    (install2) => install2.ownerId === team.id && install2.installationType === "marketplace"
  );
  if (teamInstallations.length > 1) {
    output_manager_default.error(
      `Found more than one existing installation of ${integration.name}. Please contact Vercel Support at https://vercel.com/help`
    );
    return 1;
  }
  let installation = teamInstallations[0];
  output_manager_default.log(
    `Installing ${import_chalk62.default.bold(product.name)} by ${import_chalk62.default.bold(integration.name)} under ${import_chalk62.default.bold(contextName)}`
  );
  const metadataSchema = product.metadataSchema;
  const metadataWizard = createMetadataWizard(metadataSchema);
  const nameResult = resolveResourceName(product.slug, resourceNameArg);
  if ("error" in nameResult) {
    output_manager_default.error(nameResult.error);
    return 1;
  }
  const { resourceName } = nameResult;
  let parsedMetadata;
  if (metadataFlags?.length) {
    const { metadata: parsed, errors } = parseMetadataFlags(
      metadataFlags,
      metadataSchema
    );
    if (errors.length) {
      for (const error of errors) {
        output_manager_default.error(error);
      }
      return 1;
    }
    parsedMetadata = parsed;
  }
  if (!installation) {
    const acceptedPolicies = await promptForTermAcceptance(client, integration);
    if (!acceptedPolicies) {
      return 1;
    }
    let installResult;
    try {
      installResult = await installMarketplaceIntegration(
        client,
        integration.id,
        acceptedPolicies
      );
    } catch (error) {
      output_manager_default.error(
        `Failed to install integration: ${error.message}`
      );
      return 1;
    }
    installation = {
      id: installResult.id,
      integrationId: integration.id,
      installationType: "marketplace",
      ownerId: team.id
    };
  }
  if (!(parsedMetadata || metadataWizard.isSupported)) {
    const projectLink = await getLinkedProjectField(
      client,
      options.noConnect,
      "id"
    );
    if (projectLink.exitCode) {
      return projectLink.exitCode;
    }
    const openInWeb = await client.input.confirm(
      "This resource must be provisioned through the Web UI. Open Vercel Dashboard?",
      true
    );
    if (openInWeb) {
      provisionResourceViaWebUI(
        team.id,
        integration.id,
        product.id,
        projectLink.value,
        resourceName,
        parsedMetadata,
        billingPlanId
      );
    }
    return 1;
  }
  return await provisionResourceViaCLI(
    client,
    team.id,
    contextName,
    integration,
    installation,
    product,
    metadataWizard,
    resourceName,
    parsedMetadata,
    billingPlanId,
    options
  );
}
function provisionResourceViaWebUI(teamId, integrationId, productId, projectId, resourceName, metadata, billingPlanId) {
  const url = new URL("/api/marketplace/cli", "https://vercel.com");
  url.searchParams.set("teamId", teamId);
  url.searchParams.set("integrationId", integrationId);
  url.searchParams.set("productId", productId);
  url.searchParams.set("source", "cli");
  if (projectId) {
    url.searchParams.set("projectId", projectId);
  }
  if (resourceName) {
    url.searchParams.set("defaultResourceName", resourceName);
  }
  if (metadata && Object.keys(metadata).length > 0) {
    url.searchParams.set("metadata", JSON.stringify(metadata));
  }
  if (billingPlanId) {
    url.searchParams.set("planId", billingPlanId);
  }
  url.searchParams.set("cmd", "add");
  output_manager_default.print("Opening the Vercel Dashboard to continue the installation...");
  output_manager_default.debug(`Opening URL: ${url.href}`);
  (0, import_open3.default)(url.href).catch(
    (err) => output_manager_default.debug(`Failed to open browser: ${err}`)
  );
}
async function installMarketplaceIntegration(client, integrationId, acceptedPolicies) {
  return await client.fetch(
    `/v2/integrations/integration/${encodeURIComponent(integrationId)}/marketplace/install`,
    {
      method: "POST",
      json: true,
      body: { acceptedPolicies, source: "cli" }
    }
  );
}
async function provisionResourceViaCLI(client, teamId, contextName, integration, installation, product, metadataWizard, name, parsedMetadata, billingPlanId, options = {}) {
  let metadata;
  if (parsedMetadata) {
    if (client.stdin.isTTY && metadataWizard.isSupported) {
      metadata = await metadataWizard.run(client, parsedMetadata);
    } else {
      if (!validateAndPrintRequiredMetadata(
        parsedMetadata,
        product.metadataSchema
      )) {
        return 1;
      }
      metadata = parsedMetadata;
    }
  } else if (!client.stdin.isTTY) {
    if (validateRequiredMetadata({}, product.metadataSchema).length > 0) {
      output_manager_default.error(
        "Metadata is required in non-interactive mode. Use --metadata KEY=VALUE flags. Run 'vercel integration add <name> --help' to see available keys."
      );
      return 1;
    }
    metadata = {};
  } else {
    metadata = await metadataWizard.run(client);
  }
  let billingPlans;
  try {
    const billingPlansResponse = await fetchBillingPlans(
      client,
      integration,
      product,
      metadata
    );
    billingPlans = billingPlansResponse.plans;
  } catch (error) {
    output_manager_default.error(`Failed to get billing plans: ${error.message}`);
    return 1;
  }
  const enabledBillingPlans = billingPlans.filter((plan) => !plan.disabled);
  if (!enabledBillingPlans.length) {
    output_manager_default.error("No billing plans available");
    return 1;
  }
  let billingPlan;
  if (billingPlanId) {
    billingPlan = enabledBillingPlans.find((plan) => plan.id === billingPlanId);
    if (!billingPlan) {
      output_manager_default.error(
        `Billing plan "${billingPlanId}" not found. Available plans: ${enabledBillingPlans.map((p) => p.id).join(", ")}`
      );
      return 1;
    }
  } else {
    billingPlan = await selectBillingPlan(client, enabledBillingPlans);
  }
  if (!billingPlan) {
    output_manager_default.error("No billing plan selected");
    return 1;
  }
  if (billingPlan.type !== "subscription") {
    const projectLink = await getLinkedProjectField(
      client,
      options.noConnect,
      "id"
    );
    if (projectLink.exitCode) {
      return projectLink.exitCode;
    }
    const openInWeb = await client.input.confirm(
      "You have selected a plan that cannot be provisioned through the CLI. Open Vercel Dashboard?",
      true
    );
    if (openInWeb) {
      provisionResourceViaWebUI(
        teamId,
        integration.id,
        product.id,
        projectLink.value,
        name,
        metadata,
        billingPlan.id
      );
    }
